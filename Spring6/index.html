
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../Redis7/">
      
      
        <link rel="next" href="../SpringBoot/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.1.3">
    
    
      
        <title>Spring6 - Serendipity_Docs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.c4a75a56.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#spring6" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="Serendipity_Docs" class="md-header__button md-logo" aria-label="Serendipity_Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Serendipity_Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Spring6
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Serendipity_Docs" class="md-nav__button md-logo" aria-label="Serendipity_Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Serendipity_Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        首页
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" class="md-nav__link">
        数据结构和算法
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="md-nav__link">
        微服务
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../C51%E5%8D%95%E7%89%87%E6%9C%BA/" class="md-nav__link">
        C51单片机
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Centos7%E5%AE%89%E8%A3%85Docker/" class="md-nav__link">
        Centos7安装Docker
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Docker%E5%91%BD%E4%BB%A4/" class="md-nav__link">
        Docker操作命令
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../MyBatis-Plus/" class="md-nav__link">
        MyBatis-Plus
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="md-nav__link">
        Nacos集群搭建
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/" class="md-nav__link">
        RabbitMQ部署指南
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Redis7/" class="md-nav__link">
        Redis7
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Spring6
      </a>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../SpringBoot/" class="md-nav__link">
        SpringBoot
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Vue%EF%BC%88%E9%9D%9E%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%89/" class="md-nav__link">
        Vue（非脚手架）
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Vue%EF%BC%88%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%89/" class="md-nav__link">
        Vue（脚手架）
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%E5%AE%89%E8%A3%85elasticsearch/" class="md-nav__link">
        安装elasticsearch
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="md-nav__link">
        计算机网络
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="md-nav__link">
        计算机组成原理
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="md-nav__link">
        习题总结
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="spring6">Spring6</h1>
<h1 id="spring">一、Spring启示录</h1>
<p>阅读以下代码：</p>
<pre><code class="language-java">package com.powernode.oa.controller;

import com.powernode.oa.service.UserService;
import com.powernode.oa.service.impl.UserServiceImpl;

public class UserController {

    private UserService userService = new UserServiceImpl();

    public void login(){
        String username = &quot;admin&quot;;
        String password = &quot;123456&quot;;
        boolean success = userService.login(username, password);
        if (success) {
            // 登录成功
        } else {
            // 登录失败
        }
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.oa.service.impl;

import com.powernode.oa.bean.User;
import com.powernode.oa.dao.UserDao;
import com.powernode.oa.dao.impl.UserDaoImplForMySQL;
import com.powernode.oa.service.UserService;

public class UserServiceImpl implements UserService {

    private UserDao userDao = new UserDaoImplForMySQL();

    public boolean login(String username, String password) {
        User user = userDao.selectByUsernameAndPassword(username, password);
        if (user != null) {
            return true;
        }
        return false;
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.oa.dao.impl;

import com.powernode.oa.bean.User;
import com.powernode.oa.dao.UserDao;

public class UserDaoImplForMySQL implements UserDao {
    public User selectByUsernameAndPassword(String username, String password) {
        // 连接MySQL数据库，根据用户名和密码查询用户信息
        return null;
    }
}
</code></pre>
<p>可以看出，UserDaoImplForMySQL中主要是连接MySQL数据库进行操作。如果更换到Oracle数据库上，则需要再提供一个UserDaoImplForOracle，如下：</p>
<pre><code class="language-java">package com.powernode.oa.dao.impl;

import com.powernode.oa.bean.User;
import com.powernode.oa.dao.UserDao;

public class UserDaoImplForOracle implements UserDao {
    public User selectByUsernameAndPassword(String username, String password) {
        // 连接Oracle数据库，根据用户名和密码查询用户信息
        return null;
    }
}
</code></pre>
<p>很明显，以上的操作正在进行功能的扩展，添加了一个新的类UserDaoImplForOracle来应付数据库的变化，这里的变化会引起连锁反应吗？当然会，如果想要切换到Oracle数据库上，UserServiceImpl类代码就需要修改，如下：</p>
<pre><code class="language-java">package com.powernode.oa.service.impl;

import com.powernode.oa.bean.User;
import com.powernode.oa.dao.UserDao;
import com.powernode.oa.dao.impl.UserDaoImplForOracle;
import com.powernode.oa.service.UserService;

public class UserServiceImpl implements UserService {

    //private UserDao userDao = new UserDaoImplForMySQL();
    private UserDao userDao = new UserDaoImplForOracle();

    public boolean login(String username, String password) {
        User user = userDao.selectByUsernameAndPassword(username, password);
        if (user != null) {
            return true;
        }
        return false;
    }
}
</code></pre>
<h2 id="11-ocp">1.1 OCP开闭原则</h2>
<p>这样一来就违背了开闭原则OCP。开闭原则是这样说的：在软件开发过程中应该<strong>对扩展开放</strong>，<strong>对修改关闭</strong>。也就是说，如果在进行功能扩展的时候，<strong>添加额外的类是没问题的</strong>，但因为功能扩展而<strong>修改之前运行正常写的程序</strong>，这是忌讳的，是不被允许的。因为一旦修改之前运行正常的程序，就会导致项目整体要进行全方位的重新测试。这是想当麻烦的过程，导致以上问题的主要原因是：代码和代码之间的耦<strong>合度太高</strong>。如下图：</p>
<p><img alt="image.png" src="../Spring6.assets/1663658802926-4c783887-3bd3-4a35-b32a-b2cd57d0061c.png" /></p>
<p>从以上图可以明显的看出，<strong>上层</strong>是依赖<strong>下层</strong>的。UserController依赖UserServiceImpl，而UserServiceImpl依赖UserDaoImplForMySQL，这样就会导致<strong>下面只要改动</strong>，<strong>上面必然会受到牵连（跟着也会改动）</strong>，所谓牵一发而动全身，这样也就同时违背了另一个开发原则：<strong>依赖倒置原则</strong></p>
<h2 id="12-dip">1.2 依赖倒置原则DIP</h2>
<p>依赖倒置原则（Dependence Inversion Principle），简称DIP。主要倡导<strong>面向对象编程</strong>，<strong>面向接口编程</strong>，不要面向具体编程，让上层不再依赖下层，下面改动了，上面的代码不会受到牵连。这样就可以大大降低程序的耦合度，耦合度低了，扩展力就增强了，同时代码复用性也会增强。<strong>（软件七大开发原则都是在为解耦合服务）</strong></p>
<p>你可能会说，下面面的代码已经面向接口编程了呀：</p>
<p><img alt="image.png" src="../Spring6.assets/1663663167652-73de3acd-61de-4f32-8a78-6c7698e910d3.png" /></p>
<p>确实已经面向接口编程了，但对象的创建是：new UserDaoImplForOracle()显然并没有完全面向接口编程，还是使用到了具体的接口实现类。什么叫完全面向接口编程？什么叫完全符合依赖倒置原则呢？请看以下代码：</p>
<p><img alt="image.png" src="../Spring6.assets/1663663356201-4e57a395-503b-41ec-b98a-c3cd38f9279a.png" /></p>
<p>如果代码是这样编写的，才算是完全面向想接口编程，才符合依赖倒置原则。那你可能会问，这样userDao是null，在执行的时候就会出现空指针异常啊。是的，确实是这样，所以我们要解决这个问题。解决空指针异常的问题，其实就是解决<strong>两个核心</strong>的问题：</p>
<ol>
<li>谁来负责对象的创建。（也就是说谁来：new UserDaoImplForOracle()/new UserDaoImplForMySQL()）</li>
<li>谁来负责把创建的对象赋到这个属性上。（也就是说谁来把上面创建的对象赋给userDao属性）</li>
</ol>
<p>如果以上两个核心问题解决了，就可以坐到符合OCP开闭原则，又符合DIP依赖倒置原则。</p>
<p>很荣幸的通知你：Spring框架可以做到。</p>
<p>Spring框架中，它可以帮助我们new对象，并且它还可以将new出来的对象赋到属性上。换句话说，Spring框架可以帮助我们创建对象，并且可以帮助我们维护对象与对象之间的关系。比如：</p>
<p><img alt="image.png" src="../Spring6.assets/1663664672011-b1f5c534-5c8b-412b-adb3-f7c60a3ab359.png" /></p>
<p>Spring可以new出来UserDaoImplForMySQL对象，也可以new出来UserDaoImplForOracle对象，并且还可以让new出来的dao对象和service对象产生关系（<strong>产生关系其实本质上就是给属性赋值</strong>）</p>
<p>很显然，这种方式是将对象的创建权/管理权交出去了，不再使用硬编码的方式了。同时也把对象关系的管理权交出去了，也不再使用硬编码的方式了，像这种把对象关系的管理权交出去，被称为<strong>控制反转</strong>。</p>
<h2 id="13-ioc">1.3 控制反转IOC</h2>
<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则</p>
<p>控制反转的核心是：<strong>将对象的创建权交出去，将对象与对象之间关系的管理权交出去，由第三方容器来负责创建与维护</strong></p>
<p>控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI）</p>
<p>通常，依赖注入的实现包括两种方式：</p>
<ol>
<li><strong>set方式注入</strong>（执行set方法给属性赋值）</li>
<li><strong>构造方法注入</strong>（执行构造方法给属性赋值）</li>
</ol>
<p>控制反转是思想，依赖注入是这种思想的具体形式</p>
<p>依赖注入 中 “依赖” 指什么？“注入” 指什么？</p>
<ul>
<li>依赖：A对象和B对象的关系</li>
<li>注入：是一种手段，通过这种手段可以让A对象与B对象产生关系</li>
<li>依赖注入：对象A和对象B之间的关系，靠注入的手段来维护。而注入包括set注入和构造注入</li>
</ul>
<p>而Spring框架急速一个实现了IoC思想的框架</p>
<p>IoC可以认为是<strong>一种全新的设计模式</strong>，但是理论和时间成数相对较晚，并没有包含在GoF中（GoF指的是23种设计模式）</p>
<h2 id="14">1.4 专业术语</h2>
<p>OCP：开闭原则（开发原则）</p>
<p>DIP：依赖倒置原则（开发原则）</p>
<p>IoC：控制反转（一种思想）</p>
<p>DI：依赖注入（控制反转思想的具体实现方式）</p>
<h1 id="spring_1">二、Spring简述</h1>
<h2 id="21-spring">2.1 Spring简介</h2>
<p>Spring是一个开源框架，它由Rod Johnson创建。它是为了解决企业应用开发的复杂性而创建的。
从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。
<strong>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</strong>
<strong>Spring最初的出现是为了解决EJB臃肿的设计，以及难以测试等问题。</strong>
<strong>Spring为简化开发而生，让程序员只需关注核心业务的实现，尽可能的不再关注非业务逻辑代码（事务控制，安全日志等）。</strong></p>
<h2 id="22-spring8">2.2 Spring的8大模块</h2>
<p>注意：Spring5版本之后是8个模块。在Spring5中新增了WebFlux模块。</p>
<p><img alt="image.png" src="../Spring6.assets/1663726169861-b5acb757-17e0-4d3d-a811-400eb7edd1b3.png" /></p>
<ol>
<li>Spring Core模块</li>
</ol>
<p>这是Spring框架最基础的部分，它提供了依赖注入（DependencyInjection）特征来实现容器对Bean的管理。核心容器的主要组件是 BeanFactory，BeanFactory是工厂模式的一个实现，是任何Spring应用的核心。它使用IoC将应用配置和依赖从实际的应用代码中分离出来。</p>
<ol>
<li>Spring Context模块</li>
</ol>
<p>如果说核心模块中的BeanFactory使Spring成为容器的话，那么上下文模块就是Spring成为框架的原因。</p>
<p>这个模块扩展了BeanFactory，增加了对国际化（I18N）消息、事件传播、验证的支持。另外提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持</p>
<ol>
<li>Spring AOP模块</li>
</ol>
<p>Spring在它的AOP模块中提供了对面向切面编程的丰富支持，Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中，可以自定义拦截器、切点、日志等操作。</p>
<ol>
<li>Spring DAO模块</li>
</ol>
<p>提供了一个JDBC的抽象层和异常层次结构，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析，用于简化JDBC。</p>
<ol>
<li>Spring ORM模块</li>
</ol>
<p>Spring提供了ORM模块。Spring并不试图实现它自己的ORM解决方案，而是为几种流行的ORM框架提供了集成方案，包括Hibernate、JDO和iBATIS SQL映射，这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</p>
<ol>
<li>Spring Web MVC模块</li>
</ol>
<p>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts，但Spring的MVC框架使用IoC对控制逻辑和业务对象提供了完全的分离。</p>
<ol>
<li>Spring WebFlux模块</li>
</ol>
<p>Spring Framework 中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器构建的。反应式堆栈 Web 框架 Spring WebFlux 是在 5.0 版的后期添加的。它是完全非阻塞的，支持反应式流(Reactive Stream)背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。</p>
<p><img alt="image.png" src="../Spring6.assets/1663740062570-1823e8ac-1794-4590-87de-87e4a139a722.png" /></p>
<ol>
<li>Spring Web模块</li>
</ol>
<p>Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文，提供了Spring和其它Web框架的集成，比如Struts、WebWork。还提供了一些面向服务支持，例如：实现文件上传的multipart请求。</p>
<h2 id="23-spring">2.3 Spring特点</h2>
<ol>
<li>轻量</li>
<li>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。</li>
<li>Spring是<strong>非侵入式</strong>的：Spring应用中的对象不依赖于Spring的特定类。</li>
<li>控制反转</li>
<li>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</li>
<li>面向切面</li>
<li>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
<li>容器</li>
<li>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</li>
<li>框架</li>
<li>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li>
</ol>
<p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>
<h1 id="spring_2">三、Spring的入门程序</h1>
<h2 id="31-spring">3.1 Spring的下载</h2>
<p>官网地址：https://spring.io/</p>
<p>官网地址（中文）：http://spring.p2hp.com/</p>
<h2 id="32-springjar">3.2 Spring的jar文件</h2>
<p>打开libs目录，会看到很多jar包：</p>
<p><img alt="image.png" src="../Spring6.assets/1663809473261-c5c10c35-7407-44d4-81da-8f0baa236179.png" /></p>
<p>spring-core-5.3.9.jar：字节码（<strong>这个是支撑程序运行的jar包</strong>）
spring-core-5.3.9-javadoc.jar：代码中的注释
spring-core-5.3.9-sources.jar：源码
我们来看一下spring框架都有哪些jar包：</p>
<p><img alt="image.png" src="../Spring6.assets/1663809688152-48c02538-b2c0-4649-a415-3ae25feeadab.png" /></p>
<table>
<thead>
<tr>
<th>JAR文件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>spring-aop-5.3.9.jar</strong></td>
<td align="left"><strong>这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类</strong></td>
</tr>
<tr>
<td><strong>spring-aspects-5.3.9.jar</strong></td>
<td align="left"><strong>提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中</strong></td>
</tr>
<tr>
<td><strong>spring-beans-5.3.9.jar</strong></td>
<td align="left"><strong>这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion ofControl / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。</strong></td>
</tr>
<tr>
<td><strong>spring-context-5.3.9.jar</strong></td>
<td align="left"><strong>这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。</strong></td>
</tr>
<tr>
<td>spring-context-indexer-5.3.9.jar</td>
<td align="left">虽然类路径扫描非常快，但是Spring内部存在大量的类，添加此依赖，可以通过在编译时创建候选对象的静态列表来提高大型应用程序的启动性能。</td>
</tr>
<tr>
<td>spring-context-support-5.3.9.jar</td>
<td align="left">用来提供Spring上下文的一些扩展模块,例如实现邮件服务、视图解析、缓存、定时任务调度等</td>
</tr>
<tr>
<td><strong>spring-core-5.3.9.jar</strong></td>
<td align="left"><strong>Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。</strong></td>
</tr>
<tr>
<td>spring-expression-5.3.9.jar</td>
<td align="left">Spring表达式语言。</td>
</tr>
<tr>
<td>spring-instrument-5.3.9.jar</td>
<td align="left">Spring3.0对服务器的代理接口。</td>
</tr>
<tr>
<td>spring-jcl-5.3.9.jar</td>
<td align="left">Spring的日志模块。JCL，全称为"Jakarta Commons Logging"，也可称为"Apache Commons Logging"。</td>
</tr>
<tr>
<td><strong>spring-jdbc-5.3.9.jar</strong></td>
<td align="left"><strong>Spring对JDBC的支持。</strong></td>
</tr>
<tr>
<td>spring-jms-5.3.9.jar</td>
<td align="left">这个jar包提供了对JMS 1.0.2/1.1的支持类。JMS是Java消息服务。属于JavaEE规范之一。</td>
</tr>
<tr>
<td>spring-messaging-5.3.9.jar</td>
<td align="left">为集成messaging api和消息协议提供支持</td>
</tr>
<tr>
<td>spring-orm-5.3.9.jar</td>
<td align="left">Spring集成ORM框架的支持，比如集成hibernate，mybatis等。</td>
</tr>
<tr>
<td>spring-oxm-5.3.9.jar</td>
<td align="left">为主流O/X Mapping组件提供了统一层抽象和封装，OXM是Object Xml Mapping。对象和XML之间的相互转换。</td>
</tr>
<tr>
<td>spring-r2dbc-5.3.9.jar</td>
<td align="left">Reactive Relational Database Connectivity (关系型数据库的响应式连接) 的缩写。这个jar文件是Spring对r2dbc的支持。</td>
</tr>
<tr>
<td>spring-test-5.3.9.jar</td>
<td align="left">对Junit等测试框架的简单封装。</td>
</tr>
<tr>
<td><strong>spring-tx-5.3.9.jar</strong></td>
<td align="left"><strong>为JDBC、Hibernate、JDO、JPA、Beans等提供的一致的声明式和编程式事务管理支持。</strong></td>
</tr>
<tr>
<td><strong>spring-web-5.3.9.jar</strong></td>
<td align="left"><strong>Spring集成MVC框架的支持，比如集成Struts等。</strong></td>
</tr>
<tr>
<td><strong>spring-webflux-5.3.9.jar</strong></td>
<td align="left"><strong>WebFlux是 Spring5 添加的新模块，用于 web 的开发，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流程响应式编程出现的框架。</strong></td>
</tr>
<tr>
<td><strong>spring-webmvc-5.3.9.jar</strong></td>
<td align="left"><strong>SpringMVC框架的类库</strong></td>
</tr>
<tr>
<td>spring-websocket-5.3.9.jar</td>
<td align="left">Spring集成WebSocket框架时使用</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong>
<strong>如果你只是想用Spring的IoC功能，仅需要引入：spring-context即可。将这个jar包添加到classpath当中。</strong>
<strong>如果采用maven只需要引入context的依赖即可。</strong></p>
<pre><code class="language-XML">&lt;!--Spring6的正式版发布之前，这个仓库地址是需要的--&gt;
&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;repository.spring.milestone&lt;/id&gt;
    &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
    &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
  &lt;!--spring context依赖：使用的是6.0.0-M2里程碑版--&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;6.0.0-M2&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="33-spring">3.3 第一个Spring程序</h2>
<ol>
<li><strong>添加spring context的依赖，pom.xml配置如下</strong></li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.powernode&lt;/groupId&gt;
    &lt;artifactId&gt;spring6-001-first&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;repository.spring.milestone&lt;/id&gt;
            &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;!--spring context依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
&lt;/project&gt;
</code></pre>
<p><strong>注意：打包方式jar。</strong>
当加入spring context的依赖之后，会关联引入其他依赖：
spring aop：面向切面编程
spring beans：IoC核心
spring core：spring的核心工具包
spring jcl：spring的日志包
spring expression：spring表达式</p>
<ol>
<li><strong>添加junit依赖</strong></li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.powernode&lt;/groupId&gt;
    &lt;artifactId&gt;spring6-001-first&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;repository.spring.milestone&lt;/id&gt;
            &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;!--spring context依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<ol>
<li><strong>定义bean：User</strong></li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * bean，封装用户信息。
 * @author 动力节点
 * @version 1.0
 * @since 1.0
 */
public class User {
}
</code></pre>
<ol>
<li>编写spring的配置文件：beans.xml。<strong>该文件放在类的根路径下。</strong></li>
</ol>
<p><img alt="image.png" src="../Spring6.assets/1663816617460-ee35243c-fddc-4771-af28-0017f8af2ab5.png" /></p>
<p>配置文件中进行bean的配置。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>bean的id和class属性：</p>
<ul>
<li><strong>id属性：代表对象的唯一标识。可以看做一个人的身份证号。</strong></li>
<li>
<p><strong>class属性：用来指定要创建的java对象的类名，这个类名必须是全限定类名（带包名）。</strong></p>
</li>
<li>
<p><strong>编写测试程序</strong></p>
</li>
</ul>
<pre><code class="language-java">package com.powernode.spring6.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Spring6Test {

    @Test
    public void testFirst(){
        // 初始化Spring容器上下文（解析beans.xml文件，创建所有的bean对象）
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        // 根据id获取bean对象
        Object userBean = applicationContext.getBean(&quot;userBean&quot;);
        System.out.println(userBean);
    }
}
</code></pre>
<ol>
<li><strong>运行测试程序</strong></li>
</ol>
<p><img alt="image.png" src="../Spring6.assets/1663818370960-22cf8670-7e79-48d2-b4fe-008ead1a6607.png" /></p>
<h2 id="34-spring">3.4 第一个Spring程序详细剖析</h2>
<pre><code class="language-xml">&lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot;/&gt;
</code></pre>
<pre><code class="language-java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
Object userBean = applicationContext.getBean(&quot;userBean&quot;);
</code></pre>
<ol>
<li><strong>bean标签的id属性可以重复吗？</strong></li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className Vip
 * @since 1.0
 **/
public class Vip {
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot;/&gt;
    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.Vip&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>运行测试程序：</p>
<p><img alt="image.png" src="../Spring6.assets/1663829044856-faaf4569-26f0-475b-a8c3-ba28b1753873.png" /></p>
<p><strong>通过测试得出：在spring的配置文件中id是不能重名。</strong></p>
<ol>
<li><strong>底层是怎么创建对象的，是通过反射机制调用无参数构造方法吗？</strong></li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * bean，封装用户信息。
 * @author 动力节点
 * @version 1.0
 * @since 1.0
 */
public class User {
    public User() {
        System.out.println(&quot;User的无参数构造方法执行&quot;);
    }
}
</code></pre>
<p>在User类中添加无参数构造方法，如上。
运行测试程序：</p>
<p><img alt="image.png" src="../Spring6.assets/1663829191565-09e55ce2-e426-4f34-a49d-1ecde4c66dd2.png" /></p>
<p><strong>通过测试得知：创建对象时确实调用了无参数构造方法。</strong>
如果提供一个有参数构造方法，不提供无参数构造方法会怎样呢？</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * bean，封装用户信息。
 * @author 动力节点
 * @version 1.0
 * @since 1.0
 */
public class User {
    /*public User() {
        System.out.println(&quot;User的无参数构造方法执行&quot;);
    }*/

    public User(String name){
        System.out.println(&quot;User的有参数构造方法执行&quot;);
    }
}
</code></pre>
<p>运行测试程序：</p>
<p><img alt="image.png" src="../Spring6.assets/1663829413955-bda77d32-bf39-44e2-bbd8-0ed87f72bd7e.png" /></p>
<p><strong>通过测试得知：spring是通过调用类的无参数构造方法来创建对象的，所以要想让spring给你创建对象，必须保证无参数构造方法是存在的。</strong>
Spring是如何创建对象的呢？原理是什么？</p>
<pre><code class="language-java">// dom4j解析beans.xml文件，从中获取class的全限定类名
// 通过反射机制调用无参数构造方法创建对象
Class clazz = Class.forName(&quot;com.powernode.spring6.bean.User&quot;);
Object obj = clazz.newInstance();
</code></pre>
<ol>
<li><strong>把创建好的对象存储到一个什么样的数据结构当中了呢？</strong></li>
</ol>
<p><img alt="image.png" src="../Spring6.assets/1663829973365-59ca2f4c-4d81-471f-8e4c-aa272f8c2b81.png" /></p>
<ol>
<li><strong>spring配置文件的名字必须叫做beans.xml吗？</strong></li>
</ol>
<pre><code class="language-java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
</code></pre>
<p>通过以上的java代码可以看出，这个spring配置文件名字是我们负责提供的，显然spring配置文件的名字是随意的</p>
<ol>
<li><strong>像这样的beans.xml文件可以有多个吗？</strong></li>
</ol>
<p>再创建一个spring配置文件，起名：spring.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;vipBean&quot; class=&quot;com.powernode.spring6.bean.Vip&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Spring6Test {

    @Test
    public void testFirst(){
        // 初始化Spring容器上下文（解析beans.xml文件，创建所有的bean对象）
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;,&quot;spring.xml&quot;);

        // 根据id获取bean对象
        Object userBean = applicationContext.getBean(&quot;userBean&quot;);
        Object vipBean = applicationContext.getBean(&quot;vipBean&quot;);

        System.out.println(userBean);
        System.out.println(vipBean);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1663830539482-a0454bc6-9d9b-41cb-81c3-1c02e58d3669.png" /></p>
<p>通过测试得知，spring的配置文件可以有多个，在ClassPathXmlApplicationContext构造方法的参数上传递文件路径即可。这是为什么呢？通过源码可以看到：</p>
<p><img alt="image.png" src="../Spring6.assets/1663830614508-d00ecc07-5b51-4d2d-bc1d-8f2cb4f0c785.png" /></p>
<ol>
<li><strong>在配置文件中配置的类必须是自定义的吗，可以使用JDK中的类吗，例如：java.util.Date？</strong></li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot;/&gt;
    &lt;!--&lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.Vip&quot;/&gt;--&gt;

    &lt;bean id=&quot;dateBean&quot; class=&quot;java.util.Date&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Spring6Test {

    @Test
    public void testFirst(){
        // 初始化Spring容器上下文（解析beans.xml文件，创建所有的bean对象）
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;,&quot;spring.xml&quot;);

        // 根据id获取bean对象
        Object userBean = applicationContext.getBean(&quot;userBean&quot;);
        Object vipBean = applicationContext.getBean(&quot;vipBean&quot;);
        Object dateBean = applicationContext.getBean(&quot;dateBean&quot;);

        System.out.println(userBean);
        System.out.println(vipBean);
        System.out.println(dateBean);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1663830975135-0fce3972-3b4e-4f54-878a-a4058f8d6ca6.png" /></p>
<p>通过测试得知，在spring配置文件中配置的bean可以任意类，只要这个类不是抽象的，并且提供了无参数构造方法。</p>
<ol>
<li><strong>getBean()方法调用时，如果指定的id不存在会怎样？</strong></li>
</ol>
<p><img alt="image.png" src="../Spring6.assets/1663831841228-eda809d8-3e51-4b08-913c-76ff78efae1f.png" /></p>
<p><img alt="image.png" src="../Spring6.assets/1663831885196-43acddcf-29e5-46b7-814c-33c4dfe78386.png" /></p>
<p>通过测试得知，当id不存在的时候，会出现异常。</p>
<ol>
<li><strong>getBean()方法返回的类型是Object，如果访问子类的特有属性和方法时，还需要向下转型，有其它办法可以解决这个问题吗？</strong></li>
</ol>
<pre><code class="language-java">User user = applicationContext.getBean(&quot;userBean&quot;, User.class);
</code></pre>
<ol>
<li><strong>ClassPathXmlApplicationContext是从类路径中加载配置文件，如果没有在类路径当中，又应该如何加载配置文件呢？</strong></li>
</ol>
<p><img alt="image.png" src="../Spring6.assets/1663832523920-8df601e0-1fd3-43c2-92ad-dc57207b006a.png" /></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;vipBean2&quot; class=&quot;com.powernode.spring6.bean.Vip&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">ApplicationContext applicationContext2 = new FileSystemXmlApplicationContext(&quot;d:/spring6.xml&quot;);
Vip vip = applicationContext2.getBean(&quot;vipBean2&quot;, Vip.class);
System.out.println(vip);
</code></pre>
<p>没有在类路径中的话，需要使用FileSystemXmlApplicationContext类进行加载配置文件。
这种方式较少用。一般都是将配置文件放到类路径当中，这样可移植性更强。</p>
<ol>
<li><strong>ApplicationContext的超级父接口BeanFactory。</strong></li>
</ol>
<pre><code class="language-java">BeanFactory beanFactory = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
Object vipBean = beanFactory.getBean(&quot;vipBean&quot;);
System.out.println(vipBean);
</code></pre>
<p>BeanFactory是Spring容器的<strong>超级接口</strong>。ApplicationContext是BeanFactory的<strong>子接口</strong>。</p>
<h2 id="35-spring6log4j2">3.5 Spring6启用Log4j2日志框架</h2>
<p>从Spring5之后，Spring框架支持集成的日志框架是Log4j2.如何启用日志框架：</p>
<ol>
<li>引入Log4j2的依赖</li>
</ol>
<pre><code class="language-xml">&lt;!--log4j2的依赖--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
  &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
  &lt;version&gt;2.19.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
  &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;
  &lt;version&gt;2.19.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li>在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，<strong>文件必须放到类根路径下</strong>。）</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;

    &lt;loggers&gt;
        &lt;!--
            level指定日志级别，从低到高的优先级：
                ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF
        --&gt;
        &lt;root level=&quot;DEBUG&quot;&gt;
            &lt;appender-ref ref=&quot;spring6log&quot;/&gt;
        &lt;/root&gt;
    &lt;/loggers&gt;

    &lt;appenders&gt;
        &lt;!--输出日志信息到控制台--&gt;
        &lt;console name=&quot;spring6log&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!--控制日志输出的格式--&gt;
            &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n&quot;/&gt;
        &lt;/console&gt;
    &lt;/appenders&gt;

&lt;/configuration&gt;
</code></pre>
<ol>
<li>使用日志框架</li>
</ol>
<pre><code class="language-java">Logger logger = LoggerFactory.getLogger(FirstSpringTest.class);
logger.info(&quot;我是一条日志消息&quot;);
</code></pre>
<h1 id="springioc">四、Spring对IoC的实现</h1>
<h2 id="41-ioc">4.1 IoC控制反转</h2>
<ul>
<li>控制反转是一种思想</li>
<li>控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则、DIP原则</li>
<li>控制反转，反转的是什么？</li>
<li>将对象的创建权交出去，交给第三方容器负责</li>
<li>将对象之间关系的维护权交出去，交给第三方容器负责</li>
<li>控制反转这种思想如何实现？</li>
<li>DI（Dependency Injection）：依赖注入</li>
</ul>
<h2 id="42">4.2 依赖注入</h2>
<p>依赖注入实现了控制反转的思想</p>
<p><strong>Spring通过依赖注入的方式来完成Bean的管理</strong></p>
<p><strong>Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）</strong></p>
<p>依赖注入：</p>
<ul>
<li>依赖指的是对象和对象之间的关联关系</li>
<li>注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系</li>
</ul>
<p>依赖注入常见的实现方式包括两种：</p>
<ol>
<li>set注入</li>
<li>构造注入</li>
</ol>
<h3 id="421-set">4.2.1 set注入</h3>
<p>set注入，基于set方法实现，底层会通过反射机制调用属性对应的set方法然后给属性赋值。这种方式要求属性必须对外提供set方法</p>
<p>UserDao</p>
<pre><code class="language-java">package com.powernode.spring6.dao;

/**
 * @author 动力节点
 * @version 1.0
 * @className UserDao
 * @since 1.0
 **/
public class UserDao {

    public void insert(){
        System.out.println(&quot;正在保存用户数据。&quot;);
    }
}
</code></pre>
<p>UserService</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;

/**
 * @author 动力节点
 * @version 1.0
 * @className UserService
 * @since 1.0
 **/
public class UserService {

    private UserDao userDao;

    // 使用set方式注入，必须提供set方法。
    // 反射机制要调用这个方法给属性赋值的。
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;

    &lt;bean id=&quot;userServiceBean&quot; class=&quot;com.powernode.spring6.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试程序</p>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.service.UserService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @author 动力节点
 * @version 1.0
 * @className DITest
 * @since 1.0
 **/
public class DITest {

    @Test
    public void testSetDI(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        UserService userService = applicationContext.getBean(&quot;userServiceBean&quot;, UserService.class);
        userService.save();
    }
}
</code></pre>
<p>运行结果：</p>
<p><img alt="image.png" src="../Spring6.assets/1663905094332-411b6249-dcf5-48df-830f-33335846bed8.png" /></p>
<p>重点内容是，什么原理：</p>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;

    &lt;bean id=&quot;userServiceBean&quot; class=&quot;com.powernode.spring6.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>实现原理：</p>
<p>通过property标签获取到属性名：userDao</p>
<p>通过属性名推断出set方法名：setUserDao</p>
<p>通过反射机制调用setUserDao()方法给属性赋值</p>
<p>property标签的name是属性名</p>
<p>property标签的ref是要注入的bean对象的id。（通过ref属性来完成bean的装配，这是bean最简单的一种装配方式。装配指的是：创建系统组件之间关联的动作）</p>
<p><strong>可以把set方法注释掉，再测试一下：</strong></p>
<p><img alt="image.png" src="../Spring6.assets/1663905304326-b982124b-3dea-4a3a-b808-53403627a791.png" /></p>
<p>通过测试得知，底层实际上调用了setUserDao()方法，所以需要确保这个方法的存在</p>
<p>我们现在把属性名修改一下，但方法名还是setUserDao()，我们来测试一下：</p>
<p>UserService:</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;

/**
 * @author 动力节点
 * @version 1.0
 * @className UserService
 * @since 1.0
 **/
public class UserService {

    private UserDao aaa;

    // 使用set方式注入，必须提供set方法。
    // 反射机制要调用这个方法给属性赋值的。
    public void setUserDao(UserDao userDao) {
        this.aaa = userDao;
    }

    public void save(){
        aaa.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1663913608149-ae3df3f6-cff3-4189-9b57-9b6e41e5e157.png" /></p>
<p>通过测试看到程序仍然可以正常执行，说明property标签的name是：setUserDao()方法名演变得到的，演变的规律是：</p>
<ul>
<li>setUsername() 演变为 username</li>
<li>setPassword() 演变为 password</li>
<li>setUserDao() 演变为 userDao</li>
<li>setUserService() 演变为 userService</li>
</ul>
<p>另外，对于property标签来首，ref属性也可以采用标签的方式，但使用ref属性是多数的</p>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;userServiceBean&quot; class=&quot;com.powernode.spring6.service.UserService&quot;&gt;
  &lt;property name=&quot;userDao&quot;&gt;
    &lt;ref bean=&quot;userDaoBean&quot;/&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>总结：set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系</strong></p>
<h3 id="422">4.2.2 构造注入</h3>
<p>核心原理：通过调用构造方法来给属性赋值。</p>
<p>OrderDao</p>
<pre><code class="language-java">package com.powernode.spring6.dao;

/**
 * @author 动力节点
 * @version 1.0
 * @className OrderDao
 * @since 1.0
 **/
public class OrderDao {
    public void deleteById(){
        System.out.println(&quot;正在删除订单。。。&quot;);
    }
}
</code></pre>
<p>OrderService</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.OrderDao;

/**
 * @author 动力节点
 * @version 1.0
 * @className OrderService
 * @since 1.0
 **/
public class OrderService {
    private OrderDao orderDao;

    // 通过反射机制调用构造方法给属性赋值
    public OrderService(OrderDao orderDao) {
        this.orderDao = orderDao;
    }

    public void delete(){
        orderDao.deleteById();
    }
}
</code></pre>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;orderDaoBean&quot; class=&quot;com.powernode.spring6.dao.OrderDao&quot;/&gt;
&lt;bean id=&quot;orderServiceBean&quot; class=&quot;com.powernode.spring6.service.OrderService&quot;&gt;
  &lt;!--index=&quot;0&quot;表示构造方法的第一个参数，将orderDaoBean对象传递给构造方法的第一个参数。--&gt;
  &lt;constructor-arg index=&quot;0&quot; ref=&quot;orderDaoBean&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试程序</p>
<pre><code class="language-java">@Test
public void testConstructorDI(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    OrderService orderServiceBean = applicationContext.getBean(&quot;orderServiceBean&quot;, OrderService.class);
    orderServiceBean.delete();
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1663916302936-91af70a1-30f4-4527-b92c-f9d3c83128ca.png" /></p>
<p><strong>如果构造方法有两个参数：</strong></p>
<p>OrderService</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.OrderDao;
import com.powernode.spring6.dao.UserDao;

/**
 * @author 动力节点
 * @version 1.0
 * @className OrderService
 * @since 1.0
 **/
public class OrderService {
    private OrderDao orderDao;
    private UserDao userDao;

    // 通过反射机制调用构造方法给属性赋值
    public OrderService(OrderDao orderDao, UserDao userDao) {
        this.orderDao = orderDao;
        this.userDao = userDao;
    }

    public void delete(){
        orderDao.deleteById();
        userDao.insert();
    }
}
</code></pre>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;orderDaoBean&quot; class=&quot;com.powernode.spring6.dao.OrderDao&quot;/&gt;

&lt;bean id=&quot;orderServiceBean&quot; class=&quot;com.powernode.spring6.service.OrderService&quot;&gt;
  &lt;!--第一个参数下标是0--&gt;
  &lt;constructor-arg index=&quot;0&quot; ref=&quot;orderDaoBean&quot;/&gt;
  &lt;!--第二个参数下标是1--&gt;
  &lt;constructor-arg index=&quot;1&quot; ref=&quot;userDaoBean&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1664347904052-41cd13ad-f38f-41f0-949d-a339a30a24f0.png" /></p>
<p><strong>不使用参数下标，使用参数的名字可以吗？</strong></p>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;orderDaoBean&quot; class=&quot;com.powernode.spring6.dao.OrderDao&quot;/&gt;

&lt;bean id=&quot;orderServiceBean&quot; class=&quot;com.powernode.spring6.service.OrderService&quot;&gt;
  &lt;!--这里使用了构造方法上参数的名字--&gt;
  &lt;constructor-arg name=&quot;orderDao&quot; ref=&quot;orderDaoBean&quot;/&gt;
  &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1664348053136-ecd18e6d-af92-416b-9c60-8025d929c202.png" /></p>
<p><strong>不指定参数下标，不指定参数名字，可以吗？</strong></p>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;orderDaoBean&quot; class=&quot;com.powernode.spring6.dao.OrderDao&quot;/&gt;
&lt;bean id=&quot;orderServiceBean&quot; class=&quot;com.powernode.spring6.service.OrderService&quot;&gt;
  &lt;!--没有指定下标，也没有指定参数名字--&gt;
  &lt;constructor-arg ref=&quot;orderDaoBean&quot;/&gt;
  &lt;constructor-arg ref=&quot;userDaoBean&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1664348190304-b4da661d-2fa7-4acb-8d32-b60b0112113e.png" /></p>
<p><strong>配置文件中构造方法参数的类型顺序和构造方法参数的类型顺序不一致呢？</strong></p>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;orderDaoBean&quot; class=&quot;com.powernode.spring6.dao.OrderDao&quot;/&gt;

&lt;bean id=&quot;orderServiceBean&quot; class=&quot;com.powernode.spring6.service.OrderService&quot;&gt;
  &lt;!--顺序已经和构造方法的参数顺序不同了--&gt;
  &lt;constructor-arg ref=&quot;userDaoBean&quot;/&gt;
  &lt;constructor-arg ref=&quot;orderDaoBean&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1664348350392-94e354b2-143e-4ebf-8af3-23e957d6a434.png" /></p>
<p>通过测试得知，通过构造方法注入的时候</p>
<ul>
<li>可以通过下标</li>
<li>可以通过参数名</li>
<li>也可以不指定下标和参数名，可以类型自动推断</li>
</ul>
<h2 id="43-set">4.3 set注入专题</h2>
<h3 id="431-bean">4.3.1 注入外部Bean</h3>
<p>在之前4.2.1中使用的案例就是注入外部Bean的方式。</p>
<p>spring.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;

    &lt;bean id=&quot;userServiceBean&quot; class=&quot;com.powernode.spring6.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>外部Bean的特点：bean定义到外面，在property变迁中使用ref属性进行注入，通常这种方式是常用</p>
<h3 id="432-bean">4.3.2 注入内部Bean</h3>
<p>内部Bean的方式：在bean标签中嵌套bean标签。</p>
<p>spring-inner-bean.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userServiceBean&quot; class=&quot;com.powernode.spring6.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot;&gt;
            &lt;bean class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>DITest.testInnerBean()</p>
<pre><code class="language-java">@Test
public void testInnerBean(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-inner-bean.xml&quot;);
    UserService userService = applicationContext.getBean(&quot;userServiceBean&quot;, UserService.class);
    userService.save();
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1664443574869-143a6d21-9b3f-4eaa-bd9c-6d9b0e9908b5.png" /></p>
<p>这种方式作为了解。</p>
<h3 id="433">4.3.3 注入简单类型</h3>
<p>我们之前在进行注入的时候，对象的属性是另一个对象。</p>
<pre><code class="language-java">public class UserService{

    private UserDao userDao;

    public void setUserDao(UserDao userDao){
        this.userDao = userDao;
    }

}
</code></pre>
<p>那如果对象的属性是int类型呢？</p>
<pre><code class="language-java">public class User{
    private int age;
    public void setAge(int age){
        this.age = age;
    }
}
</code></pre>
<p>可以通过set注入的方式给该属性赋值吗？</p>
<ul>
<li>当然可以，因为只要能够调用set方法就可以给属性赋值</li>
</ul>
<p><strong>编写程序给一个User对象的age属性赋值20：</strong></p>
<ol>
<li>定义User类，提供age属性，提供age属性的setter方法。</li>
</ol>
<p>User</p>
<pre><code class="language-java">package com.powernode.spring6.beans;
/**
 * @author 动力节点
 * @version 1.0
 * @className User
 * @since 1.0
 **/
public class User {
    private int age;
    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;age=&quot; + age +
                '}';
    }
}
</code></pre>
<ol>
<li>编写spring配置文件：spring-simple-type.xml</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.beans.User&quot;&gt;
        &lt;!--如果像这种int类型的属性，我们称为简单类型，这种简单类型在注入的时候要使用value属性，不能使用ref--&gt;
        &lt;!--&lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;--&gt;
        &lt;property name=&quot;age&quot;&gt;
            &lt;value&gt;20&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol>
<li>编写测试程序</li>
</ol>
<pre><code class="language-java">@Test
public void testSimpleType(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-simple-type.xml&quot;);
    User user = applicationContext.getBean(&quot;userBean&quot;, User.class);
    System.out.println(user);
}
</code></pre>
<p><img alt="1664444974497(1).png" src="../Spring6.assets/1664444978134-0cdbca10-4322-4e31-a2f8-a177d3ae2e75.png" /></p>
<p><strong>需要特别注意：如果给简单类型赋值，使用value属性或value标签。而不是ref</strong></p>
<p>简单类型包括哪些呢？可以通过Spring的源码来分析一下：BeanUtils类</p>
<p>BeanUtils</p>
<pre><code class="language-java">public class BeanUtils{

    //.......

    /**
     * Check if the given type represents a &quot;simple&quot; property: a simple value
     * type or an array of simple value types.
     * &lt;p&gt;See {@link #isSimpleValueType(Class)} for the definition of &lt;em&gt;simple
     * value type&lt;/em&gt;.
     * &lt;p&gt;Used to determine properties to check for a &quot;simple&quot; dependency-check.
     * @param type the type to check
     * @return whether the given type represents a &quot;simple&quot; property
     * @see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE
     * @see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies
     * @see #isSimpleValueType(Class)
     */
    public static boolean isSimpleProperty(Class&lt;?&gt; type) {
        Assert.notNull(type, &quot;'type' must not be null&quot;);
        return isSimpleValueType(type) || (type.isArray() &amp;&amp; isSimpleValueType(type.getComponentType()));
    }

    /**
     * Check if the given type represents a &quot;simple&quot; value type: a primitive or
     * primitive wrapper, an enum, a String or other CharSequence, a Number, a
     * Date, a Temporal, a URI, a URL, a Locale, or a Class.
     * &lt;p&gt;{@code Void} and {@code void} are not considered simple value types.
     * @param type the type to check
     * @return whether the given type represents a &quot;simple&quot; value type
     * @see #isSimpleProperty(Class)
     */
    public static boolean isSimpleValueType(Class&lt;?&gt; type) {
        return (Void.class != type &amp;&amp; void.class != type &amp;&amp;
                (ClassUtils.isPrimitiveOrWrapper(type) ||
                Enum.class.isAssignableFrom(type) ||
                CharSequence.class.isAssignableFrom(type) ||
                Number.class.isAssignableFrom(type) ||
                Date.class.isAssignableFrom(type) ||
                Temporal.class.isAssignableFrom(type) ||
                URI.class == type ||
                URL.class == type ||
                Locale.class == type ||
                Class.class == type));
    }

    //........
}
</code></pre>
<p><strong>通过源码分析得知，简单类型包括：</strong></p>
<ul>
<li><strong>基本数据类型</strong></li>
<li><strong>剧本数据类型对应的包装类</strong></li>
<li><strong>Sting或其他的CharSequence子类</strong></li>
<li><strong>Number子类</strong></li>
<li><strong>Date子类</strong></li>
<li><strong>Enum子类</strong></li>
<li><strong>URI</strong></li>
<li><strong>URL</strong></li>
<li><strong>Temporal子类</strong></li>
<li><strong>Locale</strong></li>
<li><strong>Class</strong></li>
<li><strong>另外还包括以上简单值类型对应的数据类型</strong></li>
</ul>
<p><strong>经典案例：给数据源的属性注入值：</strong></p>
<p>假设我们现在要自己手写一个数据源，我们都知道所有的数据源都要实现javax.sql.DataSource接口，并且数据源中应该有连接数据库的信息，例如：driver、url、username、password等</p>
<p>MyDataSource</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import javax.sql.DataSource;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;

/**
 * @author 动力节点
 * @version 1.0
 * @className MyDataSource
 * @since 1.0
 **/
public class MyDataSource implements DataSource {
    private String driver;
    private String url;
    private String username;
    private String password;

    public void setDriver(String driver) {
        this.driver = driver;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return &quot;MyDataSource{&quot; +
                &quot;driver='&quot; + driver + '\'' +
                &quot;, url='&quot; + url + '\'' +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}';
    }

    @Override
    public Connection getConnection() throws SQLException {
        return null;
    }

    @Override
    public Connection getConnection(String username, String password) throws SQLException {
        return null;
    }

    @Override
    public PrintWriter getLogWriter() throws SQLException {
        return null;
    }

    @Override
    public void setLogWriter(PrintWriter out) throws SQLException {

    }

    @Override
    public void setLoginTimeout(int seconds) throws SQLException {

    }

    @Override
    public int getLoginTimeout() throws SQLException {
        return 0;
    }

    @Override
    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
        return null;
    }

    @Override
    public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException {
        return null;
    }

    @Override
    public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException {
        return false;
    }
}
</code></pre>
<p>我们给driver、url、username、password四个属性分别提供了setter方法，我们可以使用spring的依赖注入完成数据源对象的创建和属性的赋值吗？看配置文件</p>
<p>spring-datasource.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;com.powernode.spring6.beans.MyDataSource&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试程序：</p>
<pre><code class="language-java">@Test
public void testDataSource(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;);
    MyDataSource dataSource = applicationContext.getBean(&quot;dataSource&quot;, MyDataSource.class);
    System.out.println(dataSource);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1664445950974-57eb35af-c4ad-47c7-9a70-341d61596656.png" /></p>
<p><strong>接下来，我们编写一个程序，把所有的简单类型全部测试一遍：</strong></p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.net.URI;
import java.net.URL;
import java.time.LocalDate;
import java.util.Date;
import java.util.Locale;

/**
 * @author 动力节点
 * @version 1.0
 * @className A
 * @since 1.0
 **/
public class A {
    private byte b;
    private short s;
    private int i;
    private long l;
    private float f;
    private double d;
    private boolean flag;
    private char c;

    private Byte b1;
    private Short s1;
    private Integer i1;
    private Long l1;
    private Float f1;
    private Double d1;
    private Boolean flag1;
    private Character c1;

    private String str;

    private Date date;

    private Season season;

    private URI uri;

    private URL url;

    private LocalDate localDate;

    private Locale locale;

    private Class clazz;

    // 生成setter方法
    // 生成toString方法
}

enum Season {
    SPRING, SUMMER, AUTUMN, WINTER
}
</code></pre>
<p>spring-all-simple-type.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;a&quot; class=&quot;com.powernode.spring6.beans.A&quot;&gt;
        &lt;property name=&quot;b&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;s&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;i&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;l&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;f&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;d&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;flag&quot; value=&quot;false&quot;/&gt;

        &lt;property name=&quot;c&quot; value=&quot;a&quot;/&gt;
        &lt;property name=&quot;b1&quot; value=&quot;2&quot;/&gt;
        &lt;property name=&quot;s1&quot; value=&quot;2&quot;/&gt;
        &lt;property name=&quot;i1&quot; value=&quot;2&quot;/&gt;
        &lt;property name=&quot;l1&quot; value=&quot;2&quot;/&gt;
        &lt;property name=&quot;f1&quot; value=&quot;2&quot;/&gt;
        &lt;property name=&quot;d1&quot; value=&quot;2&quot;/&gt;
        &lt;property name=&quot;flag1&quot; value=&quot;true&quot;/&gt;
        &lt;property name=&quot;c1&quot; value=&quot;a&quot;/&gt;

        &lt;property name=&quot;str&quot; value=&quot;zhangsan&quot;/&gt;
        &lt;!--注意：value后面的日期字符串格式不能随便写，必须是Date对象toString()方法执行的结果。--&gt;
        &lt;!--如果想使用其他格式的日期字符串，就需要进行特殊处理了。具体怎么处理，可以看后面的课程！！！！--&gt;
        &lt;property name=&quot;date&quot; value=&quot;Fri Sep 30 15:26:38 CST 2022&quot;/&gt;
        &lt;property name=&quot;season&quot; value=&quot;WINTER&quot;/&gt;
        &lt;property name=&quot;uri&quot; value=&quot;/save.do&quot;/&gt;
        &lt;!--spring6之后，会自动检查url是否有效，如果无效会报错。--&gt;
        &lt;property name=&quot;url&quot; value=&quot;http://www.baidu.com&quot;/&gt;
        &lt;property name=&quot;localDate&quot; value=&quot;EPOCH&quot;/&gt;
        &lt;!--java.util.Locale 主要在软件的本地化时使用。它本身没有什么功能，更多的是作为一个参数辅助其他方法完成输出的本地化。--&gt;
        &lt;property name=&quot;locale&quot; value=&quot;CHINESE&quot;/&gt;
        &lt;property name=&quot;clazz&quot; value=&quot;java.lang.String&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>编写测试程序：</p>
<pre><code class="language-java">@Test
public void testAllSimpleType(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-all-simple-type.xml&quot;);
    A a = applicationContext.getBean(&quot;a&quot;, A.class);
    System.out.println(a);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1664524514681-c680e261-eeaf-4536-b5db-e4f28361a03d.png" /></p>
<p><strong>需要注意的是：</strong></p>
<ul>
<li><strong>如果吧Date当做简单类型的话，日期字符串格式不能随便写。格式必须符合Date的toString()方法格式。显然这就比较鸡肋了。如果我们提供一个这样的日期字符串：2010-10-11，在这里是无法赋值给Date类型的属性的。</strong></li>
<li><strong>spring6之后，当注入的是URL，那么这个url字符串是会进行有效性检测的，如果是一个存在的url，那就没问题。如果不存在则报错</strong></li>
</ul>
<h3 id="434">4.3.4 级联属性赋值（了解）</h3>
<p>Clazz</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className Clazz
 * @since 1.0
 **/
public class Clazz {
    private String name;

    public Clazz() {
    }

    public Clazz(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Clazz{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>Student</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className Student
 * @since 1.0
 **/
public class Student {
    private String name;
    private Clazz clazz;

    public Student() {
    }

    public Student(String name, Clazz clazz) {
        this.name = name;
        this.clazz = clazz;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setClazz(Clazz clazz) {
        this.clazz = clazz;
    }

    public Clazz getClazz() {
        return clazz;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, clazz=&quot; + clazz +
                '}';
    }
}
</code></pre>
<p>spring-cascade.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;clazzBean&quot; class=&quot;com.powernode.spring6.beans.Clazz&quot;/&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.powernode.spring6.beans.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;

        &lt;!--要点1：以下两行配置的顺序不能颠倒--&gt;
        &lt;property name=&quot;clazz&quot; ref=&quot;clazzBean&quot;/&gt;
        &lt;!--要点2：clazz属性必须有getter方法--&gt;
        &lt;property name=&quot;clazz.name&quot; value=&quot;高三一班&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testCascade(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-cascade.xml&quot;);
    Student student = applicationContext.getBean(&quot;student&quot;, Student.class);
    System.out.println(student);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665196735272-17e84eb6-8dcd-4c69-9ed7-e35c7c8ad36d.png" /></p>
<p><strong>要点：</strong></p>
<ul>
<li><strong>在spring配置文件中，如上，注意顺序</strong></li>
<li><strong>在spring配置文件中，clazz属性必须提供getter方法</strong></li>
</ul>
<h3 id="435">4.3.5 注入数组</h3>
<p>当数组中的元素是简单类型：</p>
<p>Person</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.Arrays;

public class Person {
    private String[] favariteFoods;

    public void setFavariteFoods(String[] favariteFoods) {
        this.favariteFoods = favariteFoods;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;favariteFoods=&quot; + Arrays.toString(favariteFoods) +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;person&quot; class=&quot;com.powernode.spring6.beans.Person&quot;&gt;
        &lt;property name=&quot;favariteFoods&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;鸡排&lt;/value&gt;
                &lt;value&gt;汉堡&lt;/value&gt;
                &lt;value&gt;鹅肝&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testArraySimple(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-array-simple.xml&quot;);
    Person person = applicationContext.getBean(&quot;person&quot;, Person.class);
    System.out.println(person);
}
</code></pre>
<p><strong>当数组中的元素是非简单类型：一个订单中包含多个商品。</strong></p>
<p>Goods</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className Goods
 * @since 1.0
 **/
public class Goods {
    private String name;

    public Goods() {
    }

    public Goods(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Goods{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>Order</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.Arrays;

/**
 * @author 动力节点
 * @version 1.0
 * @className Order
 * @since 1.0
 **/
public class Order {
    // 一个订单中有多个商品
    private Goods[] goods;

    public Order() {
    }

    public Order(Goods[] goods) {
        this.goods = goods;
    }

    public void setGoods(Goods[] goods) {
        this.goods = goods;
    }

    @Override
    public String toString() {
        return &quot;Order{&quot; +
                &quot;goods=&quot; + Arrays.toString(goods) +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;goods1&quot; class=&quot;com.powernode.spring6.beans.Goods&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;西瓜&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;goods2&quot; class=&quot;com.powernode.spring6.beans.Goods&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;苹果&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;order&quot; class=&quot;com.powernode.spring6.beans.Order&quot;&gt;
        &lt;property name=&quot;goods&quot;&gt;
            &lt;array&gt;
                &lt;!--这里使用ref标签即可--&gt;
                &lt;ref bean=&quot;goods1&quot;/&gt;
                &lt;ref bean=&quot;goods2&quot;/&gt;
            &lt;/array&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testArray(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-array.xml&quot;);
    Order order = applicationContext.getBean(&quot;order&quot;, Order.class);
    System.out.println(order);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665193773078-0a30da90-244d-460e-bc2c-901d99873668.png" /></p>
<p><strong>要点：</strong></p>
<ul>
<li><strong>如果数组中是简单类型，使用value标签</strong></li>
<li><strong>如果数组中是非简单类型，使用ref标签</strong></li>
</ul>
<h3 id="436-list">4.3.6 注入List集合</h3>
<p>List集合：有序可重复</p>
<p>People</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.List;

/**
 * @author 动力节点
 * @version 1.0
 * @className People
 * @since 1.0
 **/
public class People {
    // 一个人有多个名字
    private List&lt;String&gt; names;

    public void setNames(List&lt;String&gt; names) {
        this.names = names;
    }

    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;names=&quot; + names +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;peopleBean&quot; class=&quot;com.powernode.spring6.beans.People&quot;&gt;
        &lt;property name=&quot;names&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;铁锤&lt;/value&gt;
                &lt;value&gt;张三&lt;/value&gt;
                &lt;value&gt;张三&lt;/value&gt;
                &lt;value&gt;张三&lt;/value&gt;
                &lt;value&gt;狼&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testCollection(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-collection.xml&quot;);
    People peopleBean = applicationContext.getBean(&quot;peopleBean&quot;, People.class);
    System.out.println(peopleBean);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665199057422-a5f94a7c-711e-4846-9d69-2caf05d11e88.png" /></p>
<p><strong>注意：注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签</strong></p>
<h3 id="437-set">4.3.7 注入Set集合</h3>
<p>Set集合：无序不可重复</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.List;
import java.util.Set;

/**
 * @author 动力节点
 * @version 1.0
 * @className People
 * @since 1.0
 **/
public class People {
    // 一个人有多个电话
    private Set&lt;String&gt; phones;

    public void setPhones(Set&lt;String&gt; phones) {
        this.phones = phones;
    }

    //......

    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;phones=&quot; + phones +
                &quot;, names=&quot; + names +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;peopleBean&quot; class=&quot;com.powernode.spring6.beans.People&quot;&gt;
        &lt;property name=&quot;phones&quot;&gt;
            &lt;set&gt;
                &lt;!--非简单类型可以使用ref，简单类型使用value--&gt;
                &lt;value&gt;110&lt;/value&gt;
                &lt;value&gt;110&lt;/value&gt;
                &lt;value&gt;120&lt;/value&gt;
                &lt;value&gt;120&lt;/value&gt;
                &lt;value&gt;119&lt;/value&gt;
                &lt;value&gt;119&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665199868843-bc721edd-e89a-4298-b41a-7c5ac8c93530.png" /></p>
<p><strong>要点：</strong></p>
<ul>
<li><strong>使用\<set>标签</strong></li>
<li><strong>set集合中元素是简单类型的使用value标签，反之使用ref标签</strong></li>
</ul>
<h3 id="438-map">4.3.8 注入Map集合</h3>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author 动力节点
 * @version 1.0
 * @className People
 * @since 1.0
 **/
public class People {
    // 一个人有多个住址
    private Map&lt;Integer, String&gt; addrs;

    public void setAddrs(Map&lt;Integer, String&gt; addrs) {
        this.addrs = addrs;
    }

    //......

    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;addrs=&quot; + addrs +
                &quot;, phones=&quot; + phones +
                &quot;, names=&quot; + names +
                '}';
    }

}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;peopleBean&quot; class=&quot;com.powernode.spring6.beans.People&quot;&gt;
        &lt;property name=&quot;addrs&quot;&gt;
            &lt;map&gt;
                &lt;!--如果key不是简单类型，使用 key-ref 属性--&gt;
                &lt;!--如果value不是简单类型，使用 value-ref 属性--&gt;
                &lt;entry key=&quot;1&quot; value=&quot;北京大兴区&quot;/&gt;
                &lt;entry key=&quot;2&quot; value=&quot;上海浦东区&quot;/&gt;
                &lt;entry key=&quot;3&quot; value=&quot;深圳宝安区&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665200352800-0b980533-2d1f-4222-8aaf-1b253cb19a39.png" /></p>
<p><strong>要点：</strong></p>
<ul>
<li><strong>使用\<map>标签</strong></li>
<li><strong>如果key是简单类型，使用key属性，反之使用key-ref属性</strong></li>
<li><strong>如果value是简单类型，使用value属性，反之使用value-ref属性</strong></li>
</ul>
<h3 id="439-properties">4.3.9 注入Properties</h3>
<p><strong>java.util.Properties继承java.util.Hashtable，所以Properties也是一个Map集合。</strong></p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * @author 动力节点
 * @version 1.0
 * @className People
 * @since 1.0
 **/
public class People {

    private Properties properties;

    public void setProperties(Properties properties) {
        this.properties = properties;
    }

    //......

    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;properties=&quot; + properties +
                &quot;, addrs=&quot; + addrs +
                &quot;, phones=&quot; + phones +
                &quot;, names=&quot; + names +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;peopleBean&quot; class=&quot;com.powernode.spring6.beans.People&quot;&gt;
        &lt;property name=&quot;properties&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;driver&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt;
                &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/spring&lt;/prop&gt;
                &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
                &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665201002733-ae9273da-1fb9-495c-907e-e6c8489a7ec5.png" /></p>
<p><strong>要点：</strong></p>
<ul>
<li><strong>使用\<props>标签嵌套\<prop>标签完成</strong></li>
</ul>
<h3 id="4310-null">4.3.10 注入null和空字符串</h3>
<p>注入空字符串使用：\<value/> 或者 value=""
注入null使用：\<null/> 或者 不为该属性赋值
我们先来看一下，怎么注入空字符串。</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className Vip
 * @since 1.0
 **/
public class Vip {
    private String email;

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return &quot;Vip{&quot; +
                &quot;email='&quot; + email + '\'' +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;vipBean&quot; class=&quot;com.powernode.spring6.beans.Vip&quot;&gt;
        &lt;!--空串的第一种方式--&gt;
        &lt;!--&lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;--&gt;
        &lt;!--空串的第二种方式--&gt;
        &lt;property name=&quot;email&quot;&gt;
            &lt;value/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testNull(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-null.xml&quot;);
    Vip vipBean = applicationContext.getBean(&quot;vipBean&quot;, Vip.class);
    System.out.println(vipBean);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665202057919-ba40e1bb-405b-455e-9719-0c56f1f9144b.png" /></p>
<p><strong>怎么注入null呢？</strong></p>
<ol>
<li>不给属性赋值</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;vipBean&quot; class=&quot;com.powernode.spring6.beans.Vip&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665202218759-f35ed2da-e136-4ef0-92e5-8ae4ea029620.png" /></p>
<ol>
<li>使用\<null/></li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;vipBean&quot; class=&quot;com.powernode.spring6.beans.Vip&quot;&gt;
        &lt;property name=&quot;email&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665202218759-f35ed2da-e136-4ef0-92e5-8ae4ea029620-166712981271143.png" /></p>
<h3 id="4311">4.3.11 注入的值中含有特殊符号</h3>
<p>XML 中有5个特殊字符，分别是：&lt;、&gt;、'、"、&amp;</p>
<p>以上5个特殊户号在XML中会被特殊对待，会被当做XML语法的一部分进行解析，如果这些特殊符号直接出现在注入的字符串中，会报错</p>
<p><img alt="image.png" src="../Spring6.assets/1665209144602-479d8a8d-d79d-4da8-bb13-6a9c7e76a949.png" /></p>
<p>解决方案包括两种：</p>
<ul>
<li>特殊符号使用转义字符代替</li>
<li>将含有特殊符号的字符串放到：\&lt;![CDATA[]]&gt; 当中。因为放在CDATA区中的数据不会被XML文件解析器解析</li>
</ul>
<p>5个特殊字符对应的转义字符分别是：</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>转义字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>&lt;</td>
<td>&lt;</td>
</tr>
<tr>
<td>'</td>
<td>&apos;</td>
</tr>
<tr>
<td>"</td>
<td>&quot;</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;</td>
</tr>
</tbody>
</table>
<p>先使用转义字符来代替：</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className Math
 * @since 1.0
 **/
public class Math {
    private String result;

    public void setResult(String result) {
        this.result = result;
    }

    @Override
    public String toString() {
        return &quot;Math{&quot; +
                &quot;result='&quot; + result + '\'' +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;mathBean&quot; class=&quot;com.powernode.spring6.beans.Math&quot;&gt;
        &lt;property name=&quot;result&quot; value=&quot;2 &amp;lt; 3&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testSpecial(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-special.xml&quot;);
    Math mathBean = applicationContext.getBean(&quot;mathBean&quot;, Math.class);
    System.out.println(mathBean);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665210216232-b41609a9-2ead-4179-9f0c-dd9a9a4e033e.png" /></p>
<p>使用CDATA方式：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;mathBean&quot; class=&quot;com.powernode.spring6.beans.Math&quot;&gt;
        &lt;property name=&quot;result&quot;&gt;
            &lt;!--只能使用value标签--&gt;
            &lt;value&gt;&lt;![CDATA[2 &lt; 3]]&gt;&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p><strong>注意：使用CDATA时，不能使用value属性，只能使用value标签</strong></p>
<p><img alt="image.png" src="../Spring6.assets/1665210754241-75f884a4-a77b-4918-b398-9f7be2a58873.png" /></p>
<h2 id="44-p">4.4 p命名空间注入</h2>
<p>目的：简化配置</p>
<p>使用p命名空间注入的前提条件包括两个：</p>
<ul>
<li>在XML头部信息中添加p命名空间的配置信息：xmlns:p="http://www.springframework.org/schema/p"</li>
<li>p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法</li>
</ul>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className Customer
 * @since 1.0
 **/
public class Customer {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Customer{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;customerBean&quot; class=&quot;com.powernode.spring6.beans.Customer&quot; p:name=&quot;zhangsan&quot; p:age=&quot;20&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testP(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-p.xml&quot;);
    Customer customerBean = applicationContext.getBean(&quot;customerBean&quot;, Customer.class);
    System.out.println(customerBean);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665215638858-c5ae8aef-43ec-455d-90a3-ac3f97c92746.png" /></p>
<p>把setter方法去掉：</p>
<p><img alt="image.png" src="../Spring6.assets/1665215713205-fcebda06-c4bb-486b-a2d7-6a238088625b.png" /></p>
<p><strong>所以p命名空间实际上是对set注入的简化。</strong></p>
<h2 id="45-c">4.5 c命名空间注入</h2>
<p>c命名空间是简化构造方法注入的。
使用c命名空间的两个前提条件：</p>
<ul>
<li>需要在xml配置文件头部添加信息：xmlns:c="http://www.springframework.org/schema/c"</li>
<li>需要提供构造方法。</li>
</ul>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className MyTime
 * @since 1.0
 **/
public class MyTime {
    private int year;
    private int month;
    private int day;

    public MyTime(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    @Override
    public String toString() {
        return &quot;MyTime{&quot; +
                &quot;year=&quot; + year +
                &quot;, month=&quot; + month +
                &quot;, day=&quot; + day +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--&lt;bean id=&quot;myTimeBean&quot; class=&quot;com.powernode.spring6.beans.MyTime&quot; c:year=&quot;1970&quot; c:month=&quot;1&quot; c:day=&quot;1&quot;/&gt;--&gt;

    &lt;bean id=&quot;myTimeBean&quot; class=&quot;com.powernode.spring6.beans.MyTime&quot; c:_0=&quot;2008&quot; c:_1=&quot;8&quot; c:_2=&quot;8&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testC(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-c.xml&quot;);
    MyTime myTimeBean = applicationContext.getBean(&quot;myTimeBean&quot;, MyTime.class);
    System.out.println(myTimeBean);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665216171317-2dc02c42-3f3e-42f5-80e7-c578888e2fbb.png" /></p>
<p>把构造方法注释掉：</p>
<p><img alt="image.png" src="../Spring6.assets/1665216339051-c5eecc20-6801-46dd-a331-e5b33c66c7ed.png" /></p>
<p><strong>所以，c命名空间是依靠构造方法的。</strong></p>
<p><strong>注意：不管是p命名空间还是c命名空间，注入的时候都可以注入简单类型和非简单类型</strong></p>
<h2 id="46-util">4.6 util命名空间</h2>
<p>使用util命名空间可以让<strong>配置复用</strong>。</p>
<p>使用util命名空间的前提是：在spring配置文件头部添加配置信息。如下：</p>
<p><img alt="image.png" src="../Spring6.assets/1665218059794-30411b76-a22c-4339-ab60-acad8f02ab28.png" /></p>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.Properties;

/**
 * @author 动力节点
 * @version 1.0
 * @className MyDataSource1
 * @since 1.0
 **/
public class MyDataSource1 {
    private Properties properties;

    public void setProperties(Properties properties) {
        this.properties = properties;
    }

    @Override
    public String toString() {
        return &quot;MyDataSource1{&quot; +
                &quot;properties=&quot; + properties +
                '}';
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.beans;

import java.util.Properties;

/**
 * @author 动力节点
 * @version 1.0
 * @className MyDataSource2
 * @since 1.0
 **/
public class MyDataSource2 {
    private Properties properties;

    public void setProperties(Properties properties) {
        this.properties = properties;
    }

    @Override
    public String toString() {
        return &quot;MyDataSource2{&quot; +
                &quot;properties=&quot; + properties +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;

    &lt;util:properties id=&quot;prop&quot;&gt;
        &lt;prop key=&quot;driver&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt;
        &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/spring&lt;/prop&gt;
        &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
        &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;
    &lt;/util:properties&gt;

    &lt;bean id=&quot;dataSource1&quot; class=&quot;com.powernode.spring6.beans.MyDataSource1&quot;&gt;
        &lt;property name=&quot;properties&quot; ref=&quot;prop&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;dataSource2&quot; class=&quot;com.powernode.spring6.beans.MyDataSource2&quot;&gt;
        &lt;property name=&quot;properties&quot; ref=&quot;prop&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testUtil(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-util.xml&quot;);

    MyDataSource1 dataSource1 = applicationContext.getBean(&quot;dataSource1&quot;, MyDataSource1.class);
    System.out.println(dataSource1);

    MyDataSource2 dataSource2 = applicationContext.getBean(&quot;dataSource2&quot;, MyDataSource2.class);
    System.out.println(dataSource2);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665218430727-c81e399e-294e-4bb5-b98b-2c8875b0884f.png" /></p>
<h2 id="47-xml">4.7 基于XML的自动装配</h2>
<p>Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据<strong>名字</strong>进行自动装配，也可以根据<strong>类型</strong>进行自动装配。</p>
<h3 id="471">4.7.1 根据名称自动装配</h3>
<pre><code class="language-java">package com.powernode.spring6.dao;

/**
 * @author 动力节点
 * @version 1.0
 * @className UserDao
 * @since 1.0
 **/
public class UserDao {

    public void insert(){
        System.out.println(&quot;正在保存用户数据。&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;

/**
 * @author 动力节点
 * @version 1.0
 * @className UserService
 * @since 1.0
 **/
public class UserService {

    private UserDao aaa;

    // 这个set方法非常关键
    public void setAaa(UserDao aaa) {
        this.aaa = aaa;
    }

    public void save(){
        aaa.insert();
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.powernode.spring6.service.UserService&quot; autowire=&quot;byName&quot;/&gt;

    &lt;bean id=&quot;aaa&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>这个配置起到关键作用：</p>
<ul>
<li>UserService Bean中需要添加autowire="byName"，表示通过名称进行装配</li>
<li>UserService类中有一个UserDao属性，而UserDao属性的名字是aaa，<strong>对应的set方法是setAaa()</strong>，正好和UserDao Bean的id是一样的。这就是根据名称自动装配。</li>
</ul>
<pre><code class="language-java">@Test
public void testAutowireByName(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-autowire.xml&quot;);
    UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class);
    userService.save();
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665535913374-7031648f-fad4-4fa1-a3f1-68dcf2318bef.png" /></p>
<p>byName装配是和属性名有关还是和set方法名有关系：</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;

/**
 * @author 动力节点
 * @version 1.0
 * @className UserService
 * @since 1.0
 **/
public class UserService {
    // 这里没修改
    private UserDao aaa;

    /*public void setAaa(UserDao aaa) {
        this.aaa = aaa;
    }*/

    // set方法名变化了
    public void setDao(UserDao aaa){
        this.aaa = aaa;
    }

    public void save(){
        aaa.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665536092171-afa2acd5-68c8-4289-95bd-ab8c0f88a66d.png" /></p>
<p>通过测试得知，aaa属性并没有赋值成功。也就是并没有装配成功。
我们将spring配置文件修改以下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

  &lt;bean id=&quot;userService&quot; class=&quot;com.powernode.spring6.service.UserService&quot; autowire=&quot;byName&quot;/&gt;
  &lt;!--这个id修改了--&gt;
  &lt;bean id=&quot;dao&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665536194436-6efd0c08-72da-437e-b3ad-143cdb00834d.png" /></p>
<p>这说明，如果根据名称装配(byName)，底层会调用set方法进行注入。
例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。</p>
<h3 id="472">4.7.2 根据类型自动装配</h3>
<pre><code class="language-java">package com.powernode.spring6.dao;

/**
 * @author 动力节点
 * @version 1.0
 * @className AccountDao
 * @since 1.0
 **/
public class AccountDao {
    public void insert(){
        System.out.println(&quot;正在保存账户信息&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.AccountDao;

/**
 * @author 动力节点
 * @version 1.0
 * @className AccountService
 * @since 1.0
 **/
public class AccountService {
    private AccountDao accountDao;

    public void setAccountDao(AccountDao accountDao) {
        this.accountDao = accountDao;
    }

    public void save(){
        accountDao.insert();
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--byType表示根据类型自动装配--&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;com.powernode.spring6.service.AccountService&quot; autowire=&quot;byType&quot;/&gt;

    &lt;bean class=&quot;com.powernode.spring6.dao.AccountDao&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testAutowireByType(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-autowire.xml&quot;);
    AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class);
    accountService.save();
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665537096983-d3c25b4c-21e1-499f-b348-6f829bc84a48.png" /></p>
<p>我们把UserService中的set方法注释掉，再执行：</p>
<p><img alt="image.png" src="../Spring6.assets/1665537145356-cf979b68-e11b-4b4f-b1b4-7c20649aa199.png" /></p>
<p>可以看到无论是byName还是byType，在装配的时候都是基于set方法的。所以set方法是必须要提供的。<strong>提供构造方法是不行的</strong>
如果byType，根据类型装配时，如果配置文件中有两个类型一样的bean会出现什么问题呢？</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;accountService&quot; class=&quot;com.powernode.spring6.service.AccountService&quot; autowire=&quot;byType&quot;/&gt;

    &lt;bean id=&quot;x&quot; class=&quot;com.powernode.spring6.dao.AccountDao&quot;/&gt;
    &lt;bean id=&quot;y&quot; class=&quot;com.powernode.spring6.dao.AccountDao&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665537341888-57af14a1-eeb4-4070-8713-b4368003251d.png" /></p>
<p><strong>测试结果说明了，当byType进行自动装配的时候，配置文件中某种类型的Bean必须是唯一的，不能出现多个</strong></p>
<h2 id="48-spring">4.8 spring引入外部属性配置文件</h2>
<p>我们都知道编写数据源的时候是需要连接数据库的信息的，例如：driver url username password等信息，这些信息可以单独写到一个属性配置文件中吗，这样用户修改起来会更加的方便。当然可以。</p>
<ol>
<li>写一个数据源类，提供相关属性。</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.beans;

import javax.sql.DataSource;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;

/**
 * @author 动力节点
 * @version 1.0
 * @className MyDataSource
 * @since 1.0
 **/
public class MyDataSource implements DataSource {
    @Override
    public String toString() {
        return &quot;MyDataSource{&quot; +
                &quot;driver='&quot; + driver + '\'' +
                &quot;, url='&quot; + url + '\'' +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}';
    }

    private String driver;
    private String url;
    private String username;
    private String password;

    public void setDriver(String driver) {
        this.driver = driver;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    //......
}
</code></pre>
<ol>
<li>在类路径下新建jdbc.properties文件，并配置信息。</li>
</ol>
<pre><code class="language-properties">jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/spring
jdbc.username=root
jdbc.password=root123
</code></pre>
<p><strong>最好带上前缀，例如jdbc.driver取值的时候${jdbc.driver}</strong></p>
<ol>
<li>在spring配置文件中引入context命名空间。</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<ol>
<li>在spring中配置使用jdbc.properties文件。</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;com.powernode.spring6.beans.MyDataSource&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testProperties(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-properties.xml&quot;);
    MyDataSource dataSource = applicationContext.getBean(&quot;dataSource&quot;, MyDataSource.class);
    System.out.println(dataSource);
}
</code></pre>
<h1 id="bean">五、Bean的作用域</h1>
<h2 id="51-singleton">5.1 singleton</h2>
<p>默认情况下，Spring的IoC容器创建的Bean对象是单例的。来测试一下：</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className SpringBean
 * @since 1.0
 **/
public class SpringBean {
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;sb&quot; class=&quot;com.powernode.spring6.beans.SpringBean&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testScope(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);

    SpringBean sb1 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    System.out.println(sb1);

    SpringBean sb2 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    System.out.println(sb2);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665220014331-a1e4cac5-c749-4b67-bab8-43d6957c35e4.png" /></p>
<p>通过测试得知：Spring的IoC容器中，默认情况下，Bean对象是单例的。
这个对象在什么时候创建的呢？可以为SpringBean提供一个无参数构造方法，测试一下，如下：</p>
<pre><code class="language-java">package com.powernode.spring6.beans;

/**
 * @author 动力节点
 * @version 1.0
 * @className SpringBean
 * @since 1.0
 **/
public class SpringBean {
    public SpringBean() {
        System.out.println(&quot;SpringBean的无参数构造方法执行。&quot;);
    }
}
</code></pre>
<p>将测试程序中getBean()所在行代码注释掉：</p>
<pre><code class="language-java">@Test
public void testScope(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665220250081-036fe814-8328-4b58-adf4-b3a37eb0cb4d.png" /></p>
<h2 id="52-prototype">5.2 prototype</h2>
<p>如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：<strong>prototype</strong>，这样Spring会在每一次执行getBean()方法的时候创建Bean对象，调用几次则创建几次。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;sb&quot; class=&quot;com.powernode.spring6.beans.SpringBean&quot; scope=&quot;prototype&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testScope(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);

    SpringBean sb1 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    System.out.println(sb1);

    SpringBean sb2 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    System.out.println(sb2);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665220593171-19b1a750-551c-441d-8f8f-9c7aa7601e77.png" /></p>
<p>我们可以把测试代码中的getBean()方法所在行代码注释掉：</p>
<pre><code class="language-java">@Test
public void testScope(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665220698959-ff4ad909-670e-4745-960d-5c215e2af71e.png" /></p>
<p>可以看到这一次在初始化Spring上下文的时候，并没有创建Bean对象。
那你可能会问：scope如果没有配置，它的默认值是什么呢？默认值是<strong>singleton</strong>，单例的。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;sb&quot; class=&quot;com.powernode.spring6.beans.SpringBean&quot; scope=&quot;singleton&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testScope(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);

    SpringBean sb1 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    System.out.println(sb1);

    SpringBean sb2 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    System.out.println(sb2);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665221074412-9b48c6e3-44f0-492c-a712-37b4baa24341.png" /></p>
<p>通过测试得知，没有指定scope属性时，默认是singleton单例的。</p>
<h2 id="53-scope">5.3 其它scope</h2>
<p><strong>scope属性的值不止两个，它一共包括8个选项：</strong></p>
<ul>
<li>singleton：默认的，单例。</li>
<li>prototype：原型。每调用一次getBean()方法则获取一个新的Bean对象。或每次注入的时候都是新对象。</li>
<li>request：一个请求对应一个Bean。<strong>仅限于在WEB应用中使用</strong>。</li>
<li>session：一个会话对应一个Bean。<strong>仅限于在WEB应用中使用</strong>。</li>
<li>global session：<strong>portlet应用中专用的</strong>。如果在Servlet的WEB应用中使用global session的话，和session一个效果。（portlet和servlet都是规范。servlet运行在servlet容器中，例如Tomcat。portlet运行在portlet容器中。）</li>
<li>application：一个应用对应一个Bean。<strong>仅限于在WEB应用中使用</strong>。</li>
<li>websocket：一个websocket生命周期对应一个Bean。<strong>仅限于在WEB应用中使用</strong>。</li>
<li>自定义scope：很少使用。</li>
</ul>
<p>接下来咱们自定义一个Scope，线程级别的Scope，在同一个线程中，获取的Bean都是同一个。跨线程则是不同的对象：（以下内容作为了解）</p>
<ol>
<li>自定义Scope。（实现Scope接口）</li>
<li>spring内置了线程范围的类：org.springframework.context.support.SimpleThreadScope，可以直接用。</li>
<li>将自定义的Scope注册到Spring容器中。</li>
</ol>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;&gt;
  &lt;property name=&quot;scopes&quot;&gt;
    &lt;map&gt;
      &lt;entry key=&quot;myThread&quot;&gt;
        &lt;bean class=&quot;org.springframework.context.support.SimpleThreadScope&quot;/&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<ol>
<li>使用Scope</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;sb&quot; class=&quot;com.powernode.spring6.beans.SpringBean&quot; scope=&quot;myThread&quot; /&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testCustomScope(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);
    SpringBean sb1 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    SpringBean sb2 = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
    System.out.println(sb1);
    System.out.println(sb2);
    // 启动线程
    new Thread(new Runnable() {
        @Override
        public void run() {
            SpringBean a = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
            SpringBean b = applicationContext.getBean(&quot;sb&quot;, SpringBean.class);
            System.out.println(a);
            System.out.println(b);
        }
    }).start();
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665297614749-ae92b97d-85fd-4792-af87-e72d35784187.png" /></p>
<h1 id="gof">六、GoF之工厂模式</h1>
<ul>
<li>设计模式：一种可以被重复利用的解决方案</li>
<li>GoF（Gang of Four）中文名——四人组</li>
<li>Design Patterns: Elements of Reusable Object-Oriented Software》（即《设计模式》一书），1995年由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著。这几位作者常被称为"四人组（Gang of Four）"</li>
<li>该书中描述了23种设计模式。我们平常所说的设计模式就是指这23种设计模式。</li>
<li>不过除了GoF23种设计模式之外，还有其它的设计模式，比如：JavaEE的设计模式（DAO模式、MVC模式等）。</li>
<li>GoF23种设计模式可分为三大类：</li>
<li><strong>创建型（5个）</strong>：解决对象创建问题：<ul>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
</li>
<li><strong>构造型（7个）</strong>：一些类或对象组合在一起的经典结构<ul>
<li>代理模式</li>
<li>装饰模式</li>
<li>适配器模式</li>
<li>组合模式</li>
<li>享元模式</li>
<li>外观模式</li>
<li>桥接模式</li>
</ul>
</li>
<li><strong>行为型（11个）</strong>：解决类或对象之间的交互问题<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>责任链模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
</li>
<li>工厂模式是解决对象创建问题的，所以工厂模式属于创建型设计模式。spring框架底层使用了大量的工厂模式</li>
</ul>
<h2 id="61">6.1 工厂模式的三种形态</h2>
<p>工厂模式通常有三种形态：</p>
<ol>
<li><strong>简单工厂模式（Simple Factory）：不属于23仲设计模式之一，简单工厂模式又叫做：静态  工厂方法模式，简单工厂模式是工厂方法模式的一种特殊实现</strong></li>
<li>
<p>工厂方法模式（Factory Method）：是23种设计模式之一</p>
</li>
<li>
<p>抽象工厂模式（Abstract Factory）：是23种设计模式之一</p>
</li>
</ol>
<h2 id="62">6.2 简单工厂模式</h2>
<p>简单工厂模式的角色包括三个：</p>
<ol>
<li>抽象产品角色</li>
<li>具体产品角色</li>
<li>工厂类角色</li>
</ol>
<p>简单工厂模式的代码如下：</p>
<p>抽象产品角色：
Weapon</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 武器（抽象产品角色）
 * @author 动力节点
 * @version 1.0
 * @className Weapon
 * @since 1.0
 **/
public abstract class Weapon {
    /**
     * 所有的武器都有攻击行为
     */
    public abstract void attack();
}
</code></pre>
<p>具体产品角色：</p>
<p>Tank</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 坦克（具体产品角色）
 * @author 动力节点
 * @version 1.0
 * @className Tank
 * @since 1.0
 **/
public class Tank extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;坦克开炮！&quot;);
    }
}
</code></pre>
<p>Fighter</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 战斗机（具体产品角色）
 * @author 动力节点
 * @version 1.0
 * @className Fighter
 * @since 1.0
 **/
public class Fighter extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;战斗机投下原子弹！&quot;);
    }
}
</code></pre>
<p>Dagger</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 匕首（具体产品角色）
 * @author 动力节点
 * @version 1.0
 * @className Dagger
 * @since 1.0
 **/
public class Dagger extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;砍他丫的！&quot;);
    }
}
</code></pre>
<p>工厂类角色：</p>
<p>WeaponFactory</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 工厂类角色
 * @author 动力节点
 * @version 1.0
 * @className WeaponFactory
 * @since 1.0
 **/
public class WeaponFactory {
    /**
     * 根据不同的武器类型生产武器
     * @param weaponType 武器类型
     * @return 武器对象
     */
    public static Weapon get(String weaponType){
        if (weaponType == null || weaponType.trim().length() == 0) {
            return null;
        }
        Weapon weapon = null;
        if (&quot;TANK&quot;.equals(weaponType)) {
            weapon = new Tank();
        } else if (&quot;FIGHTER&quot;.equals(weaponType)) {
            weapon = new Fighter();
        } else if (&quot;DAGGER&quot;.equals(weaponType)) {
            weapon = new Dagger();
        } else {
            throw new RuntimeException(&quot;不支持该武器！&quot;);
        }
        return weapon;
    }
}
</code></pre>
<p>测试程序（客户端程序）：</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * @author 动力节点
 * @version 1.0
 * @className Client
 * @since 1.0
 **/
public class Client {
    public static void main(String[] args) {
        Weapon weapon1 = WeaponFactory.get(&quot;TANK&quot;);
        weapon1.attack();

        Weapon weapon2 = WeaponFactory.get(&quot;FIGHTER&quot;);
        weapon2.attack();

        Weapon weapon3 = WeaponFactory.get(&quot;DAGGER&quot;);
        weapon3.attack();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665304945315-8bd0c855-6eff-44a8-8051-42a2c1edb712.png" /></p>
<p>简单工厂模式的优点：</p>
<ul>
<li>客户端程序不需要关心对象的创建细节，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离</li>
</ul>
<p>简单工厂模式的缺点：</p>
<ol>
<li>工厂类集中了所有的产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪</li>
<li>不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类</li>
</ol>
<p><strong>spring中的BeanFactory就使用了简单工厂模式</strong></p>
<h2 id="63">6.3 工厂方法模式</h2>
<p>工厂方法模式既保留了简单工厂模式的优点，同时又解决了简单工厂模式的缺点</p>
<p>工厂方法模式的角色包括：</p>
<ul>
<li><strong>抽象工厂角色</strong></li>
<li><strong>具体工厂角色</strong></li>
<li>抽象产品角色</li>
<li>具体产品角色</li>
</ul>
<p>抽象产品角色：</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 武器类（抽象产品角色）
 * @author 动力节点
 * @version 1.0
 * @className Weapon
 * @since 1.0
 **/
public abstract class Weapon {
    /**
     * 所有武器都有攻击行为
     */
    public abstract void attack();
}
</code></pre>
<p>具体产品角色</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 具体产品角色
 * @author 动力节点
 * @version 1.0
 * @className Gun
 * @since 1.0
 **/
public class Gun extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;开枪射击！&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 具体产品角色
 * @author 动力节点
 * @version 1.0
 * @className Fighter
 * @since 1.0
 **/
public class Fighter extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;战斗机发射核弹！&quot;);
    }
}
</code></pre>
<p>抽象工厂角色</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 武器工厂接口(抽象工厂角色)
 * @author 动力节点
 * @version 1.0
 * @className WeaponFactory
 * @since 1.0
 **/
public interface WeaponFactory {
    Weapon get();
}
</code></pre>
<p>具体工厂角色</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 具体工厂角色
 * @author 动力节点
 * @version 1.0
 * @className GunFactory
 * @since 1.0
 **/
public class GunFactory implements WeaponFactory{
    @Override
    public Weapon get() {
        return new Gun();
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.factory;

/**
 * 具体工厂角色
 * @author 动力节点
 * @version 1.0
 * @className FighterFactory
 * @since 1.0
 **/
public class FighterFactory implements WeaponFactory{
    @Override
    public Weapon get() {
        return new Fighter();
    }
}
</code></pre>
<p>客户端程序：</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * @author 动力节点
 * @version 1.0
 * @className Client
 * @since 1.0
 **/
public class Client {
    public static void main(String[] args) {
        WeaponFactory factory = new GunFactory();
        Weapon weapon = factory.get();
        weapon.attack();

        WeaponFactory factory1 = new FighterFactory();
        Weapon weapon1 = factory1.get();
        weapon1.attack();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665362593949-73061a01-391f-4926-ba24-575903fd11bb.png" /></p>
<p>如果想扩展一个新的产品，只要新增一个产品类，在新增一个该产品对应的工厂即可，例如新增：匕首</p>
<p>增加：具体产品角色</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * @author 动力节点
 * @version 1.0
 * @className Dagger
 * @since 1.0
 **/
public class Dagger extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;砍丫的！&quot;);
    }
}
</code></pre>
<p>增加：具体工厂角色</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * @author 动力节点
 * @version 1.0
 * @className DaggerFactory
 * @since 1.0
 **/
public class DaggerFactory implements WeaponFactory{
    @Override
    public Weapon get() {
        return new Dagger();
    }
}
</code></pre>
<p>客户端程序：</p>
<pre><code class="language-java">package com.powernode.factory;

/**
 * @author 动力节点
 * @version 1.0
 * @className Client
 * @since 1.0
 **/
public class Client {
    public static void main(String[] args) {
        WeaponFactory factory = new GunFactory();
        Weapon weapon = factory.get();
        weapon.attack();

        WeaponFactory factory1 = new FighterFactory();
        Weapon weapon1 = factory1.get();
        weapon1.attack();

        WeaponFactory factory2 = new DaggerFactory();
        Weapon weapon2 = factory2.get();
        weapon2.attack();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665362890109-5db8f42d-677b-450d-bc76-6842abe9640a.png" /></p>
<p>我们可以看到在进行功能扩展的时候，不需要修改之前的源代码，显然工厂方法模式符合OCP原则</p>
<p>工厂方法模式的优点：</p>
<ul>
<li>一个调用者想创建一个对象，只要知道其名称就行了</li>
<li>扩展性搞，如果想增加一个产品，只要扩展一个工厂类就可以</li>
<li>屏蔽产品的具体实现，调用者只关系产品的接口</li>
</ul>
<p>工程方法模式的缺点：</p>
<ul>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工程，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖，这并不是什么好事</li>
</ul>
<h2 id="64">6.4 抽象工厂模式（了解）</h2>
<p>抽象工厂模式相对于工厂方法模式来说，就是工厂方法模式是针对一个产品系列的，而抽象工厂模式是针对多个产品系列的，即工厂方法模式是一个产品系列一个工厂类，而抽象工厂模式是多个产品系列一个工厂类</p>
<p>抽象工厂模式特点：抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象对象时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体情况下，创建多个产品族中的产品对象，它有多个产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。每个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构</p>
<p>抽象工厂中包含4个角色：</p>
<ul>
<li>抽象工厂角色</li>
<li>具体工厂角色</li>
<li>抽象产品角色</li>
<li>具体产品角色</li>
</ul>
<p>抽象工厂模式的类图如下：</p>
<p><img alt="image.png" src="../Spring6.assets/1665370116084-46b714b8-95d2-45c5-89b6-564057c45694.png" /></p>
<p>抽象工厂模式代码如下：</p>
<ol>
<li>武器产品族</li>
</ol>
<pre><code class="language-java">package com.powernode.product;

/**
 * 武器产品族
 * @author 动力节点
 * @version 1.0
 * @className Weapon
 * @since 1.0
 **/
public abstract class Weapon {
    public abstract void attack();
}
</code></pre>
<pre><code class="language-java">package com.powernode.product;

/**
 * 武器产品族中的产品等级1
 * @author 动力节点
 * @version 1.0
 * @className Gun
 * @since 1.0
 **/
public class Gun extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;开枪射击！&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.product;

/**
 * 武器产品族中的产品等级2
 * @author 动力节点
 * @version 1.0
 * @className Dagger
 * @since 1.0
 **/
public class Dagger extends Weapon{
    @Override
    public void attack() {
        System.out.println(&quot;砍丫的！&quot;);
    }
}
</code></pre>
<ol>
<li>水果产品族</li>
</ol>
<pre><code class="language-java">package com.powernode.product;

/**
 * 水果产品族
 * @author 动力节点
 * @version 1.0
 * @className Fruit
 * @since 1.0
 **/
public abstract class Fruit {
    /**
     * 所有果实都有一个成熟周期。
     */
    public abstract void ripeCycle();
}
</code></pre>
<pre><code class="language-java">package com.powernode.product;

/**
 * 水果产品族中的产品等级1
 * @author 动力节点
 * @version 1.0
 * @className Orange
 * @since 1.0
 **/
public class Orange extends Fruit{
    @Override
    public void ripeCycle() {
        System.out.println(&quot;橘子的成熟周期是10个月&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.product;

/**
 * 水果产品族中的产品等级2
 * @author 动力节点
 * @version 1.0
 * @className Apple
 * @since 1.0
 **/
public class Apple extends Fruit{
    @Override
    public void ripeCycle() {
        System.out.println(&quot;苹果的成熟周期是8个月&quot;);
    }
}
</code></pre>
<ol>
<li>抽象工厂类</li>
</ol>
<pre><code class="language-java">package com.powernode.factory;

import com.powernode.product.Fruit;
import com.powernode.product.Weapon;

/**
 * 抽象工厂
 * @author 动力节点
 * @version 1.0
 * @className AbstractFactory
 * @since 1.0
 **/
public abstract class AbstractFactory {
    public abstract Weapon getWeapon(String type);
    public abstract Fruit getFruit(String type);
}
</code></pre>
<ol>
<li>具体工厂类</li>
</ol>
<pre><code class="language-java">package com.powernode.factory;

import com.powernode.product.Dagger;
import com.powernode.product.Fruit;
import com.powernode.product.Gun;
import com.powernode.product.Weapon;

/**
 * 武器族工厂
 * @author 动力节点
 * @version 1.0
 * @className WeaponFactory
 * @since 1.0
 **/
public class WeaponFactory extends AbstractFactory{

    public Weapon getWeapon(String type){
        if (type == null || type.trim().length() == 0) {
            return null;
        }
        if (&quot;Gun&quot;.equals(type)) {
            return new Gun();
        } else if (&quot;Dagger&quot;.equals(type)) {
            return new Dagger();
        } else {
            throw new RuntimeException(&quot;无法生产该武器&quot;);
        }
    }

    @Override
    public Fruit getFruit(String type) {
        return null;
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.factory;

import com.powernode.product.*;

/**
 * 水果族工厂
 * @author 动力节点
 * @version 1.0
 * @className FruitFactory
 * @since 1.0
 **/
public class FruitFactory extends AbstractFactory{
    @Override
    public Weapon getWeapon(String type) {
        return null;
    }

    public Fruit getFruit(String type){
        if (type == null || type.trim().length() == 0) {
            return null;
        }
        if (&quot;Orange&quot;.equals(type)) {
            return new Orange();
        } else if (&quot;Apple&quot;.equals(type)) {
            return new Apple();
        } else {
            throw new RuntimeException(&quot;我家果园不产这种水果&quot;);
        }
    }
}
</code></pre>
<p>客户端程序</p>
<pre><code class="language-java">package com.powernode.client;

import com.powernode.factory.AbstractFactory;
import com.powernode.factory.FruitFactory;
import com.powernode.factory.WeaponFactory;
import com.powernode.product.Fruit;
import com.powernode.product.Weapon;

/**
 * @author 动力节点
 * @version 1.0
 * @className Client
 * @since 1.0
 **/
public class Client {
    public static void main(String[] args) {
        // 客户端调用方法时只面向AbstractFactory调用方法。
        AbstractFactory factory = new WeaponFactory(); // 注意：这里的new WeaponFactory()可以采用 简单工厂模式 进行隐藏。
        Weapon gun = factory.getWeapon(&quot;Gun&quot;);
        Weapon dagger = factory.getWeapon(&quot;Dagger&quot;);

        gun.attack();
        dagger.attack();

        AbstractFactory factory1 = new FruitFactory(); // 注意：这里的new FruitFactory()可以采用 简单工厂模式 进行隐藏。
        Fruit orange = factory1.getFruit(&quot;Orange&quot;);
        Fruit apple = factory1.getFruit(&quot;Apple&quot;);

        orange.ripeCycle();
        apple.ripeCycle();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665370862172-3753f689-d7c7-40d8-8a50-1e4144f2be97.png" /></p>
<p>抽象工厂模式的优缺点：</p>
<ul>
<li>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象</li>
<li>确定：产品族扩展非常困难，要增加一个系列的某一产品，既要在AbstractFactory里加代码，又要在具体的里面加代码</li>
</ul>
<h1 id="bean_1">七、Bean的实例化方式</h1>
<p>Spring为Bean提供了多种实例化方式，通常包括4中方式（也就是说在Spring中为Bean对象的创建准备了多种方案，目的是：更加灵活）</p>
<ol>
<li>通过构造方法实例化</li>
<li>通过简单工厂模式实例化</li>
<li>通过factory-bean实例化</li>
<li>通过FactoryBean接口实例化</li>
</ol>
<h2 id="71">7.1 通过构造方法实例化</h2>
<p>我们之前一直使用的就是这种方式。默认情况下，会调用Bean的无参数构造方法。</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className User
 * @since 1.0
 **/
public class User {
    public User() {
        System.out.println(&quot;User类的无参数构造方法执行。&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @author 动力节点
 * @version 1.0
 * @className SpringInstantiationTest
 * @since 1.0
 **/
public class SpringInstantiationTest {

    @Test
    public void testConstructor(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        User user = applicationContext.getBean(&quot;userBean&quot;, User.class);
        System.out.println(user);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665373293580-f86edf28-3303-44bd-a9a1-855dcd575e0d.png" /></p>
<h2 id="72">7.2 通过简单工厂模式实例化</h2>
<ol>
<li>定义一个Bean</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className Vip
 * @since 1.0
 **/
public class Vip {
}
</code></pre>
<ol>
<li>编写简单工厂模式当中的工厂类</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className VipFactory
 * @since 1.0
 **/
public class VipFactory {
    public static Vip get(){
        return new Vip();
    }
}
</code></pre>
<ol>
<li>在Spring配置文件中指定创建该Bean的方法（使用factory-method属性指定）</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;vipBean&quot; class=&quot;com.powernode.spring6.bean.VipFactory&quot; factory-method=&quot;get&quot;/&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testSimpleFactory(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Vip vip = applicationContext.getBean(&quot;vipBean&quot;, Vip.class);
    System.out.println(vip);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665373835672-90312dd8-81e3-4d0a-8b2d-06f90a3e9203.png" /></p>
<h2 id="73-factory-bean">7.3 通过factory-bean实例化</h2>
<p>这种方式本质上是：通过工厂方法模式进行实例化。</p>
<ol>
<li>定义一个Bean</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className Order
 * @since 1.0
 **/
public class Order {
}
</code></pre>
<ol>
<li>定义具体工厂类，工厂类中定义实例方法</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className OrderFactory
 * @since 1.0
 **/
public class OrderFactory {
    public Order get(){
        return new Order();
    }
}
</code></pre>
<ol>
<li>在Spring配置文件中指定factory-bean以及factory-method</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;orderFactory&quot; class=&quot;com.powernode.spring6.bean.OrderFactory&quot;/&gt;
&lt;bean id=&quot;orderBean&quot; factory-bean=&quot;orderFactory&quot; factory-method=&quot;get&quot;/&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testSelfFactoryBean(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Order orderBean = applicationContext.getBean(&quot;orderBean&quot;, Order.class);
    System.out.println(orderBean);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665374686365-c2f211e2-8594-4994-8b37-09259057ad8d.png" /></p>
<h2 id="74-factorybean">7.4 通过FactoryBean接口实例化</h2>
<p>以上的第三种方式中，factory-bean是我们自定义的，factory-method也是我们自己定义的</p>
<p>在Spring中，当你编写的类直接实现FactoryBean接口之后，factory-bean不需要指定了，factory-method也不需要指定了</p>
<p>factory-bean会自动指向实现FactoryBean接口的类，factory-method会自动指向getObject()方法</p>
<ol>
<li>定义一个Bean</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class Person {
}
</code></pre>
<ol>
<li>编写一个类实现FactoryBean接口</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.beans.factory.FactoryBean;

public class PersonFactoryBean implements FactoryBean&lt;Person&gt; {

    @Override
    public Person getObject() throws Exception {
        return new Person();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        // true表示单例
        // false表示原型
        return true;
    }
}
</code></pre>
<ol>
<li>在Spring配置文件中配置FactoryBean</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;personBean&quot; class=&quot;com.powernode.spring6.bean.PersonFactoryBean&quot;/&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testFactoryBean(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Person personBean = applicationContext.getBean(&quot;personBean&quot;, Person.class);
    System.out.println(personBean);

    Person personBean2 = applicationContext.getBean(&quot;personBean&quot;, Person.class);
    System.out.println(personBean2);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665382305162-81e16b33-be0f-4256-ae49-89a59c946823.png" /></p>
<p>FactoryBean在Spring中是一个接口。被称为“工厂Bean”。“工厂Bean”是一种特殊的Bean。所有的“工厂Bean”都是用来协助Spring框架来创建其他Bean对象的</p>
<h2 id="75-beanfactoryfactorybean">7.5 BeanFactory和FactoryBean的区别</h2>
<h3 id="751-beanfactory">7.5.1 BeanFactory</h3>
<p>Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC容器中，“Bean工厂”负责创建Bean对象。
<strong>BeanFactory是工厂</strong></p>
<h3 id="752-factorybean">7.5.2 FactoryBean</h3>
<p>FactoryBean：它是一个Bean，是一个能够<strong>辅助Spring</strong>实例化其它Bean对象的一个Bean。</p>
<p>在Spring中，Bean可以分为两类：</p>
<ol>
<li>普通Bean</li>
<li>工厂Bean（记住：工厂Bean也是一种Bean，只不过这种Bean比较特殊，它可以辅助Spring实例化其他Bean对象）</li>
</ol>
<h2 id="76-date">7.6 注入自定义Date</h2>
<p>我们前面说过，java.util.Date在Spring中被当做简单类型，简单类型在注入的时候可以直接使用value属性或value标签来完成，但我们之前已经测过了，对于Date类型来说，采用value属性或value标签赋值的时候，对日期字符串的格式要求非常高，必须是这种格式：Mon Oct 10 14:30:26 CST 2022。其他格式是不会被识别的。如以下代码：</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import java.util.Date;

public class Student {
    private Date birth;

    public void setBirth(Date birth) {
        this.birth = birth;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;birth=&quot; + birth +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;studentBean&quot; class=&quot;com.powernode.spring6.bean.Student&quot;&gt;
  &lt;property name=&quot;birth&quot; value=&quot;Mon Oct 10 14:30:26 CST 2002&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testDate(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Student studentBean = applicationContext.getBean(&quot;studentBean&quot;, Student.class);
    System.out.println(studentBean);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665383744481-75de8e77-ac4e-46b8-90dc-1cd5264f66f2.png" /></p>
<p>如果把日期格式修改一下：</p>
<pre><code class="language-xml">&lt;bean id=&quot;studentBean&quot; class=&quot;com.powernode.spring6.bean.Student&quot;&gt;
  &lt;property name=&quot;birth&quot; value=&quot;2002-10-10&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665383871708-89cd2ac9-6d31-40fc-a4a8-27d27cd35ad2.png" /></p>
<p>这种情况下，我们就可以使用FactoryBean来完成这个操作。
编写DateFactoryBean实现FactoryBean接口：</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.beans.factory.FactoryBean;

import java.text.SimpleDateFormat;
import java.util.Date;

public class DateFactoryBean implements FactoryBean&lt;Date&gt; {

    // 定义属性接收日期字符串
    private String date;

    // 通过构造方法给日期字符串属性赋值
    public DateFactoryBean(String date) {
        this.date = date;
    }

    @Override
    public Date getObject() throws Exception {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        return sdf.parse(this.date);
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return null;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;dateBean&quot; class=&quot;com.powernode.spring6.bean.DateFactoryBean&quot;&gt;
  &lt;constructor-arg name=&quot;date&quot; value=&quot;1999-10-11&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;studentBean&quot; class=&quot;com.powernode.spring6.bean.Student&quot;&gt;
  &lt;property name=&quot;birth&quot; ref=&quot;dateBean&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665384407377-3fb70ee0-09d6-4d44-904a-10af88cb1a2a.png" /></p>
<h1 id="bean_2">八、Bean的生命周期</h1>
<h2 id="81-bean">8.1 什么是Bean的生命周期</h2>
<p>Spring其实就是一个管理Bean对象的工厂，他负责对象的创建，对象的销毁等</p>
<p>所谓的生命周期就是：对象从创建开始到最终销毁的整个过程</p>
<p>什么时候创建Bean对象？</p>
<p>创建Bean对象的前后会调用什么方法？</p>
<p>Bean对象什么时候销毁？</p>
<p>Bean对象的销毁前后调用什么方法？</p>
<h2 id="82-bean">8.2 为什么要知道Bean的生命周期</h2>
<p>其实生命周期的本质是：在那个时间节点上调用了哪个类的哪个方法</p>
<p>我们需要充分的了解在这个生命线上，都有哪些特殊的时间节点</p>
<p>只有我们知道了特殊的时间节点都在那，到时候我们才可以确定代码写到哪</p>
<p>我们可能需要在某个特殊的时间点上执行一段特殊的代码，这段代码就可以放到这个节点上。当生命线走到这里的时候，自然会被调用</p>
<h2 id="83-bean5">8.3 Bean的生命周期之5步</h2>
<p>Bean生命周期的管理，可以参考Spring的源码：<strong>AbstractAutowireCapableBeanFactory类的doCreateBean()方法。</strong></p>
<p>Bean的生命周期可以粗略的划分为五大步：</p>
<ol>
<li>实例化Bean</li>
<li>Bean属性赋值</li>
<li>初始化Bean</li>
<li>使用Bean</li>
<li>销毁Bean</li>
</ol>
<p><img alt="image.png" src="../Spring6.assets/1665388735200-444405f6-283d-4b3a-8cdf-8c3e01743618.png" /></p>
<ol>
<li>定义一个Bean</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class User {
    private String name;

    public User() {
        System.out.println(&quot;1.实例化Bean&quot;);
    }

    public void setName(String name) {
        this.name = name;
        System.out.println(&quot;2.Bean属性赋值&quot;);
    }

    public void initBean(){
        System.out.println(&quot;3.初始化Bean&quot;);
    }

    public void destroyBean(){
        System.out.println(&quot;5.销毁Bean&quot;);
    }

}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--
        init-method属性指定初始化方法。
        destroy-method属性指定销毁方法。
    --&gt;
    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot; init-method=&quot;initBean&quot; destroy-method=&quot;destroyBean&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BeanLifecycleTest {
    @Test
    public void testLifecycle(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        User userBean = applicationContext.getBean(&quot;userBean&quot;, User.class);
        System.out.println(&quot;4.使用Bean&quot;);
        // 只有正常关闭spring容器才会执行销毁方法
        ClassPathXmlApplicationContext context = (ClassPathXmlApplicationContext) applicationContext;
        context.close();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665392526476-d0efb004-51bf-4eef-bc8c-d3b6a315ee39.png" /></p>
<p>需要注意：</p>
<ol>
<li>只有正常关闭Spring容器，bean的销毁方法才会被调用</li>
<li>ClassPathXmlApplicationContext类才有close()方法</li>
<li>配置文件中的init-method指定初始化方法。destroy-method指定销毁方法。</li>
</ol>
<h2 id="84-bean7">8.4 Bean生命周期之7步</h2>
<p>在以上的5步中，第3步是初始化Bean，如果你还想在初始化前和初始化后添加代码，可以加入“Bean后处理器”</p>
<p>编写一个类实现BeanPostProcessor类，并且重写before和after方法：</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class LogBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;Bean后处理器的before方法执行，即将开始初始化&quot;);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;Bean后处理器的after方法执行，已完成初始化&quot;);
        return bean;
    }
}
</code></pre>
<p>在spring.xml文件中配置“Bean后处理器”：</p>
<pre><code class="language-xml">&lt;!--配置Bean后处理器。这个后处理器将作用于当前配置文件中所有的bean。--&gt;
&lt;bean class=&quot;com.powernode.spring6.bean.LogBeanPostProcessor&quot;/&gt;
</code></pre>
<p><strong>一定要注意：在spring.xml文件中配置的Bean后处理器将做哟甘雨当前配置文件中所有的Bean</strong></p>
<p><img alt="image.png" src="../Spring6.assets/1665393219244-4763ce2a-1cec-4b67-b3b4-54c2d28bc46a.png" /></p>
<p>如果加上Bean后处理器的话，Bean的生命周期就是7步了：</p>
<p><img alt="image.png" src="../Spring6.assets/1665393936765-0ea5dcdd-859a-4ac5-9407-f06022c498b9.png" /></p>
<h2 id="85-bean10">8.5 Bean生命周期之10步</h2>
<p>如果根据源码跟踪，可以划分更细粒度的步骤，10步：</p>
<p><img alt="image.png" src="../Spring6.assets/1665394697870-15de433a-8d50-4b31-9b75-b2ca7090c1c6.png" /></p>
<p>上图中检查Bean是否实现了Aware的相关接口是什么意思？</p>
<p>Aware相关的接口包括：BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</p>
<ul>
<li>当Bean实现了BeanNameAware，Spring会将Bean的名字传给Bean</li>
<li>当Bean实现了BeanClassLoaderAware，Spring会将加载该Bean的类加载器传递给Bean</li>
<li>当Bean实现了BeanFactoryAware，Spring会将Bean工程对象传递给Bean</li>
</ul>
<p>测试以上10步，可以让User类实现5个接口，并实现所有方法：</p>
<ul>
<li>BeanNameAware</li>
<li>BeanCLassLoaderAware</li>
<li>BeanFactoryAware</li>
<li>InitializingBean</li>
<li>DisposableBean</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.*;

public class User implements BeanNameAware, BeanClassLoaderAware, BeanFactoryAware, InitializingBean, DisposableBean {
    private String name;

    public User() {
        System.out.println(&quot;1.实例化Bean&quot;);
    }

    public void setName(String name) {
        this.name = name;
        System.out.println(&quot;2.Bean属性赋值&quot;);
    }

    public void initBean(){
        System.out.println(&quot;6.初始化Bean&quot;);
    }

    public void destroyBean(){
        System.out.println(&quot;10.销毁Bean&quot;);
    }

    @Override
    public void setBeanClassLoader(ClassLoader classLoader) {
        System.out.println(&quot;3.类加载器：&quot; + classLoader);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;3.Bean工厂：&quot; + beanFactory);
    }

    @Override
    public void setBeanName(String name) {
        System.out.println(&quot;3.bean名字：&quot; + name);
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;9.DisposableBean destroy&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;5.afterPropertiesSet执行&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;


public class LogBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;4.Bean后处理器的before方法执行，即将开始初始化&quot;);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;7.Bean后处理器的after方法执行，已完成初始化&quot;);
        return bean;
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665395466500-d95b1a58-24e1-46f0-b72a-aa7764b0336a.png" /></p>
<p>通过测试可以看出来：</p>
<ul>
<li><strong>InitializingBean的方法早于init-method的执行。</strong></li>
<li><strong>DisposableBean的方法早于destroy-method的执行。</strong></li>
</ul>
<p>对于SpringBean的生命周期，掌握之前的7步即可。够用。</p>
<h2 id="86-bean">8.6 Bean的作用域不同，管理方式不同</h2>
<p>Spring根据Bean的作用域来选择管理方式</p>
<ul>
<li>对于singeton作用域的Bean，Spring能够精确地知道该Bean何时被创建，何时初始化完成，以及何时被销毁</li>
<li>而对于prototype作用域的Bean，Spring只负责创建，当容器创建了Bean的实例后，Bean的实例就交给客户端代码管理，Spring容器将不再跟踪其生命周期</li>
</ul>
<p>我们把之前User类的spring.xml文件中的配置scope设置为prototype：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--
    init-method属性指定初始化方法。
    destroy-method属性指定销毁方法。
    --&gt;
    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot; init-method=&quot;initBean&quot; destroy-method=&quot;destroyBean&quot; scope=&quot;prototype&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置Bean后处理器。这个后处理器将作用于当前配置文件中所有的bean。--&gt;
    &lt;bean class=&quot;com.powernode.spring6.bean.LogBeanPostProcessor&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665395807399-a3b71b4d-d871-4230-8fe4-b939ed03b301.png" /></p>
<p>通过测试一目了然。只执行了前8步，第9和10都没有执行。</p>
<h2 id="87-newspring">8.7 自己new的对象如何让Spring管理</h2>
<p>有些时候可能会遇到这样的需求，某个java对象是我们自己new的，然后我们希望这个对象被Spring容器管理，怎么实现？</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class User {
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.User;
import org.junit.Test;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;

public class RegisterBeanTest {

    @Test
    public void testBeanRegister(){
        // 自己new的对象
        User user = new User();
        System.out.println(user);

        // 创建 默认可列表BeanFactory 对象
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
        // 注册Bean
        factory.registerSingleton(&quot;userBean&quot;, user);
        // 从spring容器中获取bean
        User userBean = factory.getBean(&quot;userBean&quot;, User.class);
        System.out.println(userBean);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1666262245551-b00bbba7-4107-4d44-8441-fbcd6f799293.png" /></p>
<h1 id="bean_3">九、Bean的循环依赖问题</h1>
<h2 id="91-bean">9.1 什么是Bean的循环依赖</h2>
<p>A对象中有B属性，B对象中有A属性。这就是循环依赖，我依赖你，你也依赖我</p>
<p>比如：丈夫类Husband，妻子类Wife。Husband中有Wife的引用。Wife中有Husband的引用</p>
<p><img alt="image.png" src="../Spring6.assets/1665452274046-82594b87-2974-4e08-a6ab-2218d001d14f.png" /></p>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class Husband {
    private String name;
    private Wife wife;
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class Wife {
    private String name;
    private Husband husband;
}
</code></pre>
<h2 id="92-singletonset">9.2 singleton下的set注入产生的循环依赖</h2>
<p>我们来编写程序，测试一下在singleton+setter的模式下产生的循环依赖，Spring是否能够解决？</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class Husband {
    private String name;
    private Wife wife;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setWife(Wife wife) {
        this.wife = wife;
    }

    // toString()方法重写时需要注意：不能直接输出wife，输出wife.getName()。要不然会出现递归导致的栈内存溢出错误。
    @Override
    public String toString() {
        return &quot;Husband{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, wife=&quot; + wife.getName() +
                '}';
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class Wife {
    private String name;
    private Husband husband;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setHusband(Husband husband) {
        this.husband = husband;
    }

    // toString()方法重写时需要注意：不能直接输出husband，输出husband.getName()。要不然会出现递归导致的栈内存溢出错误。
    @Override
    public String toString() {
        return &quot;Wife{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, husband=&quot; + husband.getName() +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;husbandBean&quot; class=&quot;com.powernode.spring6.bean.Husband&quot; scope=&quot;singleton&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;wife&quot; ref=&quot;wifeBean&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;wifeBean&quot; class=&quot;com.powernode.spring6.bean.Wife&quot; scope=&quot;singleton&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;小花&quot;/&gt;
        &lt;property name=&quot;husband&quot; ref=&quot;husbandBean&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.Husband;
import com.powernode.spring6.bean.Wife;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class CircularDependencyTest {

    @Test
    public void testSingletonAndSet(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        Husband husbandBean = applicationContext.getBean(&quot;husbandBean&quot;, Husband.class);
        Wife wifeBean = applicationContext.getBean(&quot;wifeBean&quot;, Wife.class);
        System.out.println(husbandBean);
        System.out.println(wifeBean);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665453201014-160bb88e-08d4-4d37-a1d9-44d4911a32df.png" /></p>
<p>通过测试得知：在singleton+set注入的情况下，循环依赖的没有问题的，Spring可以解决这个问题</p>
<h2 id="93-prototypeset">9.3 prototype下的set注入产生的循环依赖</h2>
<p>我们再来测试一下：prototype+set注入的方式下，循环依赖会不会出现问题？</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;husbandBean&quot; class=&quot;com.powernode.spring6.bean.Husband&quot; scope=&quot;prototype&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;wife&quot; ref=&quot;wifeBean&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;wifeBean&quot; class=&quot;com.powernode.spring6.bean.Wife&quot; scope=&quot;prototype&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;小花&quot;/&gt;
        &lt;property name=&quot;husband&quot; ref=&quot;husbandBean&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>执行测试程序：发生了异常，异常信息如下：
Caused by: org.springframework.beans.factory.<strong>BeanCurrentlyInCreationException</strong>: Error creating bean with name 'husbandBean': Requested bean is currently in creation: Is there an unresolvable circular reference?
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:265)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)
    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:325)
    ... 44 more</p>
<p>翻译为：创建名为“husbandBean”的bean时出错：请求的bean当前正在创建中：是否存在无法解析的循环引用？</p>
<p>通过测试得知，当循环依赖的所有Bean的scope=“prototype”的时候，产生的循环依赖，Spring是无法解决的，会出现<strong>BeanCurrentlyInCreationException</strong>异常</p>
<p>大家可以测试一下，以上两个Bean，如果其中一个是singleton，另一个是prototype，是没有问题的。
为什么两个Bean都是prototype时会出错呢？</p>
<p><img alt="image.png" src="../Spring6.assets/1665454469042-69668f45-5d71-494f-8537-18142d354abd.png" /></p>
<h2 id="94-singleton">9.4 singleton下的构造注入产生的循环依赖</h2>
<p>我们再来测试一下singleton + 构造注入的方式下，spring是否能够解决这种循环依赖</p>
<pre><code class="language-java">package com.powernode.spring6.bean2;

public class Husband {
    private String name;
    private Wife wife;

    public Husband(String name, Wife wife) {
        this.name = name;
        this.wife = wife;
    }

    // -----------------------分割线--------------------------------
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return &quot;Husband{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, wife=&quot; + wife +
                '}';
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.bean2;

public class Wife {
    private String name;
    private Husband husband;

    public Wife(String name, Husband husband) {
        this.name = name;
        this.husband = husband;
    }

    // -------------------------分割线--------------------------------
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return &quot;Wife{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, husband=&quot; + husband +
                '}';
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;hBean&quot; class=&quot;com.powernode.spring6.bean2.Husband&quot; scope=&quot;singleton&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;constructor-arg name=&quot;wife&quot; ref=&quot;wBean&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;wBean&quot; class=&quot;com.powernode.spring6.bean2.Wife&quot; scope=&quot;singleton&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;小花&quot;/&gt;
        &lt;constructor-arg name=&quot;husband&quot; ref=&quot;hBean&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testSingletonAndConstructor(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring2.xml&quot;);
    Husband hBean = applicationContext.getBean(&quot;hBean&quot;, Husband.class);
    Wife wBean = applicationContext.getBean(&quot;wBean&quot;, Wife.class);
    System.out.println(hBean);
    System.out.println(wBean);
}
</code></pre>
<p>执行结果：发生了异常，信息如下：
Caused by: org.springframework.beans.factory.<strong>BeanCurrentlyInCreationException</strong>: Error creating bean with name 'hBean': Requested bean is currently in creation: Is there an unresolvable circular reference?
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:355)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:227)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)
    at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:325)
    ... 56 more</p>
<p>和上一个测试结果相同，都是提示产生了循环依赖，并且Spring是无法解决这种循环依赖的。
为什么呢？</p>
<p>主要原因是因为通过构造发注入导致的：因为构造方法注入会导致<strong>实例化对象的过程</strong>和<strong>对象属性赋值的过程</strong>没有分离开，必须在一起完成导致的</p>
<h2 id="95-spring">9.5 Spring解决循环依赖的机理</h2>
<p>Spring为什么可以解决set + singleton模式下循环依赖？</p>
<p>根本原因在于：这种方式可以做到将“实例化Bean”和“Bean属性赋值”这两个操作分开去完成</p>
<p>实例化Bean的时候：调用无参数构造方法来完成。<strong>此时可以先不给属性赋值，可以提前将该Bean对象“曝光”给外界</strong></p>
<p>给Bean属性赋值的时候：调用setter方法来完成</p>
<p>两个步骤是完全可以分离开去完成的，并且这两步不要求在同一个时间点上完成</p>
<p>也就是说，Bean都是单例的，我们可以先把所有的单例Bean实例化出来，放到一个集合中（我们可以称之为缓存），所有的单例Bean全部实例化之后，然后我们再慢慢的调用setter方法给属性赋值，这样就解决了循环依赖的问题</p>
<p>那么在Spring框架底层源码级别上是如何实现的呢？请看：</p>
<p><img alt="image.png" src="../Spring6.assets/1665456331018-18c45ae3-fa4c-4cd8-aabf-d9bace567693.png" /></p>
<p>在以上类中包含三个重要的属性：</p>
<p><strong>Cache of singleton objects: bean name to bean instance. 单例对象的缓存：key存储bean名称，value存储Bean对象【一级缓存】</strong></p>
<p><strong>Cache of early singleton objects: bean name to bean instance. 早期单例对象的缓存：key存储bean名称，value存储早期的Bean对象【二级缓存】</strong></p>
<p><strong>Cache of singleton factories: bean name to ObjectFactory. 单例工厂缓存：key存储bean名称，value存储该Bean对应的ObjectFactory对象【三级缓存】</strong></p>
<p>这三个缓存其实本质上是三个Map集合。</p>
<p>我们再来看，在该类中有这样一个方法addSingletonFactory()，这个方法的作用是：将创建Bean对象的ObjectFactory对象提前曝光。</p>
<p><img alt="image.png" src="../Spring6.assets/1665460724682-2222366d-cc07-43db-a8d0-fb27712b20a4.png" /></p>
<p>再分析下面的源码</p>
<p><img alt="image.png" src="../Spring6.assets/1665460240687-3d0794c4-e6ed-4653-9463-767a7f943ff9.png" /></p>
<p>从源码中可以看到，Spring会先从一级缓存中获取Bean，如果获取不到，则从二级缓存中获取Bean，如果二级缓存还是获取不到，则从三级缓存中获取之前曝光的ObjectFactory对象，通过ObjectFactory对象获取Bean实例，这样就解决了循环依赖的问题</p>
<p><strong>总结：</strong></p>
<p><strong>Spring只能解决setter方法注入的单例Bean之间的循环依赖，Class A依赖Class B， Class B又依赖Class A，形成依赖闭环。Spring在创建Class A对象后，不需要等给属性赋值，直接将其曝光到Bean缓存中。在解析Class A的属性时，又发现依赖于Class B，再次去获取Class B，当解析Class B的属性时，有发现需要Class A的属性，但此时的Class A已经被提前曝光加入了正在创建的Bean缓存中，则无序创建新的Class A的实例，直接从缓存中获取即可，从而解决循环依赖问题</strong></p>
<h1 id="_1">十、回顾反射机制</h1>
<h2 id="101">10.1 分析方法四要素</h2>
<p>我们先来看一下，不使用反射机制调用一个方法需要几个要素的参与。
有一个这样的类：</p>
<pre><code class="language-java">package com.powernode.reflect;

public class SystemService {

    public void logout(){
        System.out.println(&quot;退出系统&quot;);
    }

    public boolean login(String username, String password){
        if (&quot;admin&quot;.equals(username) &amp;&amp; &quot;admin123&quot;.equals(password)) {
            return true;
        }
        return false;
    }
}
</code></pre>
<p>编写程序调用方法：</p>
<pre><code class="language-java">package com.powernode.reflect;

public class ReflectTest01 {
    public static void main(String[] args) {

        // 创建对象
        SystemService systemService = new SystemService();

        // 调用方法并接收方法的返回值
        boolean success = systemService.login(&quot;admin&quot;, &quot;admin123&quot;);

        System.out.println(success ? &quot;登录成功&quot; : &quot;登录失败&quot;);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665469402327-e4cdba7c-2441-4c37-bb6d-c7138ac19bc4.png" /></p>
<p>通过以上第16行代码可以看出，调用一个方法，一般涉及到4个要素：</p>
<ul>
<li>调用那个对象</li>
<li>哪个方法</li>
<li>传什么参数</li>
<li>返回什么值</li>
</ul>
<h2 id="102-method">10.2 获取Method</h2>
<p>要使用反射机制调用一个方法，首先你要获取这个方法</p>
<p>在反射机制中Method实例代表的是一个方法，那么怎么获取Method实例呢？</p>
<p>有这样一个类：</p>
<pre><code class="language-java">package com.powernode.reflect;

public class SystemService {

    public void logout(){
        System.out.println(&quot;退出系统&quot;);
    }

    public boolean login(String username, String password){
        if (&quot;admin&quot;.equals(username) &amp;&amp; &quot;admin123&quot;.equals(password)) {
            return true;
        }
        return false;
    }

    public boolean login(String password){
        if(&quot;110&quot;.equals(password)){
            return true;
        }
        return false;
    }
}
</code></pre>
<p>我们如何获取到 logout()、login(String,String)、login(String) 这三个方法呢？
要获取方法Method，首先你需要获取这个类Class。</p>
<pre><code class="language-java">Class clazz = Class.forName(&quot;com.powernode.reflect.SystemService&quot;);
</code></pre>
<p>当拿到Class之后，调用getDeclaredMethod()方法可以获取到方法。
假如你要获取这个方法：login(String username, String password)</p>
<pre><code class="language-java">Method loginMethod = clazz.getDeclaredMethod(&quot;login&quot;, String.class, String.class);
</code></pre>
<p>假如你要获取到这个方法：login(String password)</p>
<pre><code class="language-java">Method loginMethod = clazz.getDeclaredMethod(&quot;login&quot;, String.class);
</code></pre>
<p>获取一个方法，需要告诉java程序，你要获取的方法名是什么，这个方法上每一个形参的类型是什么，这样java程序才能给你拿到对应的方法</p>
<p>这样的设计也非常合理，因为在同一个类中，方法是支持重载的，也就是说方法名可以一样，但参数列表一定是不太一样的，所以获取一个方法需要提供方法名以及每个形参的类型</p>
<p>假设有这样一个方法：</p>
<pre><code class="language-java">public void setAge(int age){
    this.age = age;
}
</code></pre>
<p>你要获取这个方法的话，代码应该这样写：</p>
<pre><code class="language-java">Method setAgeMethod = clazz.getDeclaredMethod(&quot;setAge&quot;, int.class);
</code></pre>
<p>其中setAge是方法名，int.class是形参的类型。
如果要获取上面的logout方法，代码应该这样写：</p>
<pre><code class="language-java">Method logoutMethod = clazz.getDeclaredMethod(&quot;logout&quot;);
</code></pre>
<p>因为这个方法形式参数的个数是0个。所以只需要提供方法名就行了。</p>
<h2 id="103-method">10.3 调用Method</h2>
<p>要让一个方法调用的话，就要关联到四要素了：</p>
<ul>
<li>调用哪个对象的</li>
<li>哪个方法</li>
<li>传什么参数</li>
<li>返回什么值</li>
</ul>
<pre><code class="language-java">package com.powernode.reflect;

public class SystemService {

    public void logout(){
        System.out.println(&quot;退出系统&quot;);
    }

    public boolean login(String username, String password){
        if (&quot;admin&quot;.equals(username) &amp;&amp; &quot;admin123&quot;.equals(password)) {
            return true;
        }
        return false;
    }

    public boolean login(String password){
        if(&quot;110&quot;.equals(password)){
            return true;
        }
        return false;
    }
}
</code></pre>
<p>假如我们要调用的方法是：login(String, String)</p>
<ol>
<li>创建对象（四要素之首：调用哪个对象的）</li>
</ol>
<pre><code class="language-java">Class clazz = Class.forName(&quot;com.powernode.reflect.SystemService&quot;);
Object obj = clazz.newInstance();
</code></pre>
<ol>
<li>获取方法login(String,String)（四要素之一：哪个方法）</li>
</ol>
<pre><code class="language-java">Method loginMethod = clazz.getDeclaredMethod(&quot;login&quot;, String.class, String.class);
</code></pre>
<ol>
<li>调用方法</li>
</ol>
<pre><code class="language-java">Object retValue = loginMethod.invoke(obj, &quot;admin&quot;, &quot;admin123&quot;);
</code></pre>
<p>解说四要素：</p>
<ul>
<li>哪个对象：obj</li>
<li>哪个方法：loginMethod</li>
<li>传什么参数：“admin”, “admin123”</li>
<li>返回什么值：retValue</li>
</ul>
<pre><code class="language-java">package com.powernode.reflect;

import java.lang.reflect.Method;

public class ReflectTest02 {
    public static void main(String[] args) throws Exception{
        Class clazz = Class.forName(&quot;com.powernode.reflect.SystemService&quot;);
        Object obj = clazz.newInstance();
        Method loginMethod = clazz.getDeclaredMethod(&quot;login&quot;, String.class, String.class);
        Object retValue = loginMethod.invoke(obj, &quot;admin&quot;, &quot;admin123&quot;);
        System.out.println(retValue);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665471501974-88a80910-1c8e-495b-956f-d6b7a82bf5b4.png" /></p>
<p>那如果调用既没有参数，又没有返回值的logout方法，应该怎么做?</p>
<pre><code class="language-java">package com.powernode.reflect;

import java.lang.reflect.Method;

public class ReflectTest03 {
    public static void main(String[] args) throws Exception{
        Class clazz = Class.forName(&quot;com.powernode.reflect.SystemService&quot;);
        Object obj = clazz.newInstance();
        Method logoutMethod = clazz.getDeclaredMethod(&quot;logout&quot;);
        logoutMethod.invoke(obj);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665471647046-386be2b3-e848-4a3d-82ea-7faf1c802a04.png" /></p>
<h2 id="104">10.4 假设你知道属性名</h2>
<p>假设有这样一个类：</p>
<pre><code class="language-java">package com.powernode.reflect;

public class User {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<p>你知道以下这几条信息：</p>
<ul>
<li>类名是：com.powernode.reflect.User</li>
<li>该类中有String类型的name属性和int类型的age属性。</li>
<li>另外你也知道该类的设计符合javabean规范。（也就是说属性私有化，对外提供setter和getter方法）</li>
</ul>
<p>你如何通过反射机制给User对象的name属性赋值zhangsan，给age属性赋值20岁。</p>
<pre><code class="language-java">package com.powernode.reflect;

import java.lang.reflect.Method;

public class UserTest {
    public static void main(String[] args) throws Exception{
        // 已知类名
        String className = &quot;com.powernode.reflect.User&quot;;
        // 已知属性名
        String propertyName = &quot;age&quot;;

        // 通过反射机制给User对象的age属性赋值20岁
        Class&lt;?&gt; clazz = Class.forName(className);
        Object obj = clazz.newInstance(); // 创建对象

        // 根据属性名获取setter方法名
        String setMethodName = &quot;set&quot; + propertyName.toUpperCase().charAt(0) + propertyName.substring(1);

        // 获取Method
        Method setMethod = clazz.getDeclaredMethod(setMethodName, int.class);

        // 调用Method
        setMethod.invoke(obj, 20);

        System.out.println(obj);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665472287604-1994754e-51c1-4bd4-8a50-2fc0b0995ea6.png" /></p>
<h1 id="spring_3">十一、手写Spring框架</h1>
<p>Spring IoC容器的实现原理：工厂模式+解析XML+反射机制</p>
<p>我们给自己的框架起名为：myspring（我的春天）</p>
<h2 id="myspring">第一步：创建模块myspring</h2>
<p>采用Maven方式新建Module：myspring</p>
<p><img alt="image.png" src="../Spring6.assets/1665475207334-bd779f04-b490-4237-9ab1-306989458f22.png" /></p>
<p>打包方式采用jar，并且引入dom4j和jaxen的依赖，因为要使用它解析XML文件，还有junit依赖。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.myspringframework&lt;/groupId&gt;
    &lt;artifactId&gt;myspring&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;
            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
            &lt;version&gt;2.1.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jaxen&lt;/groupId&gt;
            &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
            &lt;version&gt;1.2.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<h2 id="bean_4">第二步：准备好我们要管理的Bean</h2>
<p>准备好我们要管理的Bean（<strong>这些Bean在将来开发完框架之后是要删除的</strong>）
注意包名，不要用org.myspringframework包，因为这些Bean不是框架内置的。是将来使用我们框架的程序员提供的。</p>
<pre><code class="language-java">package com.powernode.myspring.bean;

public class Address {
    private String city;
    private String street;
    private String zipcode;

    public Address() {
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String street) {
        this.street = street;
    }

    public String getZipcode() {
        return zipcode;
    }

    public void setZipcode(String zipcode) {
        this.zipcode = zipcode;
    }

    @Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;city='&quot; + city + '\'' +
                &quot;, street='&quot; + street + '\'' +
                &quot;, zipcode='&quot; + zipcode + '\'' +
                '}';
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.myspring.bean;

public class User {
    private String name;
    private int age;
    private Address addr;

    public User() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Address getAddr() {
        return addr;
    }

    public void setAddr(Address addr) {
        this.addr = addr;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, addr=&quot; + addr +
                '}';
    }
}
</code></pre>
<h2 id="myspringxml">第三步：准备myspring.xml配置文件</h2>
<p>将来在框架开发完毕之后，这个文件也是要删除的。因为这个配置文件的提供者应该是使用这个框架的程序员。
文件名随意，我们这里叫做：myspring.xml
文件放在类路径当中即可，我们这里把文件放到类的根路径下。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans&gt;

    &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.myspring.bean.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;
        &lt;property name=&quot;addr&quot; ref=&quot;addrBean&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;addrBean&quot; class=&quot;com.powernode.myspring.bean.Address&quot;&gt;
        &lt;property name=&quot;city&quot; value=&quot;北京&quot;/&gt;
        &lt;property name=&quot;street&quot; value=&quot;大兴区&quot;/&gt;
        &lt;property name=&quot;zipcode&quot; value=&quot;1000001&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>使用value给简单属性赋值。使用ref给非简单属性赋值。</p>
<h2 id="applicationcontext">第四步：编写ApplicationContext接口</h2>
<p>ApplicationContext接口中提供一个getBean()方法，通过该方法可以获取Bean对象。
注意包名：这个接口就是myspring框架中的一员了。</p>
<pre><code class="language-java">package org.myspringframework.core;

public interface ApplicationContext {
    /**
     * 根据bean的id获取bean实例。
     * @param beanId bean的id
     * @return bean实例
     */
    Object getBean(String beanId);
}
</code></pre>
<h2 id="classpathxmlapplicationcontext">第五步：编写ClassPathXmlApplicationContext</h2>
<p>ClassPathXmlApplicationContext是ApplicationContext接口的实现类。该类从类路径当中加载myspring.xml配置文件。</p>
<pre><code class="language-java">package org.myspringframework.core;

public class ClassPathXmlApplicationContext implements ApplicationContext{
    @Override
    public Object getBean(String beanId) {
        return null;
    }
}
</code></pre>
<h2 id="mapbean">第六步：确定采用Map集合存储Bean</h2>
<p>确定采用Map集合存储Bean实例。Map集合的key存储beanId，value存储Bean实例。Map<String,Object>
在ClassPathXmlApplicationContext类中添加Map<String,Object>属性。
并且在ClassPathXmlApplicationContext类中添加构造方法，该构造方法的参数接收myspring.xml文件。
同时实现getBean方法。</p>
<pre><code class="language-java">package org.myspringframework.core;

import java.util.HashMap;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext{
    /**
     * 存储bean的Map集合
     */
    private Map&lt;String,Object&gt; beanMap = new HashMap&lt;&gt;();

    /**
     * 在该构造方法中，解析myspring.xml文件，创建所有的Bean实例，并将Bean实例存放到Map集合中。
     * @param resource 配置文件路径（要求在类路径当中）
     */
    public ClassPathXmlApplicationContext(String resource) {

    }

    @Override
    public Object getBean(String beanId) {
        return beanMap.get(beanId);
    }
}
</code></pre>
<h2 id="bean_5">第七步：解析配置文件实例化所有Bean</h2>
<p>在ClassPathXmlApplicationContext的构造方法中解析配置文件，获取所有bean的类名，通过反射机制调用无参数构造方法创建Bean。并且将Bean对象存放到Map集合中。</p>
<pre><code class="language-java">/**
* 在该构造方法中，解析myspring.xml文件，创建所有的Bean实例，并将Bean实例存放到Map集合中。
* @param resource 配置文件路径（要求在类路径当中）
*/
public ClassPathXmlApplicationContext(String resource) {
    try {
        SAXReader reader = new SAXReader();
        Document document = reader.read(ClassLoader.getSystemClassLoader().getResourceAsStream(resource));
        // 获取所有的bean标签
        List&lt;Node&gt; beanNodes = document.selectNodes(&quot;//bean&quot;);
        // 遍历集合
        beanNodes.forEach(beanNode -&gt; {
            Element beanElt = (Element) beanNode;
            // 获取id
            String id = beanElt.attributeValue(&quot;id&quot;);
            // 获取className
            String className = beanElt.attributeValue(&quot;class&quot;);
            try {
                // 通过反射机制创建对象
                Class&lt;?&gt; clazz = Class.forName(className);
                Constructor&lt;?&gt; defaultConstructor = clazz.getDeclaredConstructor();
                Object bean = defaultConstructor.newInstance();
                // 存储到Map集合
                beanMap.put(id, bean);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2 id="bea">第八步：测试能否获取到Bea</h2>
<pre><code class="language-java">package com.powernode.myspring.test;

import org.junit.Test;
import org.myspringframework.core.ApplicationContext;
import org.myspringframework.core.ClassPathXmlApplicationContext;

public class MySpringTest {
    @Test
    public void testMySpring(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;myspring.xml&quot;);
        Object userBean = applicationContext.getBean(&quot;userBean&quot;);
        Object addrBean = applicationContext.getBean(&quot;addrBean&quot;);
        System.out.println(userBean);
        System.out.println(addrBean);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665478707450-7e52f70c-97b2-4e6d-b96f-cc5bea8b51a4.png" /></p>
<p>通过测试Bean已经实例化成功了，属性的值是null，这是我们能够想到的，毕竟我们调用的是无参数构造方法，所以属性都是默认值。
下一步就是我们应该如何给Bean的属性赋值呢？</p>
<h2 id="bean_6">第九步：给Bean的属性赋值</h2>
<p>通过反射机制调用set方法，给Bean的属性赋值。
继续在ClassPathXmlApplicationContext构造方法中编写代码</p>
<pre><code class="language-java">package org.myspringframework.core;

import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext{
    /**
     * 存储bean的Map集合
     */
    private Map&lt;String,Object&gt; beanMap = new HashMap&lt;&gt;();

    /**
     * 在该构造方法中，解析myspring.xml文件，创建所有的Bean实例，并将Bean实例存放到Map集合中。
     * @param resource 配置文件路径（要求在类路径当中）
     */
    public ClassPathXmlApplicationContext(String resource) {
        try {
            SAXReader reader = new SAXReader();
            Document document = reader.read(ClassLoader.getSystemClassLoader().getResourceAsStream(resource));
            // 获取所有的bean标签
            List&lt;Node&gt; beanNodes = document.selectNodes(&quot;//bean&quot;);
            // 遍历集合（这里的遍历只实例化Bean，不给属性赋值。为什么要这样做？）
            beanNodes.forEach(beanNode -&gt; {
                Element beanElt = (Element) beanNode;
                // 获取id
                String id = beanElt.attributeValue(&quot;id&quot;);
                // 获取className
                String className = beanElt.attributeValue(&quot;class&quot;);
                try {
                    // 通过反射机制创建对象
                    Class&lt;?&gt; clazz = Class.forName(className);
                    Constructor&lt;?&gt; defaultConstructor = clazz.getDeclaredConstructor();
                    Object bean = defaultConstructor.newInstance();
                    // 存储到Map集合
                    beanMap.put(id, bean);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            // 再重新遍历集合，这次遍历是为了给Bean的所有属性赋值。
            // 思考：为什么不在上面的循环中给Bean的属性赋值，而在这里再重新遍历一次呢？
            // 通过这里你是否能够想到Spring是如何解决循环依赖的：实例化和属性赋值分开。
            beanNodes.forEach(beanNode -&gt; {
                Element beanElt = (Element) beanNode;
                // 获取bean的id
                String beanId = beanElt.attributeValue(&quot;id&quot;);
                // 获取所有property标签
                List&lt;Element&gt; propertyElts = beanElt.elements(&quot;property&quot;);
                // 遍历所有属性
                propertyElts.forEach(propertyElt -&gt; {
                    try {
                        // 获取属性名
                        String propertyName = propertyElt.attributeValue(&quot;name&quot;);
                        // 获取属性类型
                        Class&lt;?&gt; propertyType = beanMap.get(beanId).getClass().getDeclaredField(propertyName).getType();
                        // 获取set方法名
                        String setMethodName = &quot;set&quot; + propertyName.toUpperCase().charAt(0) + propertyName.substring(1);
                        // 获取set方法
                        Method setMethod = beanMap.get(beanId).getClass().getDeclaredMethod(setMethodName, propertyType);
                        // 获取属性的值，值可能是value，也可能是ref。
                        // 获取value
                        String propertyValue = propertyElt.attributeValue(&quot;value&quot;);
                        // 获取ref
                        String propertyRef = propertyElt.attributeValue(&quot;ref&quot;);
                        Object propertyVal = null;
                        if (propertyValue != null) {
                            // 该属性是简单属性
                            String propertyTypeSimpleName = propertyType.getSimpleName();
                            switch (propertyTypeSimpleName) {
                                case &quot;byte&quot;: case &quot;Byte&quot;:
                                    propertyVal = Byte.valueOf(propertyValue);
                                    break;
                                case &quot;short&quot;: case &quot;Short&quot;:
                                    propertyVal = Short.valueOf(propertyValue);
                                    break;
                                case &quot;int&quot;: case &quot;Integer&quot;:
                                    propertyVal = Integer.valueOf(propertyValue);
                                    break;
                                case &quot;long&quot;: case &quot;Long&quot;:
                                    propertyVal = Long.valueOf(propertyValue);
                                    break;
                                case &quot;float&quot;: case &quot;Float&quot;:
                                    propertyVal = Float.valueOf(propertyValue);
                                    break;
                                case &quot;double&quot;: case &quot;Double&quot;:
                                    propertyVal = Double.valueOf(propertyValue);
                                    break;
                                case &quot;boolean&quot;: case &quot;Boolean&quot;:
                                    propertyVal = Boolean.valueOf(propertyValue);
                                    break;
                                case &quot;char&quot;: case &quot;Character&quot;:
                                    propertyVal = propertyValue.charAt(0);
                                    break;
                                case &quot;String&quot;:
                                    propertyVal = propertyValue;
                                    break;
                            }
                            setMethod.invoke(beanMap.get(beanId), propertyVal);
                        }
                        if (propertyRef != null) {
                            // 该属性不是简单属性
                            setMethod.invoke(beanMap.get(beanId), beanMap.get(propertyRef));
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                });
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public Object getBean(String beanId) {
        return beanMap.get(beanId);
    }
}
</code></pre>
<p><strong>重点处理：当property标签中是value怎么办？是ref怎么办？</strong></p>
<p><img alt="image.png" src="../Spring6.assets/1665481050714-a41f73d9-67bb-40b9-9137-601a0775450d.png" /></p>
<h2 id="_2">第十步：打包发布</h2>
<p><img alt="image.png" src="../Spring6.assets/1665481384984-b9b107a7-6566-473a-95df-fc7fcb613f18.png" /></p>
<p><img alt="image.png" src="../Spring6.assets/1665481462831-bbd5bfd3-d647-4c04-990a-9c39a4116d21.png" /></p>
<h2 id="myspring_1">第十一步：站在程序员角度使用myspring框架</h2>
<p>新建模块：myspring-test</p>
<p><img alt="image.png" src="../Spring6.assets/1665481605553-46ba6264-a360-4700-a696-1aa536c44cf1.png" /></p>
<p>引入myspring框架的依赖：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.powernode&lt;/groupId&gt;
    &lt;artifactId&gt;myspring-test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.myspringframework&lt;/groupId&gt;
            &lt;artifactId&gt;myspring&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<p>编写Bean</p>
<pre><code class="language-java">package com.powernode.myspring.bean;

public class UserDao {
    public void insert(){
        System.out.println(&quot;UserDao正在插入数据&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.myspring.bean;

public class UserService {
    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        System.out.println(&quot;UserService开始执行save操作&quot;);
        userDao.insert();
        System.out.println(&quot;UserService执行save操作结束&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans&gt;

    &lt;bean id=&quot;userServiceBean&quot; class=&quot;com.powernode.myspring.bean.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.myspring.bean.UserDao&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.myspring.test;

import com.powernode.myspring.bean.UserService;
import org.junit.Test;
import org.myspringframework.core.ApplicationContext;
import org.myspringframework.core.ClassPathXmlApplicationContext;

public class MySpringTest {

    @Test
    public void testMySpring(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;myspring.xml&quot;);
        UserService userServiceBean = (UserService) applicationContext.getBean(&quot;userServiceBean&quot;);
        userServiceBean.save();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665482096446-2015f7a8-3e86-4d74-a26b-a3d417c250fa.png" /></p>
<h1 id="spring-ioc">十二、Spring IoC注解式开发</h1>
<h2 id="121">12.1 回顾注解</h2>
<p>注解的存在主要是为了简化XML的配置。Spring6倡导全注解开发</p>
<p>我们来回顾一下：</p>
<ul>
<li>注解怎么定义，注解中的属性怎么定义</li>
<li>注解怎么用</li>
<li>通过反射机制怎么读取注解</li>
</ul>
<p><strong>注解怎么定义，注解中的属性怎么定义？</strong></p>
<pre><code class="language-java">package com.powernode.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Component {
    String value();
}
</code></pre>
<p>以上是自定义了一个注解：Component</p>
<p>该注解上面修饰的注解包括：Target注解和Retention注解，这两个注解被称为元注解</p>
<p>Target注解用来设置Component注解可以出现的位置，以上代表表示Component注解只能用在类和接口上</p>
<p>Retention注解用来设置Component注解的保持性策略，以上代码Component注解可以被反射机制读取</p>
<p>String value();是Component注解中的一个属性，该属性类型String，属性名是value</p>
<p><strong>注解如何使用？</strong></p>
<pre><code class="language-java">package com.powernode.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Component {
    String value();
}
</code></pre>
<p>用法简单，语法格式：@注解类型名（属性名=属性值，属性名=属性值，属性名=属性值.....）</p>
<p>userBean为什么使用双引号括起来，因为value属性是String属性，字符串</p>
<p>另外如果属性名是value，则再使用的时候可以省略属性名</p>
<pre><code class="language-java">package com.powernode.bean;

import com.powernode.annotation.Component;

//@Component(value = &quot;userBean&quot;)
@Component(&quot;userBean&quot;)
public class User {
}
</code></pre>
<p><strong>通过反射机制怎么读取注解？</strong></p>
<p>接下来，我们来写一段程序，当Bean类上有Component注解时，则实例化Bean对象，如果没有，则不实例化对象。
我们准备两个Bean，一个上面有注解，一个上面没有注解。</p>
<pre><code class="language-java">package com.powernode.bean;

import com.powernode.annotation.Component;

@Component(&quot;userBean&quot;)
public class User {
}
</code></pre>
<pre><code class="language-java">package com.powernode.bean;

public class Vip {
}
</code></pre>
<p>假设我们现在只知道包名：com.powernode.bean。至于这个包下有多少个Bean我们不知道。哪些Bean上有注解，哪些Bean上没有注解，这些我们都不知道，如何通过程序全自动化判断。</p>
<pre><code class="language-java">package com.powernode.test;

import com.powernode.annotation.Component;

import java.io.File;
import java.net.URL;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

public class Test {
    public static void main(String[] args) throws Exception {
        // 存放Bean的Map集合。key存储beanId。value存储Bean。
        Map&lt;String,Object&gt; beanMap = new HashMap&lt;&gt;();

        String packageName = &quot;com.powernode.bean&quot;;
        String path = packageName.replaceAll(&quot;\\.&quot;, &quot;/&quot;);
        URL url = ClassLoader.getSystemClassLoader().getResource(path);
        File file = new File(url.getPath());
        File[] files = file.listFiles();
        Arrays.stream(files).forEach(f -&gt; {
            String className = packageName + &quot;.&quot; + f.getName().split(&quot;\\.&quot;)[0];
            try {
                Class&lt;?&gt; clazz = Class.forName(className);
                if (clazz.isAnnotationPresent(Component.class)) {
                    Component component = clazz.getAnnotation(Component.class);
                    String beanId = component.value();
                    Object bean = clazz.newInstance();
                    beanMap.put(beanId, bean);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        });

        System.out.println(beanMap);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665543007882-24036142-350b-4209-bb20-46a61e35716d.png" /></p>
<h2 id="122-bean">12.2 声明Bean的注解</h2>
<p>负责声明Bean的注解，常见的包括四个：</p>
<ol>
<li>@Component</li>
<li>@Controller</li>
<li>@Service</li>
<li>@Repository</li>
</ol>
<p>源码如下：</p>
<pre><code class="language-java">package com.powernode.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Component {
    String value();
}
</code></pre>
<pre><code class="language-java">package org.springframework.stereotype;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.core.annotation.AliasFor;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
</code></pre>
<pre><code class="language-java">package org.springframework.stereotype;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.core.annotation.AliasFor;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
</code></pre>
<pre><code class="language-java">package org.springframework.stereotype;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.core.annotation.AliasFor;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Repository {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
</code></pre>
<p>通过源码可以看到，@Controller、@Service、@Repository这三个注解都是@Component注解的别名</p>
<p>也就是说：这四个注解的功能都一样，用哪个都可以</p>
<p>只是为了增强程序的可读性，建议：</p>
<ul>
<li>控制器类上使用：@Controller</li>
<li>service类上使用：@Service</li>
<li>dao类上使用：@Repository</li>
</ul>
<p>他们都是只有一个value属性，value属性用来制定bean的id，也就是bean的名字</p>
<p><img alt="image.png" src="../Spring6.assets/1665545099269-ebd7e446-bc2f-4442-89b8-3f513e546a8b.png" /></p>
<h2 id="123-spring">12.3 Spring注解的使用</h2>
<p>如何使用以上的注解呢？</p>
<ol>
<li>加入aop的依赖</li>
<li>在配置文件中添加context命名空间</li>
<li>在配置文件中指定扫描的包</li>
<li>在Bean类上使用注解</li>
</ol>
<p><strong>第一步：加入aop的依赖</strong>
我们可以看到当加入spring-context依赖之后，会关联加入aop的依赖。所以这一步不用做。</p>
<p><img alt="image.png" src="../Spring6.assets/1665545268001-e3fb24f3-6688-4f52-a8c7-7c3084fa10a2.png" /></p>
<p><strong>第二步：在配置文件中添加context命名空间</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<p><strong>第三步：在配置文件中指定要扫描的包</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>第四步：在Bean类上使用注解</strong></p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.stereotype.Component;

@Component(value = &quot;userBean&quot;)
public class User {
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AnnotationTest {
    @Test
    public void testBean(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        User userBean = applicationContext.getBean(&quot;userBean&quot;, User.class);
        System.out.println(userBean);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665545669944-c067eacb-f65b-45ab-b68b-2320647cdfb4.png" /></p>
<p><strong>如果注解的属性名是value，那么value是可以省略的。</strong></p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.stereotype.Component;

@Component(&quot;vipBean&quot;)
public class Vip {
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.Vip;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AnnotationTest {
    @Test
    public void testBean(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        Vip vipBean = applicationContext.getBean(&quot;vipBean&quot;, Vip.class);
        System.out.println(vipBean);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665545860738-8bae2a45-efa8-40eb-9213-0dbd2ae1b54a.png" /></p>
<p><strong>如果把value属性彻底去掉，spring会被Bean自动取名吗？会的。并且默认名字的规律是：Bean类名首字母小写即可</strong></p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.stereotype.Component;

@Component
public class BankDao {
}
</code></pre>
<p>也就是说，这个BankDao的bean的名字为：bankDao</p>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.BankDao;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AnnotationTest {
    @Test
    public void testBean(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        BankDao bankDao = applicationContext.getBean(&quot;bankDao&quot;, BankDao.class);
        System.out.println(bankDao);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665546100844-e0ffc213-8126-419a-ab67-7f433ad43105.png" /></p>
<p>我们将Component注解换成其它三个注解，看看是否可以用：</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.stereotype.Controller;

@Controller
public class BankDao {
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665546198246-f9d6adc1-ecc8-4e8c-babf-49f2ed7b87cd.png" /></p>
<p><strong>如果是多个包怎么办？有两种解决方案：</strong></p>
<ol>
<li><strong>在配置文件中指定多个包，用逗号隔开</strong></li>
<li><strong>指定多个包的共同父包</strong></li>
</ol>
<p>先来测试一下逗号（英文）的方式：
创建一个新的包：bean2，定义一个Bean类。</p>
<pre><code class="language-java">package com.powernode.spring6.bean2;

import org.springframework.stereotype.Service;

@Service
public class Order {
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean,com.powernode.spring6.bean2&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.BankDao;
import com.powernode.spring6.bean2.Order;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AnnotationTest {
    @Test
    public void testBean(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        BankDao bankDao = applicationContext.getBean(&quot;bankDao&quot;, BankDao.class);
        System.out.println(bankDao);
        Order order = applicationContext.getBean(&quot;order&quot;, Order.class);
        System.out.println(order);
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665546710304-8ebbe95d-1d1d-44fa-9605-9dad43e487b7.png" /></p>
<p>我们再来看看，指定共同的父包行不行：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665546777022-4eb8c5e3-22ed-4baf-8722-a5fa98df253d.png" /></p>
<h2 id="124-bean">12.4 选择性实例化Bean</h2>
<p>假设在某个包邮很多Bean，有的Bean上标注了Component，有的标注了Controller，有的标注了Service，有的标注了Repository，现在由于某种特殊业务的需要，只允许其中所有的Controller参与Bean管理，其他的都不实例化。这应该怎么办呢？</p>
<pre><code class="language-java">package com.powernode.spring6.bean3;

import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;

@Component
public class A {
    public A() {
        System.out.println(&quot;A的无参数构造方法执行&quot;);
    }
}

@Controller
class B {
    public B() {
        System.out.println(&quot;B的无参数构造方法执行&quot;);
    }
}

@Service
class C {
    public C() {
        System.out.println(&quot;C的无参数构造方法执行&quot;);
    }
}

@Repository
class D {
    public D() {
        System.out.println(&quot;D的无参数构造方法执行&quot;);
    }
}

@Controller
class E {
    public E() {
        System.out.println(&quot;E的无参数构造方法执行&quot;);
    }
}

@Controller
class F {
    public F() {
        System.out.println(&quot;F的无参数构造方法执行&quot;);
    }
}
</code></pre>
<p>我只想实例化bean3包下的Controller。配置文件这样写：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean3&quot; use-default-filters=&quot;false&quot;&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;

&lt;/beans&gt;
</code></pre>
<p>use-default-filters="true" 表示：使用spring默认的规则，只要有Component、Controller、Service、Repository中的任意一个注解标注，则进行实例化。</p>
<p><strong>use-default-filters="false"</strong> 表示：不再spring默认实例化规则，即使有Component、Controller、Service、Repository这些注解标注，也不再实例化。</p>
<p><context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/> 表示只有Controller进行实例化。</p>
<pre><code class="language-java">@Test
public void testChoose(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-choose.xml&quot;);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665556059297-de0d7dbc-aa37-46a3-9b1d-1d4c246b0ffc.png" /></p>
<p>也可以将use-default-filters设置为true（不写就是true），并且采用exclude-filter方式排出哪些注解标注的Bean不参与实例化：</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.powernode.spring6.bean3&quot;&gt;
  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;
  &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665556372417-14f2208c-4151-4bcd-9f22-80db5e3ed837.png" /></p>
<h2 id="125">12.5 负责注入的注解</h2>
<p>@Component @Controller @Service @Repository 这四个注解是用来声明Bean的，声明后这些Bean将被实例化。接下来我们看一下，如何给Bean的属性赋值。给Bean属性赋值需要用到这些注解：</p>
<ul>
<li>@Value</li>
<li>@Autowired</li>
<li>@Qualifier</li>
<li>@Resource</li>
</ul>
<h3 id="1251-value">12.5.1 @Value</h3>
<p>当属性的类型是<strong>简单类型</strong>时，可以使用@Value注解进行注入。</p>
<pre><code class="language-java">package com.powernode.spring6.bean4;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class User {
    @Value(value = &quot;zhangsan&quot;)
    private String name;
    @Value(&quot;20&quot;)
    private int age;

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<p>开启包扫描：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean4&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testValue(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-injection.xml&quot;);
    Object user = applicationContext.getBean(&quot;user&quot;);
    System.out.println(user);
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665557109935-e0300b67-fd35-4d66-99d1-dac41cb0f13d.png" /></p>
<p>通过以上代码可以发现，我们并没有给属性提供setter方法，但仍然可以完成属性赋值。
如果提供setter方法，并且在setter方法上添加@Value注解，可以完成注入吗？尝试一下</p>
<pre><code class="language-java">package com.powernode.spring6.bean4;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class User {

    private String name;

    private int age;

    @Value(&quot;李四&quot;)
    public void setName(String name) {
        this.name = name;
    }

    @Value(&quot;30&quot;)
    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<p>通过测试可以得知，@Value注解可以直接使用在属性上，也可以使用在setter方法上。都是可以的。都可以完成属性的赋值。
为了简化代码，以后我们一般不提供setter方法，直接在属性上使用@Value注解完成属性赋值。
出于好奇，我们再来测试一下，是否能够通过构造方法完成注入：</p>
<pre><code class="language-java">package com.powernode.spring6.bean4;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class User {

    private String name;

    private int age;

    public User(@Value(&quot;隔壁老王&quot;) String name, @Value(&quot;33&quot;) int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665557643220-1010bea9-5578-4388-8868-4beb11dfbe95.png" /></p>
<p>通过测试得知：@Value注解可以出现在属性上、setter方法上、以及构造方法的形参上。可见Spring给我们提供了多样化的注入。太灵活了。</p>
<h3 id="1252-autowiredqualifier">12.5.2 @Autowired与@Qualifier</h3>
<p>@Autowired注解可以用来注入<strong>非简单类型</strong>。被翻译为：自动连线的，或者自动装配。
单独使用@Autowired注解，<strong>默认根据类型装配</strong>。【<strong>默认是byType</strong>】
看一下它的源码：</p>
<pre><code class="language-java">package org.springframework.beans.factory.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
    boolean required() default true;
}
</code></pre>
<p>源码中有两处需要注意：</p>
<ol>
<li>该注解可以标注在哪里？</li>
<li>构造方法上</li>
<li>方法上</li>
<li>形参上</li>
<li>属性上</li>
<li>注解上</li>
<li>该注解有一个require属性，默认是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果require属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错</li>
</ol>
<p><strong>我们先在属性上使用@Autowired注解：</strong></p>
<pre><code class="language-java">package com.powernode.spring6.dao;

public interface UserDao {
    void insert();
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.dao;

import org.springframework.stereotype.Repository;

@Repository //纳入bean管理
public class UserDaoForMySQL implements UserDao{
    @Override
    public void insert() {
        System.out.println(&quot;正在向mysql数据库插入User数据&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service // 纳入bean管理
public class UserService {

    @Autowired // 在属性上注入
    private UserDao userDao;

    // 没有提供构造方法和setter方法。

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6.dao,com.powernode.spring6.service&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testAutowired(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-injection.xml&quot;);
    UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class);
    userService.save();
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665561365140-b0200308-0c25-4a29-96be-5a93594e2d2b.png" /></p>
<p>以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。
<strong>接下来，再来测试一下@Autowired注解出现在setter方法上：</strong></p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665562770986-e19377a6-af3e-4082-9463-16c795742ad5.png" /></p>
<p><strong>我们再来看看能不能出现在构造方法上：</strong></p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665562985700-7820d3d8-cf43-43af-8c81-46f301ea2835.png" /></p>
<p><strong>再来看看，这个注解能不能只标注在构造方法的形参上：</strong></p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    public UserService(@Autowired UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665563225083-172d5675-cfcb-4f63-9b83-ce85b29b953e.png" /></p>
<p><strong>还有更劲爆的，当有参数的构造方法只有一个时，@Autowired注解可以省略</strong></p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665563320900-df9e4cb3-c046-4f5c-b482-42951f18fb16.png" /></p>
<p><strong>当然，如果有多个构造方法，@Autowired肯定是不能省略的。</strong></p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }

    public UserService(){

    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665563410134-267b2484-54a3-4204-8e02-a9499ecbe614.png" /></p>
<p>到此为止，我们已经清楚@Autowired注解可以出现在哪些位置了。
@Autowired注解默认是byType进行注入的，也就是说根据类型注入的，如果以上程序中，UserDao接口还有另外一个实现类，会出现问题吗？</p>
<pre><code class="language-java">package com.powernode.spring6.dao;

import org.springframework.stereotype.Repository;

@Repository //纳入bean管理
public class UserDaoForOracle implements UserDao{
    @Override
    public void insert() {
        System.out.println(&quot;正在向Oracle数据库插入User数据&quot;);
    }
}
</code></pre>
<p>当你写完这个新的实现类之后，此时IDEA工具已经提示错误信息了：</p>
<p><img alt="image.png" src="../Spring6.assets/1665563729880-0421bc02-19ca-4353-8a10-5b0ef9972b90.png" /></p>
<p>错误信息中说：不能装配，UserDao这个Bean的数量大于1.
怎么解决这个问题呢？<strong>当然要byName，根据名称进行装配了。</strong>
@Autowired注解和@Qualifier注解联合起来才可以根据名称进行装配，在@Qualifier注解中指定Bean名称。</p>
<pre><code class="language-java">package com.powernode.spring6.dao;

import org.springframework.stereotype.Repository;

@Repository // 这里没有给bean起名，默认名字是：userDaoForOracle
public class UserDaoForOracle implements UserDao{
    @Override
    public void insert() {
        System.out.println(&quot;正在向Oracle数据库插入User数据&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    @Autowired
    @Qualifier(&quot;userDaoForOracle&quot;) // 这个是bean的名字。
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665564055076-ffda3ad0-f957-4216-bf6c-957d62724d5f.png" /></p>
<p>总结：</p>
<ul>
<li>@Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上</li>
<li>当带参数的构造方法只有一个，@Autowired注解可以省略</li>
<li>@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用</li>
</ul>
<h3 id="1253-resource">12.5.3 @Resource</h3>
<p>@Resource注解也可以完成非简单类型注入，那它和@Autowried注解有什么区别？</p>
<ul>
<li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性(JSR-250标准中制定的注解类型。JSR是Java规范提案。)</li>
<li>@Autowried注解是spring框架自己的</li>
<li><strong>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name，通过name找不到的话会自动启动通过类型byType装配</strong></li>
<li><strong>@Autowried注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起使用</strong></li>
<li>@Resource注解用在属性上、setter方法上</li>
<li>@Autowried注解用在属性上、setter方法上、构造方法上、构造方法参数上</li>
</ul>
<p>@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【<strong>如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。</strong>】</p>
<p>如果你是Spring6+版本使用这个依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
  &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
  &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>一定要注意：<strong>如果你用Spring6，要知道Spring6不再支持JavaEE，它支持的是JakartaEE9。（Oracle把JavaEE贡献给Apache了，Apache把JavaEE的名字改成JakartaEE了，大家之前所接触的所有的  javax.<em>  包名统一修改为  jakarta.</em>包名了。）</strong></p>
<p>如果你是spring5-版本使用这个依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
  &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;
  &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>@Resource注解源码如下：</p>
<p><img alt="image.png" src="../Spring6.assets/1665565515435-2ad5614a-8572-4c6f-80c1-efa236dbe35f.png" /></p>
<pre><code class="language-java">package com.powernode.spring6.dao;

import org.springframework.stereotype.Repository;

@Repository(&quot;xyz&quot;)
public class UserDaoForOracle implements UserDao{
    @Override
    public void insert() {
        System.out.println(&quot;正在向Oracle数据库插入User数据&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Resource(name = &quot;xyz&quot;)
    private UserDao userDao;

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665622877352-0ae69e3c-e7f3-452d-a405-392901612465.png" /></p>
<p><strong>我们把UserDaoForOracle的名字xyz修改为userDao，让这个Bean的名字和UserService类中的UserDao属性名一致：</strong></p>
<pre><code class="language-java">package com.powernode.spring6.dao;

import org.springframework.stereotype.Repository;

@Repository(&quot;userDao&quot;)
public class UserDaoForOracle implements UserDao{
    @Override
    public void insert() {
        System.out.println(&quot;正在向Oracle数据库插入User数据&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Resource
    private UserDao userDao;

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665623044796-c4051a04-c56b-4ce9-b627-333ab7ca7b6a.png" /></p>
<p>通过测试得知，当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。</p>
<p>接下来把UserService类中的属性名修改一下</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Resource
    private UserDao userDao2;

    public void save(){
        userDao2.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665623273523-aff8ef45-b484-4462-bacc-fba7e14c8fee.png" /></p>
<p>根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入。以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。
我们再来看@Resource注解使用在setter方法上可以吗？</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    @Resource
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p>注意这个setter方法的方法名，setUserDao去掉set之后，将首字母变小写userDao，userDao就是name
执行结果：</p>
<p><img alt="image.png" src="../Spring6.assets/1665623530366-79b8e09d-2559-4657-83eb-0b722261045f.png" /></p>
<p>当然，也可以指定name：</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import com.powernode.spring6.dao.UserDao;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private UserDao userDao;

    @Resource(name = &quot;userDaoForMySQL&quot;)
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void save(){
        userDao.insert();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665623611980-a66591e7-bd29-4327-a43c-6c6492c8612f.png" /></p>
<p><strong>一句话总结@Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个</strong></p>
<h2 id="126">12.6 全注解式开发</h2>
<p>所谓的全注解开发就是不再使用spring配置文件了。写一个配置类来代替配置文件。</p>
<pre><code class="language-java">package com.powernode.spring6.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScans;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan({&quot;com.powernode.spring6.dao&quot;, &quot;com.powernode.spring6.service&quot;})
public class Spring6Configuration {
}
</code></pre>
<p>编写测试程序：不再new ClassPathXmlApplicationContext()对象了。</p>
<pre><code class="language-java">@Test
public void testNoXml(){
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Configuration.class);
    UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class);
    userService.save();
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1665624710824-61ee0ae9-ae96-49bf-b189-4a1f358e084a.png" /></p>
<h1 id="jdbctemplate">十三、JdbcTemplate</h1>
<p>JdbcTemplate是Spring提供的一个JDBC模板类，是对JDBC的封装简化JDBC代码。
当然，你也可以不用，可以让Spring集成其它的ORM框架，例如：MyBatis、Hibernate等。
接下来我们简单来学习一下，使用JdbcTemplate完成增删改查。</p>
<h2 id="131">13.1 环境准备</h2>
<p>数据库表：t_user</p>
<p><img alt="image.png" src="../Spring6.assets/1665633536319-466a1b96-90ff-4a87-82ad-fb14f32a8d12.png" /></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.powernode&lt;/groupId&gt;
    &lt;artifactId&gt;spring6-007-jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;repository.spring.milestone&lt;/id&gt;
            &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--新增的依赖:mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.30&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--新增的依赖：spring jdbc，这个依赖中有JdbcTemplate--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<p>准备实体类：表t_user对应的实体类User。</p>
<pre><code class="language-java">package com.powernode.spring6.bean;

public class User {
    private Integer id;
    private String realName;
    private Integer age;

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, realName='&quot; + realName + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }

    public User() {
    }

    public User(Integer id, String realName, Integer age) {
        this.id = id;
        this.realName = realName;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getRealName() {
        return realName;
    }

    public void setRealName(String realName) {
        this.realName = realName;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
</code></pre>
<p>编写Spring配置文件：
JdbcTemplate是Spring提供好的类，这类的完整类名是：org.springframework.jdbc.core.JdbcTemplate
我们怎么使用这个类呢？new对象就可以了。怎么new对象，Spring最在行了。直接将这个类配置到Spring配置文件中，纳入Bean管理即可。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>我们来看一下这个JdbcTemplate源码：</p>
<p><img alt="image.png" src="../Spring6.assets/1665641540149-8f44a8b1-35b6-4c8a-bd27-f08ebd911e01.png" /></p>
<p>可以看到JdbcTemplate中有一个DataSource属性，这个属性是数据源，我们都知道连接数据库需要Connection对象，而生成Connection对象是数据源负责的。所以我们需要给JdbcTemplate设置数据源属性。
所有的数据源都是要实现javax.sql.DataSource接口的。这个数据源可以自己写一个，也可以用写好的，比如：阿里巴巴的德鲁伊连接池，c3p0，dbcp等。我们这里自己先手写一个数据源。</p>
<pre><code class="language-java">package com.powernode.spring6.jdbc;

import javax.sql.DataSource;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;

public class MyDataSource implements DataSource {
    // 添加4个属性
    private String driver;
    private String url;
    private String username;
    private String password;

    // 提供4个setter方法
    public void setDriver(String driver) {
        this.driver = driver;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    // 重点写怎么获取Connection对象就行。其他方法不用管。
    @Override
    public Connection getConnection() throws SQLException {
        try {
            Class.forName(driver);
            Connection conn = DriverManager.getConnection(url, username, password);
            return conn;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public Connection getConnection(String username, String password) throws SQLException {
        return null;
    }

    @Override
    public PrintWriter getLogWriter() throws SQLException {
        return null;
    }

    @Override
    public void setLogWriter(PrintWriter out) throws SQLException {

    }

    @Override
    public void setLoginTimeout(int seconds) throws SQLException {

    }

    @Override
    public int getLoginTimeout() throws SQLException {
        return 0;
    }

    @Override
    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
        return null;
    }

    @Override
    public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException {
        return null;
    }

    @Override
    public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException {
        return false;
    }
}
</code></pre>
<p>写完数据源，我们需要把这个数据源传递给JdbcTemplate。因为JdbcTemplate中有一个DataSource属性：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.powernode.spring6.jdbc.MyDataSource&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="132">13.2 新增</h2>
<pre><code class="language-java">package com.powernode.spring6.test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;

public class JdbcTest {
    @Test
    public void testInsert(){
        // 获取JdbcTemplate对象
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
        // 执行插入操作
        // 注意：insert delete update的sql语句，都是执行update方法。
        String sql = &quot;insert into t_user(id,real_name,age) values(?,?,?)&quot;;
        int count = jdbcTemplate.update(sql, null, &quot;张三&quot;, 30);
        System.out.println(&quot;插入的记录条数：&quot; + count);
    }
}
</code></pre>
<p>update方法有两个参数：</p>
<ul>
<li>第一个参数：要执行的SQL语句。（SQL语句中可能会有占位符 ? ）</li>
<li>第二个参数：可变长参数，参数的个数可以是0个，也可以是多个。一般是SQL语句中有几个问号，则对应几个参数。</li>
</ul>
<h2 id="133">13.3 修改</h2>
<pre><code class="language-java">@Test
public void testUpdate(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 执行更新操作
    String sql = &quot;update t_user set real_name = ?, age = ? where id = ?&quot;;
    int count = jdbcTemplate.update(sql, &quot;张三丰&quot;, 55, 1);
    System.out.println(&quot;更新的记录条数：&quot; + count);
}
</code></pre>
<h2 id="134">13.4 删除</h2>
<pre><code class="language-java">@Test
public void testDelete(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 执行delete
    String sql = &quot;delete from t_user where id = ?&quot;;
    int count = jdbcTemplate.update(sql, 1);
    System.out.println(&quot;删除了几条记录：&quot; + count);
}
</code></pre>
<h2 id="135">13.5 查询一个对象</h2>
<pre><code class="language-java">@Test
public void testSelectOne(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 执行select
    String sql = &quot;select id, real_name, age from t_user where id = ?&quot;;
    User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), 2);
    System.out.println(user);
}
</code></pre>
<p>queryForObject方法三个参数：</p>
<ul>
<li>第一个参数：sql语句</li>
<li>第二个参数：Bean属性值和数据库记录行的映射对象。在构造方法中指定映射的对象类型。</li>
<li>第三个参数：可变长参数，给sql语句的占位符问号传值。</li>
</ul>
<h2 id="136">13.6 查询多个对象</h2>
<pre><code class="language-java">@Test
public void testSelectAll(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 执行select
    String sql = &quot;select id, real_name, age from t_user&quot;;
    List&lt;User&gt; users = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(User.class));
    System.out.println(users);
}
</code></pre>
<h2 id="137">13.7 查询一个值</h2>
<pre><code class="language-java">@Test
public void testSelectOneValue(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 执行select
    String sql = &quot;select count(1) from t_user&quot;;
    Integer count = jdbcTemplate.queryForObject(sql, int.class); // 这里用Integer.class也可以
    System.out.println(&quot;总记录条数：&quot; + count);
}
</code></pre>
<h2 id="138">13.8 批量添加</h2>
<pre><code class="language-java">@Test
public void testAddBatch(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 批量添加
    String sql = &quot;insert into t_user(id,real_name,age) values(?,?,?)&quot;;

    Object[] objs1 = {null, &quot;小花&quot;, 20};
    Object[] objs2 = {null, &quot;小明&quot;, 21};
    Object[] objs3 = {null, &quot;小刚&quot;, 22};
    List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
    list.add(objs1);
    list.add(objs2);
    list.add(objs3);

    int[] count = jdbcTemplate.batchUpdate(sql, list);
    System.out.println(Arrays.toString(count));
}
</code></pre>
<h2 id="139">13.9 批量修改</h2>
<pre><code class="language-java">@Test
public void testUpdateBatch(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 批量修改
    String sql = &quot;update t_user set real_name = ?, age = ? where id = ?&quot;;
    Object[] objs1 = {&quot;小花11&quot;, 10, 2};
    Object[] objs2 = {&quot;小明22&quot;, 12, 3};
    Object[] objs3 = {&quot;小刚33&quot;, 9, 4};
    List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
    list.add(objs1);
    list.add(objs2);
    list.add(objs3);

    int[] count = jdbcTemplate.batchUpdate(sql, list);
    System.out.println(Arrays.toString(count));
}
</code></pre>
<h2 id="1310">13.10 批量删除</h2>
<pre><code class="language-java">@Test
public void testDeleteBatch(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    // 批量删除
    String sql = &quot;delete from t_user where id = ?&quot;;
    Object[] objs1 = {2};
    Object[] objs2 = {3};
    Object[] objs3 = {4};
    List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
    list.add(objs1);
    list.add(objs2);
    list.add(objs3);
    int[] count = jdbcTemplate.batchUpdate(sql, list);
    System.out.println(Arrays.toString(count));
}
</code></pre>
<h2 id="1311">13.11 使用回调函数</h2>
<pre><code class="language-java">@Test
public void testCallback(){
    // 获取JdbcTemplate对象
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    JdbcTemplate jdbcTemplate = applicationContext.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);
    String sql = &quot;select id, real_name, age from t_user where id = ?&quot;;

    User user = jdbcTemplate.execute(sql, new PreparedStatementCallback&lt;User&gt;() {
        @Override
        public User doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException {
            User user = null;
            ps.setInt(1, 5);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                user = new User();
                user.setId(rs.getInt(&quot;id&quot;));
                user.setRealName(rs.getString(&quot;real_name&quot;));
                user.setAge(rs.getInt(&quot;age&quot;));
            }
            return user;
        }
    });
    System.out.println(user);
}
</code></pre>
<h2 id="1312">13.12 使用德鲁伊连接池</h2>
<p>之前数据源是用我们自己写的。也可以使用别人写好的。例如比较牛的德鲁伊连接池。</p>
<ol>
<li>引入德鲁伊连接池的依赖。</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;druid&lt;/artifactId&gt;
  &lt;version&gt;1.1.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li>将德鲁伊中的数据源配置到spring配置文件中。和配置我们自己写的一样。</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="gof_1">十四、GoF之代理模式</h1>
<h2 id="141">14.1 对代理模式的理解</h2>
<p><strong>生活场景1</strong>：牛村的牛二看上了隔壁村小花，牛二不好意思直接找小花，于是牛二找来了媒婆王妈妈。这里面就有一个非常典型的代理模式。牛二不能和小花直接对接，只能找一个中间人。其中王妈妈是代理类，牛二是目标类。王妈妈代替牛二和小花先见个面。（现实生活中的婚介所）【在程序中，对象A和对象B无法直接交互时。】</p>
<p><strong>生活场景2</strong>：你刚到北京，要租房子，可以自己找，也可以找链家帮你找。其中链家是代理类，你是目标类。你们两个都有共同的行为：找房子。不过链家除了满足你找房子，另外会收取一些费用的。(现实生活中的房产中介)【在程序中，功能需要增强时。】
西游记场景：八戒和高小姐的故事。八戒要强抢民女高翠兰。悟空得知此事之后怎么做的？悟空幻化成高小姐的模样。代替高小姐与八戒会面。其中八戒是客户端程序。悟空是代理类。高小姐是目标类。那天夜里，在八戒眼里，眼前的就是高小姐，对于八戒来说，他是不知道眼前的高小姐是悟空幻化的，在他内心里这就是高小姐。所以悟空代替高小姐和八戒亲了嘴儿。这是非常典型的代理模式实现的保护机制。<strong>代理模式中有一个非常重要的特点：对于客户端程序来说，使用代理对象时就像在使用目标对象一样</strong>。【在程序中，目标需要被保护时】</p>
<p><strong>业务场景</strong>：系统中有A、B、C三个模块，使用这些模块的前提是需要用户登录，也就是说在A模块中要编写判断登录的代码，B模块中也要编写，C模块中还要编写，这些判断登录的代码反复出现，显然代码没有得到复用，可以为A、B、C三个模块提供一个代理，在代理当中写一次登录判断即可。代理的逻辑是：请求来了之后，判断用户是否登录了，如果已经登录了，则执行对应的目标，如果没有登录则跳转到登录页面。【在程序中，目标不但受到保护，并且代码也得到了复用。】</p>
<p>代理模式是GoF23种设计模式之一。属于结构型设计模式。</p>
<p>代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不应该看到的内容和服务或者添加客户需要的额外服务。 通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p>
<p>代理模式中的角色：</p>
<ul>
<li>代理类（代理主题）</li>
<li>目标类（真实主题）</li>
<li>代理类和目标类的公共接口（抽象主题）：客户端在使用代理类时就像在使用目标类，不被客户端所察觉所以代理类和目标类要有共同的行为，也就是实现共同的接口</li>
</ul>
<p>代理模式的类图：</p>
<p><img alt="image.png" src="../Spring6.assets/1665651817094-af9ecbad-24ae-4c11-9fa2-efe46653df25.png" /></p>
<p>代理模式在代码实现上，包括两种形式：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h2 id="142">14.2 静态代理</h2>
<pre><code class="language-java">package com.powernode.mall.service;

public interface OrderService {
    /**
     * 生成订单
     */
    void generate();

    /**
     * 查看订单详情
     */
    void detail();

    /**
     * 修改订单
     */
    void modify();
}
</code></pre>
<pre><code class="language-java">package com.powernode.mall.service.impl;

import com.powernode.mall.service.OrderService;

public class OrderServiceImpl implements OrderService {
    @Override
    public void generate() {
        try {
            Thread.sleep(1234);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单已生成&quot;);
    }

    @Override
    public void detail() {
        try {
            Thread.sleep(2541);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单信息如下：******&quot;);
    }

    @Override
    public void modify() {
        try {
            Thread.sleep(1010);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单已修改&quot;);
    }
}
</code></pre>
<p>其中Thread.sleep()方法的调用是为了模拟操作耗时。</p>
<p>项目已上线，并且运行正常，只是客户反馈系统有一些地方运行较慢，要求项目组对系统进行优化。于是项目负责人就下达了这个需求。首先需要搞清楚是哪些业务方法耗时较长，于是让我们统计每个业务方法所耗费的时长。如果是你，你该怎么做呢？</p>
<p>第一种方案：直接修改Java源代码，在每个业务方法中添加统计逻辑，如下：</p>
<pre><code class="language-java">package com.powernode.mall.service.impl;

import com.powernode.mall.service.OrderService;

public class OrderServiceImpl implements OrderService {
    @Override
    public void generate() {
        long begin = System.currentTimeMillis();
        try {
            Thread.sleep(1234);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单已生成&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗费时长&quot;+(end - begin)+&quot;毫秒&quot;);
    }

    @Override
    public void detail() {
        long begin = System.currentTimeMillis();
        try {
            Thread.sleep(2541);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单信息如下：******&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗费时长&quot;+(end - begin)+&quot;毫秒&quot;);
    }

    @Override
    public void modify() {
        long begin = System.currentTimeMillis();
        try {
            Thread.sleep(1010);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单已修改&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗费时长&quot;+(end - begin)+&quot;毫秒&quot;);
    }
}
</code></pre>
<p>需求可以满足，但显然是违背了OCP开闭原则。这种方案不可取。</p>
<p>第二种方案：编写一个子类继承OrderServiceImpl，在子类中重写每个方法，代码如下：</p>
<pre><code class="language-java">package com.powernode.mall.service.impl;

public class OrderServiceImplSub extends OrderServiceImpl{
    @Override
    public void generate() {
        long begin = System.currentTimeMillis();
        super.generate();
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot;+(end - begin)+&quot;毫秒&quot;);
    }

    @Override
    public void detail() {
        long begin = System.currentTimeMillis();
        super.detail();
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot;+(end - begin)+&quot;毫秒&quot;);
    }

    @Override
    public void modify() {
        long begin = System.currentTimeMillis();
        super.modify();
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot;+(end - begin)+&quot;毫秒&quot;);
    }
}
</code></pre>
<p>这种方式可以解决，但是存在两个问题：</p>
<ul>
<li>第一个问题：假设系统中有100个这样的业务类，需要提供100个子类，并且之前写好的创建Service对象的代码，都要修改为创建子类对象。</li>
<li>第二个问题：由于采用了继承的方式，导致代码之间的耦合度较高。</li>
</ul>
<p>这种方案也不可取。</p>
<p>第三种方案：使用代理模式（这里采用静态代理）</p>
<p>可以为OrderService接口提供一个代理类。</p>
<pre><code class="language-java">package com.powernode.mall.service;

public class OrderServiceProxy implements OrderService{ // 代理对象

    // 目标对象
    private OrderService orderService;

    // 通过构造方法将目标对象传递给代理对象
    public OrderServiceProxy(OrderService orderService) {
        this.orderService = orderService;
    }

    @Override
    public void generate() {
        long begin = System.currentTimeMillis();
        // 执行目标对象的目标方法
        orderService.generate();
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot;+(end - begin)+&quot;毫秒&quot;);
    }

    @Override
    public void detail() {
        long begin = System.currentTimeMillis();
        // 执行目标对象的目标方法
        orderService.detail();
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot;+(end - begin)+&quot;毫秒&quot;);
    }

    @Override
    public void modify() {
        long begin = System.currentTimeMillis();
        // 执行目标对象的目标方法
        orderService.modify();
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot;+(end - begin)+&quot;毫秒&quot;);
    }
}
</code></pre>
<p>这种方式的优点：符合OCP开闭原则，同时采用的是关联关系，所以程序的耦合度较低。所以这种方案是被推荐的。</p>
<p>编写客户端程序：</p>
<pre><code class="language-java">package com.powernode.mall;

import com.powernode.mall.service.OrderService;
import com.powernode.mall.service.OrderServiceProxy;
import com.powernode.mall.service.impl.OrderServiceImpl;

public class Client {
    public static void main(String[] args) {
        // 创建目标对象
        OrderService target = new OrderServiceImpl();
        // 创建代理对象
        OrderService proxy = new OrderServiceProxy(target);
        // 调用代理对象的代理方法
        proxy.generate();
        proxy.modify();
        proxy.detail();
    }
}
</code></pre>
<p>以上就是代理模式中的静态代理，其中OrderService接口是代理类和目标类的共同接口，OrderServiceImpl是目标类OrderServiceProxy是代理类。</p>
<p>大家思考一下：如果系统中业务接口很多，一个接口对应一个代理类，显然也是不合理的，会导致类爆炸。怎么解决这个问题？动态代理可以解决。因为在动态代理中可以在内存中动态的为我们生成代理类的字节码。代理类不需要我们写了。类爆炸解决了，而且代码只需要写一次，代码也会得到复用。</p>
<h2 id="143">14.3 动态代理</h2>
<p>在程序运行阶段，在内存中动态生成代理类，被称为动态代理，目的是为了减少代理类的数量，解决代码复用的问题</p>
<p>在内存当中动态生成类的技术常见的包括：</p>
<ul>
<li>JDK动态代理技术：只能代理接口</li>
<li>CGLIB动态代理技术：CGLIB是一个开源项目，是一个强大的，高性能，高质量的Code生成类库，它可以运行期扩展Java类与实现Java接口。它既可以代理接口，又可以代理类，<strong>底层是通过继承的方式实现的</strong>。性能比JDK动态代理好。<strong>（底层有一个小而快的字节码处理框架ASM。）</strong></li>
<li>Javassist动态代理技术：Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态"AOP"框架。</li>
</ul>
<h3 id="1431-jdk">14.3.1 JDK动态代理</h3>
<pre><code class="language-java">package com.powernode.mall.service;

public interface OrderService {
    /**
     * 生成订单
     */
    void generate();

    /**
     * 查看订单详情
     */
    void detail();

    /**
     * 修改订单
     */
    void modify();
}
</code></pre>
<pre><code class="language-java">package com.powernode.mall.service.impl;

import com.powernode.mall.service.OrderService;

public class OrderServiceImpl implements OrderService {
    @Override
    public void generate() {
        try {
            Thread.sleep(1234);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单已生成&quot;);
    }

    @Override
    public void detail() {
        try {
            Thread.sleep(2541);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单信息如下：******&quot;);
    }

    @Override
    public void modify() {
        try {
            Thread.sleep(1010);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;订单已修改&quot;);
    }
}
</code></pre>
<p>我们在静态代理的时候，除了以上一个接口和一个实现类之外，是不是要写一个代理类UserServiceProxy呀！在动态代理中UserServiceProxy代理类是可以动态生成的。这个类不需要写。我们直接写客户端程序即可：</p>
<pre><code class="language-java">package com.powernode.mall;

import com.powernode.mall.service.OrderService;
import com.powernode.mall.service.impl.OrderServiceImpl;

import java.lang.reflect.Proxy;

public class Client {
    public static void main(String[] args) {
        // 第一步：创建目标对象
        OrderService target = new OrderServiceImpl();
        // 第二步：创建代理对象
        OrderService orderServiceProxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), 调用处理器对象);
        // 第三步：调用代理对象的代理方法
        orderServiceProxy.detail();
        orderServiceProxy.modify();
        orderServiceProxy.generate();
    }
}
</code></pre>
<p>以上第二步创建代理对象是需要大家理解的：
OrderService orderServiceProxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), 调用处理器对象);</p>
<p>这行代码做了两件事：</p>
<ul>
<li>第一件事：在内存中生成了代理类的字节码</li>
<li>第二件事：创建代理对象</li>
</ul>
<p>Proxy类全名：java.lang.reflect.Proxy。这是JDK提供的一个类（所以称为JDK动态代理）。主要是通过这个类在内存中生成代理类的字节码。
其中newProxyInstance()方法有三个参数：</p>
<ul>
<li>第一个参数：类加载器。在内存中生成了字节码，要想执行这个字节码，也是需要先把这个字节码加载到内存当中的。所以要指定使用哪个类加载器加载。</li>
<li>第二个参数：接口类型。代理类和目标类实现相同的接口，所以要通过这个参数告诉JDK动态代理生成的类要实现哪些接口。</li>
<li>第三个参数：调用处理器。这是一个JDK动态代理规定的接口，接口全名：java.lang.reflect.InvocationHandler。显然这是一个回调接口，也就是说调用这个接口中方法的程序已经写好了，就差这个接口的实现类了。</li>
</ul>
<p>所以接下来我们要写一下java.lang.reflect.InvocationHandler接口的实现类，并且实现接口中的方法，代码如下：</p>
<pre><code class="language-java">package com.powernode.mall.service;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TimerInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return null;
    }
}
</code></pre>
<p>InvocationHandler接口中有一个方法invoke，这个invoke方法上有三个参数：</p>
<ul>
<li>第一个参数：Object proxy。代理对象。设计这个参数只是为了后期的方便，如果想在invoke方法中使用代理对象的话，尽管通过这个参数来使用。</li>
<li>第二个参数：Method method。目标方法。</li>
<li>第三个参数：Object[] args。目标方法调用时要传的参数。</li>
</ul>
<p>我们将来肯定是要调用“目标方法”的，但要调用目标方法的话，需要“目标对象”的存在，“目标对象”从哪儿来呢？我们可以给TimerInvocationHandler提供一个构造方法，可以通过这个构造方法传过来“目标对象”，代码如下：</p>
<pre><code class="language-java">package com.powernode.mall.service;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TimerInvocationHandler implements InvocationHandler {
    // 目标对象
    private Object target;

    // 通过构造方法来传目标对象
    public TimerInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return null;
    }
}
</code></pre>
<p>有了目标对象我们就可以在invoke()方法中调用目标方法了。代码如下：</p>
<pre><code class="language-java">package com.powernode.mall.service;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TimerInvocationHandler implements InvocationHandler {
    // 目标对象
    private Object target;

    // 通过构造方法来传目标对象
    public TimerInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 目标执行之前增强。
        long begin = System.currentTimeMillis();
        // 调用目标对象的目标方法
        Object retValue = method.invoke(target, args);
        // 目标执行之后增强。
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot;+(end - begin)+&quot;毫秒&quot;);
        // 一定要记得返回哦。
        return retValue;
    }
}
</code></pre>
<p>到此为止，调用处理器就完成了。接下来，应该继续完善Client程序：</p>
<pre><code class="language-java">package com.powernode.mall;

import com.powernode.mall.service.OrderService;
import com.powernode.mall.service.TimerInvocationHandler;
import com.powernode.mall.service.impl.OrderServiceImpl;

import java.lang.reflect.Proxy;

public class Client {
    public static void main(String[] args) {
        // 创建目标对象
        OrderService target = new OrderServiceImpl();
        // 创建代理对象
        OrderService orderServiceProxy = (OrderService) Proxy.newProxyInstance(target.getClass().getClassLoader(),
                                                                                target.getClass().getInterfaces(),
                                                                                new TimerInvocationHandler(target));
        // 调用代理对象的代理方法
        orderServiceProxy.detail();
        orderServiceProxy.modify();
        orderServiceProxy.generate();
    }
}
</code></pre>
<p>大家可能会比较好奇：那个InvocationHandler接口中的invoke()方法没看见在哪里调用呀？
注意：当你调用代理对象的代理方法的时候，注册在InvocationHandler接口中的invoke()方法会被调用。也就是上面代码第18 19 20行，这三行代码中任意一行代码执行，注册在InvocationHandler接口中的invoke()方法都会被调用。</p>
<p>学到这里可能会感觉有点懵，折腾半天，到最后这不是还得写一个接口的实现类吗？没省劲儿呀？</p>
<p>你要这样想就错了!!!!</p>
<p>我们可以看到，不管你有多少个Service接口，多少个业务类，这个TimerInvocationHandler接口是不是只需要写一次就行了，代码是不是得到复用了！！！！</p>
<p>而且最重要的是，以后程序员只需要关注核心业务的编写了，像这种统计时间的代码根本不需要关注。因为这种统计时间的代码只需要在调用处理器中编写一次即可。</p>
<p>到这里，JDK动态代理的原理就结束了。</p>
<p>不过我们看以下这个代码确实有点繁琐，对于客户端来说，用起来不方便：</p>
<p><img alt="image.png" src="../Spring6.assets/1665716434406-4e092df4-b1a7-4d16-bbc1-1f134b8f51f7.png" /></p>
<p>我们可以提供一个工具类：ProxyUtil，封装一个方法：</p>
<pre><code class="language-java">package com.powernode.mall.util;

import com.powernode.mall.service.TimerInvocationHandler;

import java.lang.reflect.Proxy;

public class ProxyUtil {
    public static Object newProxyInstance(Object target) {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                new TimerInvocationHandler(target));
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.mall;

import com.powernode.mall.service.OrderService;
import com.powernode.mall.service.TimerInvocationHandler;
import com.powernode.mall.service.impl.OrderServiceImpl;
import com.powernode.mall.util.ProxyUtil;

import java.lang.reflect.Proxy;

public class Client {
    public static void main(String[] args) {
        // 创建目标对象
        OrderService target = new OrderServiceImpl();
        // 创建代理对象
        OrderService orderServiceProxy = (OrderService) ProxyUtil.newProxyInstance(target);
        // 调用代理对象的代理方法
        orderServiceProxy.detail();
        orderServiceProxy.modify();
        orderServiceProxy.generate();
    }
}
</code></pre>
<h3 id="1432-cglib">14.3.2 CGLIB动态代理</h3>
<p>CGLIB既可以代理接口，又可以代理类。底层采用继承的方式实现。所以被代理的目标类不能使用final修饰。</p>
<p>使用CGLIB，需要引入它的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;cglib&lt;/groupId&gt;
  &lt;artifactId&gt;cglib&lt;/artifactId&gt;
  &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.mall.service;

public class UserService {

    public void login(){
        System.out.println(&quot;用户正在登录系统....&quot;);
    }

    public void logout(){
        System.out.println(&quot;用户正在退出系统....&quot;);
    }
}
</code></pre>
<p>使用CGLIB在内存中为UserService类生成代理类，并创建对象</p>
<pre><code class="language-java">package com.powernode.mall;

import com.powernode.mall.service.UserService;
import net.sf.cglib.proxy.Enhancer;

/**
 * @author 动力节点
 * @version 1.0
 * @className Client
 * @since 1.0
 **/
public class Client {
    public static void main(String[] args) {
        // 创建字节码增强器
        Enhancer enhancer = new Enhancer();
        // 告诉cglib要继承哪个类
        enhancer.setSuperclass(UserService.class);
        // 设置回调接口
        enhancer.setCallback(方法拦截器对象);
        // 生成源码，编译class，加载到JVM，并创建代理对象
        UserService userServiceProxy = (UserService)enhancer.create();

        userServiceProxy.login();
        userServiceProxy.logout();

    }
}
</code></pre>
<p>和JDK动态代理原理差不多，在CGLIB中需要提供的不是InvocationHandler，而是：net.sf.cglib.proxy.MethodInterceptor
编写MethodInterceptor接口实现类：</p>
<pre><code class="language-java">package com.powernode.mall.service;

import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class TimerMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object target, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        return null;
    }
}
</code></pre>
<p>MethodInterceptor接口中有一个方法intercept()，该方法有4个参数：</p>
<p>第一个参数：目标对象</p>
<p>第二个参数：目标方法</p>
<p>第三个参数：目标方法调用时的实参</p>
<p>第四个参数：代理方法</p>
<p>在MethodInterceptor的intercept()方法中调用目标以及添加增强：</p>
<pre><code class="language-java">package com.powernode.mall.service;

import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class TimerMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object target, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        // 前增强
        long begin = System.currentTimeMillis();
        // 调用目标
        Object retValue = methodProxy.invokeSuper(target, objects);
        // 后增强
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时&quot; + (end - begin) + &quot;毫秒&quot;);
        // 一定要返回
        return retValue;
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.mall;

import com.powernode.mall.service.TimerMethodInterceptor;
import com.powernode.mall.service.UserService;
import net.sf.cglib.proxy.Enhancer;

public class Client {
    public static void main(String[] args) {
        // 创建字节码增强器
        Enhancer enhancer = new Enhancer();
        // 告诉cglib要继承哪个类
        enhancer.setSuperclass(UserService.class);
        // 设置回调接口
        enhancer.setCallback(new TimerMethodInterceptor());
        // 生成源码，编译class，加载到JVM，并创建代理对象
        UserService userServiceProxy = (UserService)enhancer.create();

        userServiceProxy.login();
        userServiceProxy.logout();

    }
}
</code></pre>
<p>对于高版本的JDK，如果使用CGLIB，需要在启动项中添加两个启动参数：</p>
<p><img alt="image.png" src="../Spring6.assets/1665719287350-761d69a9-2666-40b3-9332-91d695f1eb86.png" /></p>
<ul>
<li>--add-opens java.base/java.lang=ALL-UNNAMED</li>
<li>--add-opens java.base/sun.net.util=ALL-UNNAMED</li>
</ul>
<h1 id="aop">十五、面向切面编程AOP</h1>
<p>IoC使软件组件松耦合。AOP让你能够捕捉系统中经常使用的功能，把它转化成主键</p>
<p>AOP（Aspect Oriented Programming）：面向切面编程，面向方便编程。（AOP是一种编程技术）</p>
<p>AOP是对OOP的补充延伸</p>
<p>AOP底层使用的就是动态代理来实现的</p>
<p>Spring的AOP使用的动态代理是：JDK动态代理+CGLIB动态代理技术。Spring在这两种动态代理中灵活切换，如果是代理接口，会默认使用JDK动态代理，如果要代理某个类，这个类没有实现接口，就回切换使用CGLIB。当然，你也可以强制通过一些配置让Spring只是用CGLIB</p>
<h2 id="151-aop">15.1 AOP介绍</h2>
<p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：<strong>交叉业务</strong></p>
<p>这些<strong>交叉服务</strong>几乎是通用的，不管你是做银行账户转账，还是删除用户数据。日志、事务管理、安全这些都是需要做的</p>
<p>如果在每一个业务处理过程当中，都掺杂这些交叉业务代码进去的话，存在两方面的问题：</p>
<ol>
<li>交叉业务代码在多个业务流程中反复出现，显然这个交叉业务代码没有得到复用。并且修改这些交叉业务代码的话，需要修改多处</li>
<li>程序员无法专注核心业务代码的编写，在编写核心业务代码的同时还需要处理这些交叉业务</li>
</ol>
<p>使用AOP可以很轻松的解决以上问题</p>
<p>请看下图，可以帮助你快速理解AOP的思想：</p>
<p><img alt="image.png" src="../Spring6.assets/1665732609757-d8ae52ba-915e-49cf-9ef4-c7bcada0d601.png" /></p>
<p>用一句话总结AOP：将于核心业务无关的代码独立的抽取出阿里，形成一个独立的组件，然后以横向交叉的方式应用到业务流程当中的过程被称为AOP</p>
<p>AOP的优点：</p>
<ol>
<li>代码复用性增强</li>
<li>代码易维护</li>
<li>使开发者更关注业务逻辑</li>
</ol>
<h2 id="152-aop">15.2 AOP的七大术语</h2>
<pre><code class="language-java">public class UserService{
    public void do1(){
        System.out.println(&quot;do 1&quot;);
    }
    public void do2(){
        System.out.println(&quot;do 2&quot;);
    }
    public void do3(){
        System.out.println(&quot;do 3&quot;);
    }
    public void do4(){
        System.out.println(&quot;do 4&quot;);
    }
    public void do5(){
        System.out.println(&quot;do 5&quot;);
    }
    // 核心业务方法
    public void service(){
        do1();
        do2();
        do3();
        do5();
    }
}
</code></pre>
<ul>
<li><strong>连接点 Joinpoint</strong></li>
<li>
<p>在程序的整个执行流程中，<strong>可以织入</strong>切面的位置，方法的执行前后，异常抛出之后等位置</p>
</li>
<li>
<p><strong>切点 Pointcut</strong></p>
</li>
<li>
<p>在程序执行和流程中，<strong>真正织入</strong>切面的方法（一个切点对应多个连接点）</p>
</li>
<li>
<p><strong>通知 Advice</strong></p>
</li>
<li>通知又叫增强，就是具体你要哦织入的代码</li>
<li>通知包括：<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>环绕通知</li>
<li>异常通知</li>
<li>最终通知</li>
</ul>
</li>
<li><strong>切面 Aspect</strong></li>
<li>
<p><strong>切点 + 通知就是切面</strong></p>
</li>
<li>
<p>织入 Weaving</p>
</li>
<li>把通知应用到目标对象上的过程</li>
<li>代理对象 Proxy</li>
<li>一个目标对象被织入通知后产生的新对象</li>
<li>目标对象 Target</li>
<li>被织入通知的对象</li>
</ul>
<p>通过下图，大家可以很好的理解AOP的相关术语：</p>
<p><img alt="image.png" src="../Spring6.assets/1665735638342-44194599-66e2-4c02-a843-8a8b3ba5b0c8.png" /></p>
<h2 id="153">15.3 切点表达式</h2>
<p>切点表达式用来定义通知（Advice）往哪些方法上切入</p>
<p>切入点表达式语法格式</p>
<pre><code class="language-java">execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])
</code></pre>
<p>访问控制权限修饰符：</p>
<ul>
<li>可选项</li>
<li>没写，就是4个权限都包括</li>
<li>写public就表示只包括公开的方法</li>
</ul>
<p>返回值类型：</p>
<ul>
<li>必填项</li>
<li>*表示返回值类型任意</li>
</ul>
<p>全限定类名：</p>
<ul>
<li>可选项</li>
<li>两个点“..”代表当前包以及子包下的所有类</li>
<li>省略时表示所有的类</li>
</ul>
<p>方法名：</p>
<ul>
<li>必填项</li>
<li>*表示所有方法</li>
<li>set*表示所有的set方法</li>
</ul>
<p>形式参数列表：</p>
<ul>
<li>必填项</li>
<li>（）表示没有参数的方法</li>
<li>（..）参数类型和个数随意的方法</li>
<li>（*）只有一个参数的方法</li>
<li>（*， String）第一个参数类型随意，第二个参数是String的</li>
</ul>
<p>异常：</p>
<ul>
<li>可选项</li>
<li>省略时表示任意异常类型</li>
</ul>
<p>理解以下的切点表达式：</p>
<p>service包下所有的类中以delete开始的所有方法</p>
<pre><code class="language-java">execution(public * com.powernode.mall.service.*.delete*(..))
</code></pre>
<p>mall包下所有的类的所有的方法</p>
<pre><code class="language-java">execution(* com.powernode.mall..*(..))
</code></pre>
<p>所有类的所有方法</p>
<pre><code class="language-java">execution(* *(..))
</code></pre>
<h2 id="154-springaop">15.4 使用Spring的AOP</h2>
<p>Spring对AOP的实现包括一下3中方式：</p>
<ol>
<li><strong>Spring 框架结课AspectJ框架实现AOP，基于注解方式</strong></li>
<li><strong>Spring框架结合AspectJ框架实现AOP，基于XML方式</strong></li>
<li>Spring框架自己实现的AOP，基于XML配置方式</li>
</ol>
<p>实际开发中，都是Spring+AspectJ来实现AOP</p>
<p>什么是AspectJ？（Eclipse组织的一个支持AOP的框架。AspectJ框架是独立于Spring框架之外的一个框架，Spring框架用了AspectJ） </p>
<p>AspectJ项目起源于帕洛阿尔托（Palo Alto）研究中心（缩写为PARC）。该中心由Xerox集团资助，Gregor Kiczales领导，从1997年开始致力于AspectJ的开发，1998年第一次发布给外部用户，2001年发布1.0 release。为了推动AspectJ技术和社团的发展，PARC在2003年3月正式将AspectJ项目移交给了Eclipse组织，因为AspectJ的发展和受关注程度大大超出了PARC的预期，他们已经无力继续维持它的发展。</p>
<h3 id="1541">15.4.1 准备工作</h3>
<p>使用Spring+AspectJ的AOP需要引入的依赖如下：</p>
<pre><code class="language-xml">&lt;!--spring context依赖--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
  &lt;version&gt;6.0.0-M2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--spring aop依赖--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
  &lt;version&gt;6.0.0-M2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--spring aspects依赖--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
  &lt;version&gt;6.0.0-M2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Spring配置文件中添加context命名空间和aop命名空间</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="1542-aspectjaop">15.4.2 基于AspectJ的AOP注解式开发</h3>
<ol>
<li>定义目标类以及目标方法</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.service;

// 目标类
public class OrderService {
    // 目标方法
    public void generate(){
        System.out.println(&quot;订单已生成！&quot;);
    }
}
</code></pre>
<ol>
<li>定义切面类</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.aspectj.lang.annotation.Aspect;

// 切面类
@Aspect
public class MyAspect {
}
</code></pre>
<ol>
<li>目标类和切面类都纳入spring bean管理</li>
</ol>
<p>​    在目标类OrderService上添加@Component注解。
   ​    在切面类MyAspect类上添加@Component注解。</p>
<ol>
<li>在spring配置文件中添加组建扫描</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!--开启组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6.service&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<ol>
<li>在切面类中添加通知</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.springframework.stereotype.Component;
import org.aspectj.lang.annotation.Aspect;

// 切面类
@Aspect
@Component
public class MyAspect {
    // 这就是需要增强的代码（通知）
    public void advice(){
        System.out.println(&quot;我是一个通知&quot;);
    }
}
</code></pre>
<ol>
<li>在通知上添加切点表达式（通知+切点=切面）</li>
</ol>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;
import org.aspectj.lang.annotation.Aspect;

// 切面类
@Aspect
@Component
public class MyAspect {

    // 切点表达式
    @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    // 这就是需要增强的代码（通知）
    public void advice(){
        System.out.println(&quot;我是一个通知&quot;);
    }
}
</code></pre>
<p><strong>注解@Before表示前置通知。</strong></p>
<ol>
<li>在spring配置文件中启用自动代理</li>
</ol>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!--开启组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6.service&quot;/&gt;
    &lt;!--开启自动代理--&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong><aop:aspectj-autoproxy  proxy-target-class="true"/> 开启自动代理之后，凡是带有@Aspect注解的bean都会生成代理对象</strong></p>
<p><strong>proxy-target-class="true" 表示采用cglib动态代理。</strong></p>
<p><strong>proxy-target-class="false" 表示采用jdk动态代理。默认值是false。即使写成false，当没有接口的时候，也会自动选择cglib生成代理类。</strong></p>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.service.OrderService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AOPTest {
    @Test
    public void testAOP(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-aspectj-aop-annotation.xml&quot;);
        OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class);
        orderService.generate();
    }
}
</code></pre>
<p><strong>通知类型</strong></p>
<p>通知类型包括：</p>
<ul>
<li>前置通知：@Before 目标方法执行之前通知</li>
<li>后置通知：@AfterReturning 目标方法执行之后的通知</li>
<li>环绕通知：@Around 目标方法之前添加通知，同时目标方法执行之后添加通知</li>
<li>异常通知：@AfterThrowing 发生异常之后执行的通知</li>
<li>最终通知：@After 放在finally语句块中的通知</li>
</ul>
<p>接下来，编写程序来测试这几个通知的执行顺序：</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

// 切面类
@Component
@Aspect
public class MyAspect {

    @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println(&quot;环绕通知开始&quot;);
        // 执行目标方法。
        proceedingJoinPoint.proceed();
        System.out.println(&quot;环绕通知结束&quot;);
    }

    @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;前置通知&quot;);
    }

    @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterReturningAdvice(){
        System.out.println(&quot;后置通知&quot;);
    }

    @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterThrowingAdvice(){
        System.out.println(&quot;异常通知&quot;);
    }

    @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterAdvice(){
        System.out.println(&quot;最终通知&quot;);
    }

}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.springframework.stereotype.Component;

// 目标类
@Component
public class OrderService {
    // 目标方法
    public void generate(){
        System.out.println(&quot;订单已生成！&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.service.OrderService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AOPTest {
    @Test
    public void testAOP(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-aspectj-aop-annotation.xml&quot;);
        OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class);
        orderService.generate();
    }
}
</code></pre>
<p><img alt="5F9597E7-7930-4384-95C2-CF64C9DDA9F3.png" src="../Spring6.assets/1665892617792-22cc74a2-6876-4cd1-bb17-87d3b5211cae.png" /></p>
<p>通过上面的执行结果就可以判断他们的执行顺序了，这里不再赘述。
结果中没有异常通知，这是因为目标程序执行过程中没有发生异常。我们尝试让目标方法发生异常：</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.springframework.stereotype.Component;

// 目标类
@Component
public class OrderService {
    // 目标方法
    public void generate(){
        System.out.println(&quot;订单已生成！&quot;);
        if (1 == 1) {
            throw new RuntimeException(&quot;模拟异常发生&quot;);
        }
    }
}
</code></pre>
<p><img alt="5F9597E7-7930-4384-95C2-CF64C9DDA9F3.png" src="../Spring6.assets/1665892847715-75045cd0-63b1-47f9-a77e-05911dc72339.png" /></p>
<p>通过测试得知，当发生异常之后，最终通知也会执行，因为最终通知@After会出现在finally语句块中。
出现异常之后，<strong>后置通知</strong>和环<strong>绕通知的结束部分</strong>不会执行。</p>
<p><strong>切面的先后顺序</strong></p>
<p>我们知道，业务流程当中不一定只有一个切面，可以有的切面控制事务，有的记录日志，有的进行安全控制，如果多个切面的话，顺序如何控制：<strong>可以使用@Order注解来标识切面类，为@Order注解的value指定一个整数型的数字，数字越小，优先级越高</strong></p>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Aspect
@Component
@Order(1) //设置优先级
public class YourAspect {

    @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println(&quot;YourAspect环绕通知开始&quot;);
        // 执行目标方法。
        proceedingJoinPoint.proceed();
        System.out.println(&quot;YourAspect环绕通知结束&quot;);
    }

    @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;YourAspect前置通知&quot;);
    }

    @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterReturningAdvice(){
        System.out.println(&quot;YourAspect后置通知&quot;);
    }

    @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterThrowingAdvice(){
        System.out.println(&quot;YourAspect异常通知&quot;);
    }

    @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterAdvice(){
        System.out.println(&quot;YourAspect最终通知&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

// 切面类
@Component
@Aspect
@Order(2) //设置优先级
public class MyAspect {

    @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println(&quot;环绕通知开始&quot;);
        // 执行目标方法。
        proceedingJoinPoint.proceed();
        System.out.println(&quot;环绕通知结束&quot;);
    }

    @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;前置通知&quot;);
    }

    @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterReturningAdvice(){
        System.out.println(&quot;后置通知&quot;);
    }

    @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterThrowingAdvice(){
        System.out.println(&quot;异常通知&quot;);
    }

    @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterAdvice(){
        System.out.println(&quot;最终通知&quot;);
    }

}
</code></pre>
<p><strong>优化使用切点表达式</strong></p>
<p>观看以下代码中的切点表达式：</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

// 切面类
@Component
@Aspect
@Order(2)
public class MyAspect {

    @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println(&quot;环绕通知开始&quot;);
        // 执行目标方法。
        proceedingJoinPoint.proceed();
        System.out.println(&quot;环绕通知结束&quot;);
    }

    @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;前置通知&quot;);
    }

    @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterReturningAdvice(){
        System.out.println(&quot;后置通知&quot;);
    }

    @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterThrowingAdvice(){
        System.out.println(&quot;异常通知&quot;);
    }

    @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void afterAdvice(){
        System.out.println(&quot;最终通知&quot;);
    }

}
</code></pre>
<p>缺点是：</p>
<ol>
<li>切点表达式重复写了多次，没有得到复用</li>
<li>如果要修改切点表达式，需要修改多处，难维护</li>
</ol>
<p>可以这样做：将切点表达式单独的定义出来，在需要的位置引入即可。如下：</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

// 切面类
@Component
@Aspect
@Order(2)
public class MyAspect {

    @Pointcut(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;)
    public void pointcut(){}

    @Around(&quot;pointcut()&quot;)
    public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println(&quot;环绕通知开始&quot;);
        // 执行目标方法。
        proceedingJoinPoint.proceed();
        System.out.println(&quot;环绕通知结束&quot;);
    }

    @Before(&quot;pointcut()&quot;)
    public void beforeAdvice(){
        System.out.println(&quot;前置通知&quot;);
    }

    @AfterReturning(&quot;pointcut()&quot;)
    public void afterReturningAdvice(){
        System.out.println(&quot;后置通知&quot;);
    }

    @AfterThrowing(&quot;pointcut()&quot;)
    public void afterThrowingAdvice(){
        System.out.println(&quot;异常通知&quot;);
    }

    @After(&quot;pointcut()&quot;)
    public void afterAdvice(){
        System.out.println(&quot;最终通知&quot;);
    }

}
</code></pre>
<p>使用@Pointcut注解来定义独立的切点表达式。</p>
<p>注意这个@Pointcut注解标注的方法随意，只是起到一个能够让@Pointcut注解编写的位置。</p>
<p><strong>全注解式开发AOP</strong></p>
<p>就是编写一个类，在这个类上面使用大量注解来代替spring的配置文件，spring配置文件消失了，如下：</p>
<pre><code class="language-java">package com.powernode.spring6.service;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(&quot;com.powernode.spring6.service&quot;)
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class Spring6Configuration {
}
</code></pre>
<pre><code class="language-java">@Test
public void testAOPWithAllAnnotation(){
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Configuration.class);
    OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class);
    orderService.generate();
}
</code></pre>
<h2 id="155-aop">15.5 AOP的实际案例：事务处理</h2>
<p>项目中的事务控制是在所难免的。在一个业务流程当中，可能需要多条DML语句共同完成，为了保证数据的安全，这多条DML语句要么同时成功，要么同时失败。这就需要添加事务控制的代码。例如以下伪代码：</p>
<pre><code class="language-java">class 业务类1{
    public void 业务方法1(){
        try{
            // 开启事务
            startTransaction();

            // 执行核心业务逻辑
            step1();
            step2();
            step3();
            ....

            // 提交事务
            commitTransaction();
        }catch(Exception e){
            // 回滚事务
            rollbackTransaction();
        }
    }
    public void 业务方法2(){
        try{
            // 开启事务
            startTransaction();

            // 执行核心业务逻辑
            step1();
            step2();
            step3();
            ....

            // 提交事务
            commitTransaction();
        }catch(Exception e){
            // 回滚事务
            rollbackTransaction();
        }
    }
    public void 业务方法3(){
        try{
            // 开启事务
            startTransaction();

            // 执行核心业务逻辑
            step1();
            step2();
            step3();
            ....

            // 提交事务
            commitTransaction();
        }catch(Exception e){
            // 回滚事务
            rollbackTransaction();
        }
    }
}

class 业务类2{
    public void 业务方法1(){
        try{
            // 开启事务
            startTransaction();

            // 执行核心业务逻辑
            step1();
            step2();
            step3();
            ....

            // 提交事务
            commitTransaction();
        }catch(Exception e){
            // 回滚事务
            rollbackTransaction();
        }
    }
    public void 业务方法2(){
        try{
            // 开启事务
            startTransaction();

            // 执行核心业务逻辑
            step1();
            step2();
            step3();
            ....

            // 提交事务
            commitTransaction();
        }catch(Exception e){
            // 回滚事务
            rollbackTransaction();
        }
    }
    public void 业务方法3(){
        try{
            // 开启事务
            startTransaction();

            // 执行核心业务逻辑
            step1();
            step2();
            step3();
            ....

            // 提交事务
            commitTransaction();
        }catch(Exception e){
            // 回滚事务
            rollbackTransaction();
        }
    }
}
//......
</code></pre>
<p>可以看到，这些业务类中的每一个业务方法都是需要控制事务的，而控制事务的代码又是固定的格式，都是：</p>
<pre><code class="language-java">try{
    // 开启事务
    startTransaction();

    // 执行核心业务逻辑
    //......

    // 提交事务
    commitTransaction();
}catch(Exception e){
    // 回滚事务
    rollbackTransaction();
}
</code></pre>
<p>这个控制事务的代码就是和业务逻辑没有关系的“交叉业务”。以上伪代码中可以看到这些交叉业务的代码没有得到复用，并且如果这些交叉业务代码需要修改，那必然需要修改多处，难维护，怎么解决？可以采用AOP思想解决。可以把以上控制事务的代码作为环绕通知，切入到目标类的方法当中。接下来我们做一下这件事，有两个业务类，如下：</p>
<pre><code class="language-java">package com.powernode.spring6.biz;

import org.springframework.stereotype.Component;

@Component
// 业务类
public class AccountService {
    // 转账业务方法
    public void transfer(){
        System.out.println(&quot;正在进行银行账户转账&quot;);
    }
    // 取款业务方法
    public void withdraw(){
        System.out.println(&quot;正在进行取款操作&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.biz;

import org.springframework.stereotype.Component;

@Component
// 业务类
public class OrderService {
    // 生成订单
    public void generate(){
        System.out.println(&quot;正在生成订单&quot;);
    }
    // 取消订单
    public void cancel(){
        System.out.println(&quot;正在取消订单&quot;);
    }
}
</code></pre>
<p>注意，以上两个业务类已经纳入spring bean的管理，因为都添加了@Component注解。</p>
<p>接下来我们给以上两个业务类的4个方法添加事务控制代码，使用AOP来完成：</p>
<pre><code class="language-java">package com.powernode.spring6.biz;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
// 事务切面类
public class TransactionAspect {

    @Around(&quot;execution(* com.powernode.spring6.biz..*(..))&quot;)
    public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint){
        try {
            System.out.println(&quot;开启事务&quot;);
            // 执行目标
            proceedingJoinPoint.proceed();
            System.out.println(&quot;提交事务&quot;);
        } catch (Throwable e) {
            System.out.println(&quot;回滚事务&quot;);
        }
    }
}
</code></pre>
<p>你看，这个事务控制代码是不是只需要写一次就行了，并且修改起来也没有成本。编写测试程序：</p>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.biz.AccountService;
import com.powernode.spring6.biz.OrderService;
import com.powernode.spring6.service.Spring6Configuration;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AOPTest2 {
    @Test
    public void testTransaction(){
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Configuration.class);
        OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class);
        AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class);
        // 生成订单
        orderService.generate();
        // 取消订单
        orderService.cancel();
        // 转账
        accountService.transfer();
        // 取款
        accountService.withdraw();
    }
}
</code></pre>
<p>通过测试可以看到，所有的业务方法都添加了事务控制的代码。</p>
<h2 id="156-aop">15.6 AOP的实际案例：安全日志</h2>
<p>需求是这样的：项目开发结束了，已经上线了。运行正常。客户提出了新的需求：凡事在系统中进行修改操作的，删除操作的，新增操作的，都要把这个人记录下来。因为这几个操作是属于危险行为。例如有业务类和业务方法：</p>
<pre><code class="language-java">package com.powernode.spring6.biz;

import org.springframework.stereotype.Component;

@Component
//用户业务
public class UserService {
    public void getUser(){
        System.out.println(&quot;获取用户信息&quot;);
    }
    public void saveUser(){
        System.out.println(&quot;保存用户&quot;);
    }
    public void deleteUser(){
        System.out.println(&quot;删除用户&quot;);
    }
    public void modifyUser(){
        System.out.println(&quot;修改用户&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.biz;

import org.springframework.stereotype.Component;

// 商品业务类
@Component
public class ProductService {
    public void getProduct(){
        System.out.println(&quot;获取商品信息&quot;);
    }
    public void saveProduct(){
        System.out.println(&quot;保存商品&quot;);
    }
    public void deleteProduct(){
        System.out.println(&quot;删除商品&quot;);
    }
    public void modifyProduct(){
        System.out.println(&quot;修改商品&quot;);
    }
}

</code></pre>
<p>注意：已经添加了@Component注解。</p>
<p>接下来我们使用aop来解决上面的需求：编写一个负责安全的切面类</p>
<pre><code class="language-java">package com.powernode.spring6.biz;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class SecurityAspect {

    @Pointcut(&quot;execution(* com.powernode.spring6.biz..save*(..))&quot;)
    public void savePointcut(){}

    @Pointcut(&quot;execution(* com.powernode.spring6.biz..delete*(..))&quot;)
    public void deletePointcut(){}

    @Pointcut(&quot;execution(* com.powernode.spring6.biz..modify*(..))&quot;)
    public void modifyPointcut(){}

    @Before(&quot;savePointcut() || deletePointcut() || modifyPointcut()&quot;)
    public void beforeAdivce(JoinPoint joinpoint){
        System.out.println(&quot;XXX操作员正在操作&quot;+joinpoint.getSignature().getName()+&quot;方法&quot;);
    }
}
</code></pre>
<pre><code class="language-java">@Test
public void testSecurity(){
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Configuration.class);
    UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class);
    ProductService productService = applicationContext.getBean(&quot;productService&quot;, ProductService.class);
    userService.getUser();
    userService.saveUser();
    userService.deleteUser();
    userService.modifyUser();
    productService.getProduct();
    productService.saveProduct();
    productService.deleteProduct();
    productService.modifyProduct();
}
</code></pre>
<h1 id="spring_4">十六、Spring对事务的支持</h1>
<h2 id="161">16.1 事务概述</h2>
<ul>
<li>什么是事务<ul>
<li>在一个业务流程当中，通常需要多条DML（insert delete update）语句共同联合才能完成，这多条DML语句必须同时成功，或者同时失败，这样才能保证数据的安全</li>
<li>多条DML要么同时成功，要么同时失败，这叫做事务</li>
<li>事务：Translation（tx）</li>
</ul>
</li>
<li>事务的四个处理过程<ol>
<li>开启事务</li>
<li>执行核心业务代码</li>
<li>提交事务（如果核心业务处理过程中没有出现异常）</li>
<li>回滚事务（如果核心业务处理过程中出现异常）</li>
</ol>
</li>
<li>事务的四个特性：<ul>
<li>A 原子性：事务是最小的工作单元，不可再分</li>
<li>C 一致性：事务要求要么同时成功，要么同时失败。事务前和事务后的总量不变</li>
<li>I 隔离性：事务和事务之间因为有隔离性，才可以保证互不干扰</li>
<li>D 持久性：持久性是事务结束的标志</li>
</ul>
</li>
</ul>
<h2 id="162">16.2 引入事务场景</h2>
<p>以银行账户转账为例学习事务。两个账户act-001和act-002。act-001账户向act-002账户转账10000，必须同时成功，或者同时失败。（一个减成功，一个加成功， 这两条update语句必须同时成功，或同时失败。）</p>
<p>连接数据库的技术采用Spring框架的JdbcTemplate。</p>
<p>采用三层架构搭建：</p>
<p><img alt="image.png" src="../Spring6.assets/1666495641174-069ee06f-097c-4f44-9a29-ca3e701d666b.png" /></p>
<p>模块名：spring6-013-tx-bank（依赖如下）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.powernode&lt;/groupId&gt;
    &lt;artifactId&gt;spring6-013-tx-bank&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;!--仓库--&gt;
    &lt;repositories&gt;
        &lt;!--spring里程碑版本的仓库--&gt;
        &lt;repository&gt;
            &lt;id&gt;repository.spring.milestone&lt;/id&gt;
            &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;!--依赖--&gt;
    &lt;dependencies&gt;
        &lt;!--spring context--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--spring jdbc--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.30&lt;/version&gt;
        &lt;/dependency&gt;
      &lt;!--德鲁伊连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.2.13&lt;/version&gt;
        &lt;/dependency&gt;
      &lt;!--@Resource注解--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;
            &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<h3 id="_3">第一步：准备数据库表</h3>
<p>表结构：</p>
<p><img alt="image.png" src="../Spring6.assets/1666496097440-75d21db2-588b-4f6a-bd40-149c3de6f27d.png" /></p>
<p>表数据：</p>
<p><img alt="image.png" src="../Spring6.assets/1666496136146-5cc1d848-0ad4-425d-a1fc-8b59b5d0b91f.png" /></p>
<h3 id="_4">第二步：创建包结构</h3>
<p>com.powernode.bank.pojo
com.powernode.bank.service
com.powernode.bank.service.impl
com.powernode.bank.dao
com.powernode.bank.dao.impl</p>
<h3 id="pojo">第三步：准备POJO类</h3>
<pre><code class="language-java">package com.powernode.bank.pojo;

public class Account {
    private String actno;
    private Double balance;

    @Override
    public String toString() {
        return &quot;Account{&quot; +
                &quot;actno='&quot; + actno + '\'' +
                &quot;, balance=&quot; + balance +
                '}';
    }

    public Account() {
    }

    public Account(String actno, Double balance) {
        this.actno = actno;
        this.balance = balance;
    }

    public String getActno() {
        return actno;
    }

    public void setActno(String actno) {
        this.actno = actno;
    }

    public Double getBalance() {
        return balance;
    }

    public void setBalance(Double balance) {
        this.balance = balance;
    }
}
</code></pre>
<h3 id="_5">第四步：编写持久层</h3>
<pre><code class="language-java">package com.powernode.bank.dao;

import com.powernode.bank.pojo.Account;

public interface AccountDao {

    /**
     * 根据账号查询余额
     * @param actno
     * @return
     */
    Account selectByActno(String actno);

    /**
     * 更新账户
     * @param act
     * @return
     */
    int update(Account act);

}
</code></pre>
<pre><code class="language-java">package com.powernode.bank.dao.impl;

import com.powernode.bank.dao.AccountDao;
import com.powernode.bank.pojo.Account;
import jakarta.annotation.Resource;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Repository(&quot;accountDao&quot;)
public class AccountDaoImpl implements AccountDao {

    @Resource(name = &quot;jdbcTemplate&quot;)
    private JdbcTemplate jdbcTemplate;

    @Override
    public Account selectByActno(String actno) {
        String sql = &quot;select actno, balance from t_act where actno = ?&quot;;
        Account account = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), actno);
        return account;
    }

    @Override
    public int update(Account act) {
        String sql = &quot;update t_act set balance = ? where actno = ?&quot;;
        int count = jdbcTemplate.update(sql, act.getBalance(), act.getActno());
        return count;
    }
}
</code></pre>
<h3 id="_6">第五步：编写业务层</h3>
<pre><code class="language-java">package com.powernode.bank.service;

public interface AccountService {

    /**
     * 转账
     * @param fromActno
     * @param toActno
     * @param money
     */
    void transfer(String fromActno, String toActno, double money);
}
</code></pre>
<pre><code class="language-java">package com.powernode.bank.service.impl;

import com.powernode.bank.dao.AccountDao;
import com.powernode.bank.pojo.Account;
import com.powernode.bank.service.AccountService;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service(&quot;accountService&quot;)
public class AccountServiceImpl implements AccountService {

    @Resource(name = &quot;accountDao&quot;)
    private AccountDao accountDao;

    @Override
    public void transfer(String fromActno, String toActno, double money) {
        // 查询账户余额是否充足
        Account fromAct = accountDao.selectByActno(fromActno);
        if (fromAct.getBalance() &lt; money) {
            throw new RuntimeException(&quot;账户余额不足&quot;);
        }
        // 余额充足，开始转账
        Account toAct = accountDao.selectByActno(toActno);
        fromAct.setBalance(fromAct.getBalance() - money);
        toAct.setBalance(toAct.getBalance() + money);
        int count = accountDao.update(fromAct);
        count += accountDao.update(toAct);
        if (count != 2) {
            throw new RuntimeException(&quot;转账失败，请联系银行&quot;);
        }
    }
}
</code></pre>
<h3 id="spring_5">第六步：编写Spring配置文件</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.powernode.bank&quot;/&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="_7">第七步：编写表示层（测试程序）</h3>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.bank.service.AccountService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BankTest {
    @Test
    public void testTransfer(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class);
        try {
            accountService.transfer(&quot;act-001&quot;, &quot;act-002&quot;, 10000);
            System.out.println(&quot;转账成功&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1666497683531-b14430f2-b90e-4555-8552-1de9747c9fcc.png" /></p>
<p>数据变化：</p>
<p><img alt="image.png" src="../Spring6.assets/1666497727323-b2ca34c9-99c6-4b23-8d3b-8dbe3009d3e9.png" /></p>
<h3 id="_8">模拟异常</h3>
<pre><code class="language-java">package com.powernode.bank.service.impl;

import com.powernode.bank.dao.AccountDao;
import com.powernode.bank.pojo.Account;
import com.powernode.bank.service.AccountService;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;

@Service(&quot;accountService&quot;)
public class AccountServiceImpl implements AccountService {

    @Resource(name = &quot;accountDao&quot;)
    private AccountDao accountDao;

    @Override
    public void transfer(String fromActno, String toActno, double money) {
        // 查询账户余额是否充足
        Account fromAct = accountDao.selectByActno(fromActno);
        if (fromAct.getBalance() &lt; money) {
            throw new RuntimeException(&quot;账户余额不足&quot;);
        }
        // 余额充足，开始转账
        Account toAct = accountDao.selectByActno(toActno);
        fromAct.setBalance(fromAct.getBalance() - money);
        toAct.setBalance(toAct.getBalance() + money);
        int count = accountDao.update(fromAct);

        // 模拟异常
        String s = null;
        s.toString();

        count += accountDao.update(toAct);
        if (count != 2) {
            throw new RuntimeException(&quot;转账失败，请联系银行&quot;);
        }
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1666497808309-c50af959-1a57-480c-9f31-76f6ce3b555a.png" /></p>
<p>数据库表中数据：</p>
<p><img alt="image.png" src="../Spring6.assets/1666497824308-bdd8f11f-8f99-4195-81c4-c37721627f4c.png" /></p>
<p><strong>丢了1万</strong></p>
<h2 id="163-spring">16.3 Spring对事务的支持</h2>
<h3 id="spring_6">Spring实现事务的两种方式</h3>
<ul>
<li>编程式事务<ul>
<li>通过编写代码的方式来实现事务的管理</li>
</ul>
</li>
<li>声明式事务<ul>
<li>基于注解方式</li>
<li>基于XML配置方式</li>
</ul>
</li>
</ul>
<h3 id="springapi">Spring事务管理API</h3>
<p>Spring对事务的管理底层实现方式是基于AOP实现的。采用AOP的方式进行了封装。所以Spring专门针对事务开发了一套API，API的核心接口如下：</p>
<p><img alt="image.png" src="../Spring6.assets/1666504216275-1b6a9ac4-6958-4cdf-9323-7a79a08d059d.png" /></p>
<p>PlatformTransactionManager接口：spring事务管理器的核心接口。在<strong>Spring6</strong>中它有两个实现：</p>
<ul>
<li>DataSourceTransactionManager：支持JdbcTemplate、MyBatis、Hibernate等事务管理。</li>
<li>JtaTransactionManager：支持分布式事务管理。</li>
</ul>
<p>如果要在Spring6中使用JdbcTemplate，就要使用DataSourceTransactionManager来管理事务。（Spring内置写好了，可以直接用。）</p>
<h3 id="_9">声明式事务之注解实现方式</h3>
<ol>
<li>在spring配置文件中配置事务管理器</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol>
<li>在spring配置文件中引入tx命名空间</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<ol>
<li>在spring配置文件中配置“事务注解驱动器”，开始注解的方式控制事务。</li>
</ol>
<pre><code class="language-xml">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<ol>
<li>在service类上或方法上添加@Transactional注解</li>
</ol>
<p>在类上添加该注解，该类中所有的方法都有事务。在某个方法上添加该注解，表示只有这个方法使用事务。</p>
<pre><code class="language-java">package com.powernode.bank.service.impl;

import com.powernode.bank.dao.AccountDao;
import com.powernode.bank.pojo.Account;
import com.powernode.bank.service.AccountService;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service(&quot;accountService&quot;)
@Transactional
public class AccountServiceImpl implements AccountService {

    @Resource(name = &quot;accountDao&quot;)
    private AccountDao accountDao;

    @Override
    public void transfer(String fromActno, String toActno, double money) {
        // 查询账户余额是否充足
        Account fromAct = accountDao.selectByActno(fromActno);
        if (fromAct.getBalance() &lt; money) {
            throw new RuntimeException(&quot;账户余额不足&quot;);
        }
        // 余额充足，开始转账
        Account toAct = accountDao.selectByActno(toActno);
        fromAct.setBalance(fromAct.getBalance() - money);
        toAct.setBalance(toAct.getBalance() + money);
        int count = accountDao.update(fromAct);

        // 模拟异常
        String s = null;
        s.toString();

        count += accountDao.update(toAct);
        if (count != 2) {
            throw new RuntimeException(&quot;转账失败，请联系银行&quot;);
        }
    }
}
</code></pre>
<p>当前数据库表中的数据：</p>
<p><img alt="image.png" src="../Spring6.assets/1666505321919-85dd9adb-bceb-49ef-826f-5a3ddf7699a0.png" /></p>
<p><img alt="image.png" src="../Spring6.assets/1666505358758-2a264b1c-3435-4f90-a42f-801001170a2b.png" /></p>
<p>虽然出现异常了，再次查看数据库表中数据：</p>
<p><img alt="image.png" src="../Spring6.assets/1666505321919-85dd9adb-bceb-49ef-826f-5a3ddf7699a0-1667656898791-21.png" /></p>
<p>通过测试，发现数据没有变化，事务起作用了。</p>
<h3 id="_10">事务属性</h3>
<h4 id="_11">事务属性包括哪些</h4>
<p><img alt="image.png" src="../Spring6.assets/1666506552984-8a4f9d42-73ba-4ded-853d-564d27340db5.png" /></p>
<p>事务中的重点属性：</p>
<ul>
<li>事务传播行为</li>
<li>事务隔离级别</li>
<li>事务超时</li>
<li>只读事务</li>
<li>设置出现哪些异常回滚事务</li>
<li>设置出现哪些异常不回滚事务</li>
</ul>
<h4 id="_12">事务传播行为</h4>
<p>什么是事务传播行为？</p>
<p>在service类中有a()方法和b()方法，</p>
<p>a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。</p>
<p>事务传播行为在spring框架中被定义为枚举类型：</p>
<p><img alt="image.png" src="../Spring6.assets/1666505960049-06173489-15fc-4d16-94f3-1a9025f85d8c.png" /></p>
<p>一共有七种传播行为：</p>
<ul>
<li>REQUIRED：支持当前事务吗，如果不存在就新建一个（默认）<strong>【没有就新建，有就加入】</strong></li>
<li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【<strong>有就加入，没有就不管了</strong>】</li>
<li>MANDTORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常<strong>【有就加入，没有就抛异常】</strong></li>
<li>REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起<strong>【不管有没有，直接开启一个新的事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】</strong></li>
<li>NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务<strong>【不支持事务，存在就挂起】</strong></li>
<li>NEVER：以非事务方式运行，如果有事务存在，抛出异常<strong>【不支持事务，存在就抛异常】</strong></li>
<li>NESTED：如果当前正又一个事务在进行中，则该方法应当运行在一个嵌套式事务中，被嵌套的事务可以独立于外层事务进行提交或回滚，如果外层事务不存在，行为就像REQUIRED一样。<strong>【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚，没有事务就和REQUIRED一样】</strong></li>
</ul>
<p>在代码中设置事务的传播行为：</p>
<pre><code class="language-java">@Transactional(propagation = Propagation.REQUIRED)
</code></pre>
<p>可以编写程序测试一下传播行为：</p>
<pre><code class="language-java">@Transactional(propagation = Propagation.REQUIRED)
public void save(Account act) {

    // 这里调用dao的insert方法。
    accountDao.insert(act); // 保存act-003账户

    // 创建账户对象
    Account act2 = new Account(&quot;act-004&quot;, 1000.0);
    try {
        accountService.save(act2); // 保存act-004账户
    } catch (Exception e) {

    }
    // 继续往后进行我当前1号事务自己的事儿。
}
</code></pre>
<pre><code class="language-java">@Override
//@Transactional(propagation = Propagation.REQUIRED)
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void save(Account act) {
    accountDao.insert(act);
    // 模拟异常
    String s = null;
    s.toString();

    // 事儿没有处理完，这个大括号当中的后续也许还有其他的DML语句。
}
</code></pre>
<p><strong>一定要集成Log4j2日志框架，在日志信息中可以看到更加详细的信息。</strong></p>
<h4 id="_13">事务隔离级别</h4>
<p>事务隔离级别类似于教室A和教室B之间的那道墙，隔离级别越高表示墙体越厚，隔音效果越好</p>
<p>数据库中读取数据存在的三大问题：（三大读问题）</p>
<ul>
<li><strong>脏读：读取到没有提交到数据库的数据，叫做脏读</strong></li>
<li><strong>不可重复度：在同一个事务当中，第一次和第二次读取的数据不一样</strong></li>
<li><strong>幻读：读到的数据是假的</strong></li>
</ul>
<p>事务隔离级别包括四个级别：</p>
<ul>
<li>读未提交：READ_UNCOMMITTED<ul>
<li>这种隔离级别，存在脏读问题，所谓的脏读表示能够读取到其他事务未提交的数据</li>
</ul>
</li>
<li>读提交：READ_COMMITTED<ul>
<li>解决了脏读问题，其他事务提交之后才能读到，但存在不可重复读问题</li>
</ul>
</li>
<li>可重复度：REPEATABLE_READ<ul>
<li>解决了不可重复读，可以达到可重复读效果，只要当前事务不结束，读取到的数据一直都是一样的。但存在幻读问题</li>
</ul>
</li>
<li>序列化：SERIALIZABLE<ul>
<li>解决了幻读问题，事务排队执行，不支持并发</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>读提交</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>可重复读</td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>序列化</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>在Spring代码中如何设置隔离级别？</p>
<p>隔离级别在spring中以枚举类型存在：</p>
<p><img alt="image.png" src="../Spring6.assets/1666508609641-2c838566-7334-4cf1-b452-0fed9aaebf3d.png" /></p>
<pre><code class="language-java">@Transactional(isolation = Isolation.READ_COMMITTED)
</code></pre>
<p>测试事务隔离级别：READ_UNCOMMITTED 和 READ_COMMITTED
怎么测试：一个service负责插入，一个service负责查询。负责插入的service要模拟延迟。</p>
<pre><code class="language-java">package com.powernode.bank.service.impl;

import com.powernode.bank.dao.AccountDao;
import com.powernode.bank.pojo.Account;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

@Service(&quot;i1&quot;)
public class IsolationService1 {

    @Resource(name = &quot;accountDao&quot;)
    private AccountDao accountDao;

    // 1号
    // 负责查询
    // 当前事务可以读取到别的事务没有提交的数据。
    //@Transactional(isolation = Isolation.READ_UNCOMMITTED)
    // 对方事务提交之后的数据我才能读取到。
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void getByActno(String actno) {
        Account account = accountDao.selectByActno(actno);
        System.out.println(&quot;查询到的账户信息：&quot; + account);
    }

}
</code></pre>
<pre><code class="language-java">package com.powernode.bank.service.impl;

import com.powernode.bank.dao.AccountDao;
import com.powernode.bank.pojo.Account;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service(&quot;i2&quot;)
public class IsolationService2 {

    @Resource(name = &quot;accountDao&quot;)
    private AccountDao accountDao;

    // 2号
    // 负责insert
    @Transactional
    public void save(Account act) {
        accountDao.insert(act);
        // 睡眠一会
        try {
            Thread.sleep(1000 * 20);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>
<pre><code class="language-java">@Test
public void testIsolation1(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    IsolationService1 i1 = applicationContext.getBean(&quot;i1&quot;, IsolationService1.class);
    i1.getByActno(&quot;act-004&quot;);
}

@Test
public void testIsolation2(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    IsolationService2 i2 = applicationContext.getBean(&quot;i2&quot;, IsolationService2.class);
    Account act = new Account(&quot;act-004&quot;, 1000.0);
    i2.save(act);
}
</code></pre>
<p>通过执行结果可以清晰的看出隔离级别不同，执行效果不同。</p>
<h4 id="_14">事务超时</h4>
<pre><code class="language-java">@Transactional(timeout = 10)
</code></pre>
<p>以上代码表示设置事务的超时时间为10秒</p>
<p><strong>表示超过10秒如果该事务中所有的DML语句还没有执行完毕的话，最终结果也会选择回滚</strong></p>
<p>默认值-1，表示没有时间限制</p>
<p><strong>这里有个坑，事务的超时时间指的是哪段时间？</strong></p>
<p><strong>在当前事务中，最后一条DML语句执行之前的时间，如果最后一条DML语句后面还有很多业务逻辑，这些业务代码执行的时间不被计入超时时间</strong></p>
<p>以下代码的超时不会被计入超时时间</p>
<pre><code class="language-java">@Transactional(timeout = 10) // 设置事务超时时间为10秒。
public void save(Account act) {
    accountDao.insert(act);
    // 睡眠一会
    try {
        Thread.sleep(1000 * 15);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>
<p>以下代码超时时间会被计入超时时间</p>
<pre><code class="language-java">@Transactional(timeout = 10) // 设置事务超时时间为10秒。
public void save(Account act) {
    // 睡眠一会
    try {
        Thread.sleep(1000 * 15);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    accountDao.insert(act);
}
</code></pre>
<p><strong>当然，如果想让整个方法的所有代码都计入超时时间的话，可以在方法最后一行添加一行无关紧要的DML语句</strong>****</p>
<h4 id="_15">只读事务</h4>
<pre><code class="language-java">@Transactional(readOnly = true)
</code></pre>
<p>将当前事务设置为只读事务，在该事务执行过程中只允许select语句执行，delete insert update均不可执行</p>
<p>该特性的作用是：<strong>启动spring的优化策略，提高select语句执行效率</strong></p>
<p>如果该事务中确实没有增删改操作，建议设置为只读事务</p>
<h4 id="_16">设置哪些异常回滚事务</h4>
<pre><code class="language-java">@Transactional(rollbackFor = RuntimeException.class)
</code></pre>
<p>表示只有发生RuntimeException异常或该异常的子类异常才回滚。</p>
<h4 id="_17">设置哪些异常不回滚事务</h4>
<pre><code class="language-java">@Transactional(noRollbackFor = NullPointerException.class)
</code></pre>
<h3 id="_18">事务的全注解式开发</h3>
<pre><code class="language-java">package com.powernode.bank;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;

@Configuration
@ComponentScan(&quot;com.powernode.bank&quot;)
@EnableTransactionManagement
public class Spring6Config {

    @Bean
    public DataSource getDataSource(){
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring6&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;root&quot;);
        return dataSource;
    }

    @Bean(name = &quot;jdbcTemplate&quot;)
    public JdbcTemplate getJdbcTemplate(DataSource dataSource){
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }

    @Bean
    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource){
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }

}
</code></pre>
<pre><code class="language-java">@Test
public void testNoXml(){
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Config.class);
    AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class);
    try {
        accountService.transfer(&quot;act-001&quot;, &quot;act-002&quot;, 10000);
        System.out.println(&quot;转账成功&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<p><img alt="image.png" src="../Spring6.assets/1666511446141-925a1a0e-05ab-4306-996f-532878d5c5a3.png" /></p>
<p><img alt="image.png" src="../Spring6.assets/1666511460275-5ede53ce-9ad1-4bce-935a-32436a46c83a.png" /></p>
<h1 id="spring6junit5">十七、Spring6整合JUnit5</h1>
<h2 id="171-springjunit4">17.1 Spring对JUnit4的支持</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.powernode&lt;/groupId&gt;
    &lt;artifactId&gt;spring6-015-junit&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;!--仓库--&gt;
    &lt;repositories&gt;
        &lt;!--spring里程碑版本的仓库--&gt;
        &lt;repository&gt;
            &lt;id&gt;repository.spring.milestone&lt;/id&gt;
            &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;!--spring context依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--spring对junit的支持相关依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit4依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.bean;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * @author 动力节点
 * @version 1.0
 * @className User
 * @since 1.0
 **/
@Component
public class User {

    @Value(&quot;张三&quot;)
    private String name;

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public User() {
    }

    public User(String name) {
        this.name = name;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>Spring提供的方便主要是这几个注解：
@RunWith(SpringJUnit4ClassRunner.class)</p>
<p>@ContextConfiguration("classpath:spring.xml")</p>
<p>在单元测试类上使用这两个注解之后，在单元测试类的属性上可以使用@Autowried。比较方便</p>
<h2 id="172-springjunit5">17.2 Spring对JUnit5的支持</h2>
<p>引入JUnit5的依赖，Spring对JUnit支持的依赖还是：spring-test，如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.powernode&lt;/groupId&gt;
    &lt;artifactId&gt;spring6-015-junit&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;!--仓库--&gt;
    &lt;repositories&gt;
        &lt;!--spring里程碑版本的仓库--&gt;
        &lt;repository&gt;
            &lt;id&gt;repository.spring.milestone&lt;/id&gt;
            &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;!--spring context依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--spring对junit的支持相关依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;6.0.0-M2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit5依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
            &lt;version&gt;5.9.0&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="language-java">package com.powernode.spring6.test;

import com.powernode.spring6.bean.User;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;


@ExtendWith(SpringExtension.class)
@ContextConfiguration(&quot;classpath:spring.xml&quot;)
public class SpringJUnit5Test {

    @Autowired
    private User user;

    @Test
    public void testUser(){
        System.out.println(user.getName());
    }
}
</code></pre>
<p>在JUnit5当中，可以使用Spring提供的以下两个注解，标注到单元测试类上，这样在类当中就可以使用@Autowried注解了</p>
<p>@ExtenWith(SpringExtension.class)</p>
<p>@ContextConfiguration("classspath:spring.xml")</p>
<h1 id="spring_7">十九、Spring中的八大模式</h1>
<h2 id="191">19.1 简单工厂模式</h2>
<p>BeanFactory的getBean()方法，通过唯一标识来获取Bean对象。是典型的简单工厂模式（静态工厂模式）</p>
<h2 id="192">19.2 工厂方法模式</h2>
<p>FactoryBean是典型的工厂方法模式，在配置文件中通过factory-method属性来指定工厂方法，该方法是一个实例方法</p>
<h2 id="193">19.3 单例模式</h2>
<p>Spring用的是双重判断加锁的单例模式</p>
<p><img alt="image.png" src="https://cdn.nlark.com/yuque/0/2022/png/21376908/1666663352271-4ba8d737-1e32-4f0e-b01a-aa305ad3abea.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5Yqo5Yqb6IqC54K5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1190%2Climit_0" /></p>
<h2 id="194">19.4 代理模式</h2>
<p>Spring的AOP就是使用了动态代理实现的</p>
<h2 id="195">19.5 装饰器模式</h2>
<p>JavaSE中的IO流就是非常典型的装饰器模式</p>
<p>Spring中配置DataSource的时候，这些DataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache提供的</p>
<p>org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。</p>
<p>这时，能否在尽可能少修改原有类代码的情况下，做到动态切换不同的数据源？此时可以用到装饰者模式</p>
<p>Spring根据每次请求的不同，将DataSource属性设置成不同的数据源，以打到切换数据源的目的</p>
<p><strong>Spring中类名中带有：Decorator和Wrapper单词的类，都是装饰器模式</strong></p>
<h2 id="196">19.6 观察者模式</h2>
<p>定义对象间一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</p>
<p>Spring中观察者模式一般用在listener的实现</p>
<p>Spring中的时间编程模型就是观察者模式的实现，在Spring中定义了一个ApplicationContext内置了几个时间，其中比较容易理解的是：ContextRefreshEvent、ContextStartedEvent、ContextStoppedEvent、ContextClosedEvent</p>
<h2 id="197">19.7 策略模式</h2>
<p>策略模式是行为性模式，调用不同的方法，适应行为的变化，强调父类的调用子类的特性</p>
<p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器</p>
<p>比如我们自己写了AccountDao接口，然后这个接口下有不同的实现类：AccountDaoForMySql、AccountDaoForOracle。对于service来说不需要关心底层具体的实现，只需要面向AccountDao接口调用，底层可以灵活切换实现，这就是策略模式</p>
<h2 id="198">19.8 模板方法模式</h2>
<p>Spring中的JdbcTemplate类就是一个模板类，它就是一个模板方法设计模式的体现。在模板类的模板方法execute中编写核心算法，具体的实现步骤在子类中完成</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.efa0ade1.min.js"></script>
      
    
  </body>
</html>