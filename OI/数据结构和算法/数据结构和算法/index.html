
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../..">
      
      
        <link rel="next" href="../../%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.1.3">
    
    
      
        <title>数据结构和算法 - Serendipity_Docs</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.c4a75a56.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Serendipity_Docs" class="md-header__button md-logo" aria-label="Serendipity_Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Serendipity_Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              数据结构和算法
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Serendipity_Docs" class="md-nav__button md-logo" aria-label="Serendipity_Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Serendipity_Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        主页
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
      
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          OI
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          OI
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" checked>
      
      
      
        <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
          数据结构和算法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          数据结构和算法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          数据结构和算法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        数据结构和算法
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    一、数据结构和算法内容介绍
  </a>
  
    <nav class="md-nav" aria-label="一、数据结构和算法内容介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 几个经典算法面试题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    二、数据结构和算法概述
  </a>
  
    <nav class="md-nav" aria-label="二、数据结构和算法概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 数据结构和算法的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 几个十一编程中遇到的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 线性结构和非线性结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    三、稀疏数组和队列
  </a>
  
    <nav class="md-nav" aria-label="三、稀疏数组和队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-sparsearray" class="md-nav__link">
    3.1 稀疏sparsearray数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 队列
  </a>
  
    <nav class="md-nav" aria-label="3.2 队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321" class="md-nav__link">
    3.2.1 数组模拟队列思路：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#322" class="md-nav__link">
    3.2.2 数组模拟环形队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    四、链表
  </a>
  
    <nav class="md-nav" aria-label="四、链表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 单链表的应用实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2 单链表面试题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    4.3 双向链表应用实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    4.4 单向环形链表应用场景
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    五、栈
  </a>
  
    <nav class="md-nav" aria-label="五、栈">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    5.1 栈的一个实际需求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    5.2 栈的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    5.3 栈的应用场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    5.4 栈的快速入门
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#55" class="md-nav__link">
    5.5 栈实现综合计算器(中缀表达式)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#56" class="md-nav__link">
    5.6 逆波兰计算器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#57" class="md-nav__link">
    5.7 中缀表达式转换为后缀表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#58" class="md-nav__link">
    5.8 逆波兰计算器完整版
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    六、递归
  </a>
  
    <nav class="md-nav" aria-label="六、递归">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    6.1 递归应用场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62" class="md-nav__link">
    6.2 递归的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63" class="md-nav__link">
    6.3 递归调用机制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64" class="md-nav__link">
    6.4 递归能解决什么样的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#65" class="md-nav__link">
    6.5 递归需要遵守的重要规则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#66-" class="md-nav__link">
    6.6 递归-迷宫问题
  </a>
  
    <nav class="md-nav" aria-label="6.6 递归-迷宫问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#661" class="md-nav__link">
    6.6.1 迷宫问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#662" class="md-nav__link">
    6.6.2 代码实现:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#663" class="md-nav__link">
    6.6.3 对迷宫问题的讨论
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#67-" class="md-nav__link">
    6.7  递归-八皇后问题(回溯算法)
  </a>
  
    <nav class="md-nav" aria-label="6.7  递归-八皇后问题(回溯算法)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#671" class="md-nav__link">
    6.7.1 八皇后问题介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#672" class="md-nav__link">
    6.7.2 八皇后问题算法思路分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#673" class="md-nav__link">
    6.7.3 八皇后问题算法代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    七、排序算法
  </a>
  
    <nav class="md-nav" aria-label="七、排序算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71" class="md-nav__link">
    7.1 排序算法的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72" class="md-nav__link">
    7.2 排序的分类：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73" class="md-nav__link">
    7.3 算法的时间复杂度
  </a>
  
    <nav class="md-nav" aria-label="7.3 算法的时间复杂度">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#731" class="md-nav__link">
    7.3.1 度量一个程序(算法)执行时间的两种方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#732" class="md-nav__link">
    7.3.2 时间频度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#733" class="md-nav__link">
    7.3.3 时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#734" class="md-nav__link">
    7.3.4 常见的时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#735" class="md-nav__link">
    7.3.5 平均时间复杂度和最坏时间复杂度
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#74" class="md-nav__link">
    7.4 算法的空间复杂度简介
  </a>
  
    <nav class="md-nav" aria-label="7.4 算法的空间复杂度简介">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#741" class="md-nav__link">
    7.4.1 基本介绍
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#75" class="md-nav__link">
    7.5 冒泡排序
  </a>
  
    <nav class="md-nav" aria-label="7.5 冒泡排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#751" class="md-nav__link">
    7.5.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#752" class="md-nav__link">
    7.5.2 演示冒泡过程的例子(图解)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#753" class="md-nav__link">
    7.5.3 冒泡排序应用实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#76" class="md-nav__link">
    7.6 选择排序
  </a>
  
    <nav class="md-nav" aria-label="7.6 选择排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#761" class="md-nav__link">
    7.6.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#762" class="md-nav__link">
    7.6.2 选择排序思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#763" class="md-nav__link">
    7.6.3 选择排序思路分析图:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#764" class="md-nav__link">
    7.6.4 选择排序应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#77" class="md-nav__link">
    7.7 插入排序
  </a>
  
    <nav class="md-nav" aria-label="7.7 插入排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#771" class="md-nav__link">
    7.7.1 插入排序法介绍:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#772" class="md-nav__link">
    7.7.2 插入排序法思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#773" class="md-nav__link">
    7.7.3 插入排序思路图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#774" class="md-nav__link">
    7.7.4 插入排序法应用实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#78" class="md-nav__link">
    7.8 希尔排序
  </a>
  
    <nav class="md-nav" aria-label="7.8 希尔排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#781" class="md-nav__link">
    7.8.1 简单插入排序存在的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#782" class="md-nav__link">
    7.8.2 希尔排序法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#783" class="md-nav__link">
    7.8.3 希尔排序法基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#784" class="md-nav__link">
    7.8.4 希尔排序法的示意图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#785" class="md-nav__link">
    7.8.5 希尔排序法应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#79" class="md-nav__link">
    7.9 快速排序
  </a>
  
    <nav class="md-nav" aria-label="7.9 快速排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#791" class="md-nav__link">
    7.9.1 快速排序法介绍:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#792" class="md-nav__link">
    7.9.2 快速排序法示意图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#793" class="md-nav__link">
    7.9.3 快速排序法应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#710" class="md-nav__link">
    7.10 归并排序
  </a>
  
    <nav class="md-nav" aria-label="7.10 归并排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#7101" class="md-nav__link">
    7.10.1 归并排序介绍:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7102-1-" class="md-nav__link">
    7.10.2 归并排序思想示意图 1-基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7103-2-" class="md-nav__link">
    7.10.3 归并排序思想示意图 2-合并相邻有序子序列:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7104" class="md-nav__link">
    7.10.4 归并排序的应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#711" class="md-nav__link">
    7.11 基数排序
  </a>
  
    <nav class="md-nav" aria-label="7.11 基数排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#7111" class="md-nav__link">
    7.11.1 基数排序(桶排序)介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7112" class="md-nav__link">
    7.11.2 基数排序基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7113" class="md-nav__link">
    7.11.3 基数排序图文说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7114" class="md-nav__link">
    7.11.4 基数排序代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7115" class="md-nav__link">
    7.11.5 基数排序的说明
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#712" class="md-nav__link">
    7.12 常用排序算法总结和对比
  </a>
  
    <nav class="md-nav" aria-label="7.12 常用排序算法总结和对比">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#7121" class="md-nav__link">
    7.12.1 一张排序算法的比较图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7122" class="md-nav__link">
    7.12.2 相关术语解释
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    八、查找算法
  </a>
  
    <nav class="md-nav" aria-label="八、查找算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81" class="md-nav__link">
    8.1 查找算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82" class="md-nav__link">
    8.2 线性查找算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#83" class="md-nav__link">
    8.3 二分查找算法
  </a>
  
    <nav class="md-nav" aria-label="8.3 二分查找算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#831" class="md-nav__link">
    8.3.1 二分查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#832" class="md-nav__link">
    8.3.2 二分查找算法的思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#833" class="md-nav__link">
    8.3.3 二分查找的代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#84" class="md-nav__link">
    8.4 插值查找
  </a>
  
    <nav class="md-nav" aria-label="8.4 插值查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#841" class="md-nav__link">
    8.4.1 插值查找应用案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#842" class="md-nav__link">
    8.4.2 插值查找注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#85" class="md-nav__link">
    8.5 斐波那契(黄金分割法)查找算法
  </a>
  
    <nav class="md-nav" aria-label="8.5 斐波那契(黄金分割法)查找算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#851" class="md-nav__link">
    8.5.1 斐波那契(黄金分割法)查找基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#852" class="md-nav__link">
    8.5.2 斐波那契(黄金分割法)原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#853" class="md-nav__link">
    8.5.3 斐波那契查找应用案例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    九、哈希表
  </a>
  
    <nav class="md-nav" aria-label="九、哈希表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#91-google" class="md-nav__link">
    9.1 哈希表(散列)-Google 上机题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#92" class="md-nav__link">
    9.2 哈希表的基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#93-google" class="md-nav__link">
    9.3 google 公司的一个上机题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    十、树结构的基础部分
  </a>
  
    <nav class="md-nav" aria-label="十、树结构的基础部分">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#101" class="md-nav__link">
    10.1 二叉树
  </a>
  
    <nav class="md-nav" aria-label="10.1 二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1011" class="md-nav__link">
    10.1.1 为什么需要树这种数据结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1012" class="md-nav__link">
    10.1.2 树示意图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1013" class="md-nav__link">
    10.1.3 二叉树的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1014" class="md-nav__link">
    10.1.4 二叉树遍历的说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1015" class="md-nav__link">
    10.1.5 二叉树遍历应用实例(前序,中序,后序)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1016-" class="md-nav__link">
    10.1.6 二叉树-查找指定节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1017-" class="md-nav__link">
    10.1.7 二叉树-删除节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102" class="md-nav__link">
    10.2 顺序存储二叉树
  </a>
  
    <nav class="md-nav" aria-label="10.2 顺序存储二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1021" class="md-nav__link">
    10.2.1 顺序存储二叉树的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1022" class="md-nav__link">
    10.2.2 顺序存储二叉树遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1023" class="md-nav__link">
    10.2.3 顺序存储二叉树应用实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103" class="md-nav__link">
    10.3 线索化二叉树
  </a>
  
    <nav class="md-nav" aria-label="10.3 线索化二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1031" class="md-nav__link">
    10.3.1 先看一个问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1032" class="md-nav__link">
    10.3.2 线索二叉树基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1033" class="md-nav__link">
    10.3.3 线索二叉树应用案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1034" class="md-nav__link">
    10.3.4 遍历线索化二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    十一、树结构实际应用
  </a>
  
    <nav class="md-nav" aria-label="十一、树结构实际应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111" class="md-nav__link">
    11.1 堆排序
  </a>
  
    <nav class="md-nav" aria-label="11.1 堆排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1111" class="md-nav__link">
    11.1.1 堆排序基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1112" class="md-nav__link">
    11.1.2 堆排序基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1113" class="md-nav__link">
    11.1.3 堆排序步骤图解说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1114" class="md-nav__link">
    11.1.4 堆排序代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112" class="md-nav__link">
    11.2 赫夫曼树
  </a>
  
    <nav class="md-nav" aria-label="11.2 赫夫曼树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1121" class="md-nav__link">
    11.2.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1122" class="md-nav__link">
    11.2.2 赫夫曼树几个重要概念和举例说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1123" class="md-nav__link">
    11.2.3 赫夫曼树创建思路图解
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113" class="md-nav__link">
    11.3 赫夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="11.3 赫夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1131" class="md-nav__link">
    11.3.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1132" class="md-nav__link">
    11.3.2 原理剖析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1133-" class="md-nav__link">
    11.3.3 最佳实践-数据压缩(创建赫夫曼树)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1134-" class="md-nav__link">
    11.3.4 最佳实践-文件压缩
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1135-" class="md-nav__link">
    11.3.5 最佳实践-文件解压(文件恢复)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1136" class="md-nav__link">
    11.3.6 赫夫曼编码压缩文件注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#114" class="md-nav__link">
    11.4 二叉排序树
  </a>
  
    <nav class="md-nav" aria-label="11.4 二叉排序树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1141" class="md-nav__link">
    11.4.1 先看一个需求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1142" class="md-nav__link">
    11.4.2 解决方案分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1143" class="md-nav__link">
    11.4.3 二叉排序树介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1144" class="md-nav__link">
    11.4.4 二叉排序树创建和遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1145" class="md-nav__link">
    11.4.5 二叉排序树的删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1146" class="md-nav__link">
    11.4.6 二叉排序树的代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#115-avl" class="md-nav__link">
    11.5 平衡二叉树(AVL  树)
  </a>
  
    <nav class="md-nav" aria-label="11.5 平衡二叉树(AVL  树)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1151" class="md-nav__link">
    11.5.1 看一个案例(说明二叉排序树可能的问题)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1152" class="md-nav__link">
    11.5.2 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1153-" class="md-nav__link">
    11.5.3 应用案例-单旋转(左旋转)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1154-" class="md-nav__link">
    11.5.4 应用案例-单旋转(右旋转)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1155-" class="md-nav__link">
    11.5.5 应用案例-双旋转
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    十二、多路查找树
  </a>
  
    <nav class="md-nav" aria-label="十二、多路查找树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#121-b" class="md-nav__link">
    12.1 二叉树与 B  树
  </a>
  
    <nav class="md-nav" aria-label="12.1 二叉树与 B  树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1211" class="md-nav__link">
    12.1.1 二叉树的问题分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1212" class="md-nav__link">
    12.1.2 多叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1213-b" class="md-nav__link">
    12.1.3 B 树的基本介绍
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#122-2-3" class="md-nav__link">
    12.2 2-3  树
  </a>
  
    <nav class="md-nav" aria-label="12.2 2-3  树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1221-2-3-b" class="md-nav__link">
    12.2.1 2-3 树是最简单的  B  树结构,   具有如下特点:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1222-2-3" class="md-nav__link">
    12.2.2 2-3 树应用案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1223" class="md-nav__link">
    12.2.3 其它说明
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#123-b-b-b" class="md-nav__link">
    12.3 B  树、B+树和  B*树
  </a>
  
    <nav class="md-nav" aria-label="12.3 B  树、B+树和  B*树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1231-b" class="md-nav__link">
    12.3.1 B 树的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1232-b" class="md-nav__link">
    12.3.2 B 树的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1233-b" class="md-nav__link">
    12.3.3 B+树的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1234-b" class="md-nav__link">
    12.3.4 B*树的介绍
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    十三、图
  </a>
  
    <nav class="md-nav" aria-label="十三、图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131" class="md-nav__link">
    13.1 图基本介绍
  </a>
  
    <nav class="md-nav" aria-label="13.1 图基本介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1311" class="md-nav__link">
    13.1.1 为什么要有图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1312" class="md-nav__link">
    13.1.2 图的举例说明
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1313" class="md-nav__link">
    13.1.3 图的常用概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132" class="md-nav__link">
    13.2 图的表示方式
  </a>
  
    <nav class="md-nav" aria-label="13.2 图的表示方式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1321" class="md-nav__link">
    13.2.1 邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1322" class="md-nav__link">
    13.2.2 邻接表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133" class="md-nav__link">
    13.3 图的快速入门案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#134" class="md-nav__link">
    13.4 图的深度优先遍历介绍
  </a>
  
    <nav class="md-nav" aria-label="13.4 图的深度优先遍历介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1341" class="md-nav__link">
    13.4.1 图遍历介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1342" class="md-nav__link">
    13.4.2 深度优先遍历基本思想
  </a>
  
    <nav class="md-nav" aria-label="13.4.2 深度优先遍历基本思想">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1343" class="md-nav__link">
    13.4.3 深度优先遍历算法步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#135" class="md-nav__link">
    13.5 图的广度优先遍历
  </a>
  
    <nav class="md-nav" aria-label="13.5 图的广度优先遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1351" class="md-nav__link">
    13.5.1 广度优先遍历基本思想
  </a>
  
    <nav class="md-nav" aria-label="13.5.1 广度优先遍历基本思想">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1352" class="md-nav__link">
    13.5.2 广度优先遍历算法步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#v-v" class="md-nav__link">
    访问初始结点 v  并标记结点 v  为已访问。
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#136-vs" class="md-nav__link">
    13.6 图的深度优先 VS    广度优先
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    十四、程序员常用  10  种算法
  </a>
  
    <nav class="md-nav" aria-label="十四、程序员常用  10  种算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#141" class="md-nav__link">
    14.1 二分查找算法(非递归)
  </a>
  
    <nav class="md-nav" aria-label="14.1 二分查找算法(非递归)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1411" class="md-nav__link">
    14.1.1 二分查找算法(非递归)介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1412" class="md-nav__link">
    14.1.2 二分查找算法(非递归)代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#142" class="md-nav__link">
    14.2 分治算法
  </a>
  
    <nav class="md-nav" aria-label="14.2 分治算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1421" class="md-nav__link">
    14.2.1 分治算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1422" class="md-nav__link">
    14.2.2 分治算法的基本步骤
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1423-divide-and-conquerp" class="md-nav__link">
    14.2.3 分治(Divide-and-Conquer(P))算法设计模式如下：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1424-" class="md-nav__link">
    14.2.4 分治算法最佳实践-汉诺塔
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#143" class="md-nav__link">
    14.3 动态规划算法
  </a>
  
    <nav class="md-nav" aria-label="14.3 动态规划算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1431-" class="md-nav__link">
    14.3.1 应用场景-背包问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1432" class="md-nav__link">
    14.3.2 动态规划算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1433-" class="md-nav__link">
    14.3.3 动态规划算法最佳实践-背包问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#144-kmp" class="md-nav__link">
    14.4 KMP  算法
  </a>
  
    <nav class="md-nav" aria-label="14.4 KMP  算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1441-" class="md-nav__link">
    14.4.1 应用场景-字符串匹配问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1442" class="md-nav__link">
    14.4.2 暴力匹配算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1443-kmp" class="md-nav__link">
    14.4.3 KMP  算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1444-kmp-" class="md-nav__link">
    14.4.4 KMP  算法最佳应用-字符串匹配问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#145" class="md-nav__link">
    14.5 贪心算法
  </a>
  
    <nav class="md-nav" aria-label="14.5 贪心算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1451-" class="md-nav__link">
    14.5.1 应用场景-集合覆盖问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1452" class="md-nav__link">
    14.5.2 贪心算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1453-" class="md-nav__link">
    14.5.3 贪心算法最佳应用-集合覆盖
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1454" class="md-nav__link">
    14.5.4 贪心算法注意事项和细节
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
          算法总结
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          算法总结
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="md-nav__link">
        算法总结
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
      
      
      
        <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
          动态规划
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_3">
          <span class="md-nav__icon md-icon"></span>
          动态规划
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" class="md-nav__link">
        记忆化搜素
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/" class="md-nav__link">
        背包DP
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/" class="md-nav__link">
        区间DP
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
      
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          java学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          java学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="md-nav__link">
        微服务
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/Centos7%E5%AE%89%E8%A3%85Docker/" class="md-nav__link">
        Centos7安装Docker
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/Docker%E5%91%BD%E4%BB%A4/" class="md-nav__link">
        Docker命令
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/MyBatis-Plus/" class="md-nav__link">
        MyBatis
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="md-nav__link">
        nacos集群搭建
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/" class="md-nav__link">
        RabbitMQ部署指南
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/Redis7/" class="md-nav__link">
        Redis7
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/Spring6/" class="md-nav__link">
        Spring6
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/SpringBoot/" class="md-nav__link">
        SpringBoot
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../java%E5%AD%A6%E4%B9%A0/%E5%AE%89%E8%A3%85elasticsearch/" class="md-nav__link">
        安装elasticsearch
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
      
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          Qt
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          Qt
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Qt/Qt/" class="md-nav__link">
        Qt
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
      
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          前端学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          前端学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%89%8D%E7%AB%AF/Vue%EF%BC%88%E9%9D%9E%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%89/" class="md-nav__link">
        Vue（非脚手架）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%89%8D%E7%AB%AF/Vue%EF%BC%88%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%89/" class="md-nav__link">
        Vue（脚手架）
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          Android
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Android
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Android/Android/" class="md-nav__link">
        Android
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
      
      
      
        <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
          嵌入式
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          嵌入式
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%B5%8C%E5%85%A5%E5%BC%8F/C51%E5%8D%95%E7%89%87%E6%9C%BA/" class="md-nav__link">
        C51单片机
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
      
      
      
        <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
          考研
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          考研
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="md-nav__link">
        计算机网络
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="md-nav__link">
        计算机组成原理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    一、数据结构和算法内容介绍
  </a>
  
    <nav class="md-nav" aria-label="一、数据结构和算法内容介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 几个经典算法面试题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    二、数据结构和算法概述
  </a>
  
    <nav class="md-nav" aria-label="二、数据结构和算法概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 数据结构和算法的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 几个十一编程中遇到的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 线性结构和非线性结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    三、稀疏数组和队列
  </a>
  
    <nav class="md-nav" aria-label="三、稀疏数组和队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-sparsearray" class="md-nav__link">
    3.1 稀疏sparsearray数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 队列
  </a>
  
    <nav class="md-nav" aria-label="3.2 队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321" class="md-nav__link">
    3.2.1 数组模拟队列思路：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#322" class="md-nav__link">
    3.2.2 数组模拟环形队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    四、链表
  </a>
  
    <nav class="md-nav" aria-label="四、链表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 单链表的应用实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2 单链表面试题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    4.3 双向链表应用实例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    4.4 单向环形链表应用场景
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    五、栈
  </a>
  
    <nav class="md-nav" aria-label="五、栈">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    5.1 栈的一个实际需求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    5.2 栈的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    5.3 栈的应用场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    5.4 栈的快速入门
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#55" class="md-nav__link">
    5.5 栈实现综合计算器(中缀表达式)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#56" class="md-nav__link">
    5.6 逆波兰计算器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#57" class="md-nav__link">
    5.7 中缀表达式转换为后缀表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#58" class="md-nav__link">
    5.8 逆波兰计算器完整版
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    六、递归
  </a>
  
    <nav class="md-nav" aria-label="六、递归">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    6.1 递归应用场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62" class="md-nav__link">
    6.2 递归的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63" class="md-nav__link">
    6.3 递归调用机制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64" class="md-nav__link">
    6.4 递归能解决什么样的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#65" class="md-nav__link">
    6.5 递归需要遵守的重要规则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#66-" class="md-nav__link">
    6.6 递归-迷宫问题
  </a>
  
    <nav class="md-nav" aria-label="6.6 递归-迷宫问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#661" class="md-nav__link">
    6.6.1 迷宫问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#662" class="md-nav__link">
    6.6.2 代码实现:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#663" class="md-nav__link">
    6.6.3 对迷宫问题的讨论
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#67-" class="md-nav__link">
    6.7  递归-八皇后问题(回溯算法)
  </a>
  
    <nav class="md-nav" aria-label="6.7  递归-八皇后问题(回溯算法)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#671" class="md-nav__link">
    6.7.1 八皇后问题介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#672" class="md-nav__link">
    6.7.2 八皇后问题算法思路分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#673" class="md-nav__link">
    6.7.3 八皇后问题算法代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    七、排序算法
  </a>
  
    <nav class="md-nav" aria-label="七、排序算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71" class="md-nav__link">
    7.1 排序算法的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72" class="md-nav__link">
    7.2 排序的分类：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73" class="md-nav__link">
    7.3 算法的时间复杂度
  </a>
  
    <nav class="md-nav" aria-label="7.3 算法的时间复杂度">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#731" class="md-nav__link">
    7.3.1 度量一个程序(算法)执行时间的两种方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#732" class="md-nav__link">
    7.3.2 时间频度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#733" class="md-nav__link">
    7.3.3 时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#734" class="md-nav__link">
    7.3.4 常见的时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#735" class="md-nav__link">
    7.3.5 平均时间复杂度和最坏时间复杂度
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#74" class="md-nav__link">
    7.4 算法的空间复杂度简介
  </a>
  
    <nav class="md-nav" aria-label="7.4 算法的空间复杂度简介">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#741" class="md-nav__link">
    7.4.1 基本介绍
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#75" class="md-nav__link">
    7.5 冒泡排序
  </a>
  
    <nav class="md-nav" aria-label="7.5 冒泡排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#751" class="md-nav__link">
    7.5.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#752" class="md-nav__link">
    7.5.2 演示冒泡过程的例子(图解)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#753" class="md-nav__link">
    7.5.3 冒泡排序应用实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#76" class="md-nav__link">
    7.6 选择排序
  </a>
  
    <nav class="md-nav" aria-label="7.6 选择排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#761" class="md-nav__link">
    7.6.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#762" class="md-nav__link">
    7.6.2 选择排序思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#763" class="md-nav__link">
    7.6.3 选择排序思路分析图:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#764" class="md-nav__link">
    7.6.4 选择排序应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#77" class="md-nav__link">
    7.7 插入排序
  </a>
  
    <nav class="md-nav" aria-label="7.7 插入排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#771" class="md-nav__link">
    7.7.1 插入排序法介绍:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#772" class="md-nav__link">
    7.7.2 插入排序法思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#773" class="md-nav__link">
    7.7.3 插入排序思路图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#774" class="md-nav__link">
    7.7.4 插入排序法应用实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#78" class="md-nav__link">
    7.8 希尔排序
  </a>
  
    <nav class="md-nav" aria-label="7.8 希尔排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#781" class="md-nav__link">
    7.8.1 简单插入排序存在的问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#782" class="md-nav__link">
    7.8.2 希尔排序法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#783" class="md-nav__link">
    7.8.3 希尔排序法基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#784" class="md-nav__link">
    7.8.4 希尔排序法的示意图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#785" class="md-nav__link">
    7.8.5 希尔排序法应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#79" class="md-nav__link">
    7.9 快速排序
  </a>
  
    <nav class="md-nav" aria-label="7.9 快速排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#791" class="md-nav__link">
    7.9.1 快速排序法介绍:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#792" class="md-nav__link">
    7.9.2 快速排序法示意图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#793" class="md-nav__link">
    7.9.3 快速排序法应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#710" class="md-nav__link">
    7.10 归并排序
  </a>
  
    <nav class="md-nav" aria-label="7.10 归并排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#7101" class="md-nav__link">
    7.10.1 归并排序介绍:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7102-1-" class="md-nav__link">
    7.10.2 归并排序思想示意图 1-基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7103-2-" class="md-nav__link">
    7.10.3 归并排序思想示意图 2-合并相邻有序子序列:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7104" class="md-nav__link">
    7.10.4 归并排序的应用实例:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#711" class="md-nav__link">
    7.11 基数排序
  </a>
  
    <nav class="md-nav" aria-label="7.11 基数排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#7111" class="md-nav__link">
    7.11.1 基数排序(桶排序)介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7112" class="md-nav__link">
    7.11.2 基数排序基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7113" class="md-nav__link">
    7.11.3 基数排序图文说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7114" class="md-nav__link">
    7.11.4 基数排序代码实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7115" class="md-nav__link">
    7.11.5 基数排序的说明
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#712" class="md-nav__link">
    7.12 常用排序算法总结和对比
  </a>
  
    <nav class="md-nav" aria-label="7.12 常用排序算法总结和对比">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#7121" class="md-nav__link">
    7.12.1 一张排序算法的比较图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7122" class="md-nav__link">
    7.12.2 相关术语解释
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    八、查找算法
  </a>
  
    <nav class="md-nav" aria-label="八、查找算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81" class="md-nav__link">
    8.1 查找算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82" class="md-nav__link">
    8.2 线性查找算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#83" class="md-nav__link">
    8.3 二分查找算法
  </a>
  
    <nav class="md-nav" aria-label="8.3 二分查找算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#831" class="md-nav__link">
    8.3.1 二分查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#832" class="md-nav__link">
    8.3.2 二分查找算法的思路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#833" class="md-nav__link">
    8.3.3 二分查找的代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#84" class="md-nav__link">
    8.4 插值查找
  </a>
  
    <nav class="md-nav" aria-label="8.4 插值查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#841" class="md-nav__link">
    8.4.1 插值查找应用案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#842" class="md-nav__link">
    8.4.2 插值查找注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#85" class="md-nav__link">
    8.5 斐波那契(黄金分割法)查找算法
  </a>
  
    <nav class="md-nav" aria-label="8.5 斐波那契(黄金分割法)查找算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#851" class="md-nav__link">
    8.5.1 斐波那契(黄金分割法)查找基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#852" class="md-nav__link">
    8.5.2 斐波那契(黄金分割法)原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#853" class="md-nav__link">
    8.5.3 斐波那契查找应用案例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    九、哈希表
  </a>
  
    <nav class="md-nav" aria-label="九、哈希表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#91-google" class="md-nav__link">
    9.1 哈希表(散列)-Google 上机题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#92" class="md-nav__link">
    9.2 哈希表的基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#93-google" class="md-nav__link">
    9.3 google 公司的一个上机题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    十、树结构的基础部分
  </a>
  
    <nav class="md-nav" aria-label="十、树结构的基础部分">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#101" class="md-nav__link">
    10.1 二叉树
  </a>
  
    <nav class="md-nav" aria-label="10.1 二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1011" class="md-nav__link">
    10.1.1 为什么需要树这种数据结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1012" class="md-nav__link">
    10.1.2 树示意图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1013" class="md-nav__link">
    10.1.3 二叉树的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1014" class="md-nav__link">
    10.1.4 二叉树遍历的说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1015" class="md-nav__link">
    10.1.5 二叉树遍历应用实例(前序,中序,后序)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1016-" class="md-nav__link">
    10.1.6 二叉树-查找指定节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1017-" class="md-nav__link">
    10.1.7 二叉树-删除节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102" class="md-nav__link">
    10.2 顺序存储二叉树
  </a>
  
    <nav class="md-nav" aria-label="10.2 顺序存储二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1021" class="md-nav__link">
    10.2.1 顺序存储二叉树的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1022" class="md-nav__link">
    10.2.2 顺序存储二叉树遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1023" class="md-nav__link">
    10.2.3 顺序存储二叉树应用实例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103" class="md-nav__link">
    10.3 线索化二叉树
  </a>
  
    <nav class="md-nav" aria-label="10.3 线索化二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1031" class="md-nav__link">
    10.3.1 先看一个问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1032" class="md-nav__link">
    10.3.2 线索二叉树基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1033" class="md-nav__link">
    10.3.3 线索二叉树应用案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1034" class="md-nav__link">
    10.3.4 遍历线索化二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    十一、树结构实际应用
  </a>
  
    <nav class="md-nav" aria-label="十一、树结构实际应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111" class="md-nav__link">
    11.1 堆排序
  </a>
  
    <nav class="md-nav" aria-label="11.1 堆排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1111" class="md-nav__link">
    11.1.1 堆排序基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1112" class="md-nav__link">
    11.1.2 堆排序基本思想
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1113" class="md-nav__link">
    11.1.3 堆排序步骤图解说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1114" class="md-nav__link">
    11.1.4 堆排序代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112" class="md-nav__link">
    11.2 赫夫曼树
  </a>
  
    <nav class="md-nav" aria-label="11.2 赫夫曼树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1121" class="md-nav__link">
    11.2.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1122" class="md-nav__link">
    11.2.2 赫夫曼树几个重要概念和举例说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1123" class="md-nav__link">
    11.2.3 赫夫曼树创建思路图解
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113" class="md-nav__link">
    11.3 赫夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="11.3 赫夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1131" class="md-nav__link">
    11.3.1 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1132" class="md-nav__link">
    11.3.2 原理剖析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1133-" class="md-nav__link">
    11.3.3 最佳实践-数据压缩(创建赫夫曼树)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1134-" class="md-nav__link">
    11.3.4 最佳实践-文件压缩
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1135-" class="md-nav__link">
    11.3.5 最佳实践-文件解压(文件恢复)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1136" class="md-nav__link">
    11.3.6 赫夫曼编码压缩文件注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#114" class="md-nav__link">
    11.4 二叉排序树
  </a>
  
    <nav class="md-nav" aria-label="11.4 二叉排序树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1141" class="md-nav__link">
    11.4.1 先看一个需求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1142" class="md-nav__link">
    11.4.2 解决方案分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1143" class="md-nav__link">
    11.4.3 二叉排序树介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1144" class="md-nav__link">
    11.4.4 二叉排序树创建和遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1145" class="md-nav__link">
    11.4.5 二叉排序树的删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1146" class="md-nav__link">
    11.4.6 二叉排序树的代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#115-avl" class="md-nav__link">
    11.5 平衡二叉树(AVL  树)
  </a>
  
    <nav class="md-nav" aria-label="11.5 平衡二叉树(AVL  树)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1151" class="md-nav__link">
    11.5.1 看一个案例(说明二叉排序树可能的问题)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1152" class="md-nav__link">
    11.5.2 基本介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1153-" class="md-nav__link">
    11.5.3 应用案例-单旋转(左旋转)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1154-" class="md-nav__link">
    11.5.4 应用案例-单旋转(右旋转)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1155-" class="md-nav__link">
    11.5.5 应用案例-双旋转
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    十二、多路查找树
  </a>
  
    <nav class="md-nav" aria-label="十二、多路查找树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#121-b" class="md-nav__link">
    12.1 二叉树与 B  树
  </a>
  
    <nav class="md-nav" aria-label="12.1 二叉树与 B  树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1211" class="md-nav__link">
    12.1.1 二叉树的问题分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1212" class="md-nav__link">
    12.1.2 多叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1213-b" class="md-nav__link">
    12.1.3 B 树的基本介绍
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#122-2-3" class="md-nav__link">
    12.2 2-3  树
  </a>
  
    <nav class="md-nav" aria-label="12.2 2-3  树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1221-2-3-b" class="md-nav__link">
    12.2.1 2-3 树是最简单的  B  树结构,   具有如下特点:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1222-2-3" class="md-nav__link">
    12.2.2 2-3 树应用案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1223" class="md-nav__link">
    12.2.3 其它说明
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#123-b-b-b" class="md-nav__link">
    12.3 B  树、B+树和  B*树
  </a>
  
    <nav class="md-nav" aria-label="12.3 B  树、B+树和  B*树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1231-b" class="md-nav__link">
    12.3.1 B 树的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1232-b" class="md-nav__link">
    12.3.2 B 树的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1233-b" class="md-nav__link">
    12.3.3 B+树的介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1234-b" class="md-nav__link">
    12.3.4 B*树的介绍
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    十三、图
  </a>
  
    <nav class="md-nav" aria-label="十三、图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131" class="md-nav__link">
    13.1 图基本介绍
  </a>
  
    <nav class="md-nav" aria-label="13.1 图基本介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1311" class="md-nav__link">
    13.1.1 为什么要有图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1312" class="md-nav__link">
    13.1.2 图的举例说明
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1313" class="md-nav__link">
    13.1.3 图的常用概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132" class="md-nav__link">
    13.2 图的表示方式
  </a>
  
    <nav class="md-nav" aria-label="13.2 图的表示方式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1321" class="md-nav__link">
    13.2.1 邻接矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1322" class="md-nav__link">
    13.2.2 邻接表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133" class="md-nav__link">
    13.3 图的快速入门案例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#134" class="md-nav__link">
    13.4 图的深度优先遍历介绍
  </a>
  
    <nav class="md-nav" aria-label="13.4 图的深度优先遍历介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1341" class="md-nav__link">
    13.4.1 图遍历介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1342" class="md-nav__link">
    13.4.2 深度优先遍历基本思想
  </a>
  
    <nav class="md-nav" aria-label="13.4.2 深度优先遍历基本思想">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1343" class="md-nav__link">
    13.4.3 深度优先遍历算法步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#135" class="md-nav__link">
    13.5 图的广度优先遍历
  </a>
  
    <nav class="md-nav" aria-label="13.5 图的广度优先遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1351" class="md-nav__link">
    13.5.1 广度优先遍历基本思想
  </a>
  
    <nav class="md-nav" aria-label="13.5.1 广度优先遍历基本思想">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1352" class="md-nav__link">
    13.5.2 广度优先遍历算法步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#v-v" class="md-nav__link">
    访问初始结点 v  并标记结点 v  为已访问。
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#136-vs" class="md-nav__link">
    13.6 图的深度优先 VS    广度优先
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    十四、程序员常用  10  种算法
  </a>
  
    <nav class="md-nav" aria-label="十四、程序员常用  10  种算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#141" class="md-nav__link">
    14.1 二分查找算法(非递归)
  </a>
  
    <nav class="md-nav" aria-label="14.1 二分查找算法(非递归)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1411" class="md-nav__link">
    14.1.1 二分查找算法(非递归)介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1412" class="md-nav__link">
    14.1.2 二分查找算法(非递归)代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#142" class="md-nav__link">
    14.2 分治算法
  </a>
  
    <nav class="md-nav" aria-label="14.2 分治算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1421" class="md-nav__link">
    14.2.1 分治算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1422" class="md-nav__link">
    14.2.2 分治算法的基本步骤
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1423-divide-and-conquerp" class="md-nav__link">
    14.2.3 分治(Divide-and-Conquer(P))算法设计模式如下：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1424-" class="md-nav__link">
    14.2.4 分治算法最佳实践-汉诺塔
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#143" class="md-nav__link">
    14.3 动态规划算法
  </a>
  
    <nav class="md-nav" aria-label="14.3 动态规划算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1431-" class="md-nav__link">
    14.3.1 应用场景-背包问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1432" class="md-nav__link">
    14.3.2 动态规划算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1433-" class="md-nav__link">
    14.3.3 动态规划算法最佳实践-背包问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#144-kmp" class="md-nav__link">
    14.4 KMP  算法
  </a>
  
    <nav class="md-nav" aria-label="14.4 KMP  算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1441-" class="md-nav__link">
    14.4.1 应用场景-字符串匹配问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1442" class="md-nav__link">
    14.4.2 暴力匹配算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1443-kmp" class="md-nav__link">
    14.4.3 KMP  算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1444-kmp-" class="md-nav__link">
    14.4.4 KMP  算法最佳应用-字符串匹配问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#145" class="md-nav__link">
    14.5 贪心算法
  </a>
  
    <nav class="md-nav" aria-label="14.5 贪心算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1451-" class="md-nav__link">
    14.5.1 应用场景-集合覆盖问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1452" class="md-nav__link">
    14.5.2 贪心算法介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1453-" class="md-nav__link">
    14.5.3 贪心算法最佳应用-集合覆盖
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1454" class="md-nav__link">
    14.5.4 贪心算法注意事项和细节
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">数据结构和算法</h1>
<h2 id="_2">一、数据结构和算法内容介绍</h2>
<h3 id="11">1.1 几个经典算法面试题</h3>
<ul>
<li><strong>字符串匹配问题</strong>：</li>
</ul>
<p>​   1)有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好""，和一个子串 str2="尚硅谷你尚硅你"</p>
<p>​   2)现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p>
<p>​   3)要求用最快的速度来完成匹配</p>
<p>​   4)你的思路是什么？</p>
<p>​   暴力匹配（简单，但是效率低）</p>
<p>​   KMP算法《部分匹配表》</p>
<ul>
<li><strong>汉诺塔游戏</strong>,</li>
</ul>
<p>请完成汉诺塔游戏的代码: 要求：1) 将A塔的所有圆盘移动到C塔。并且规定，在2) 小圆盘上不能放大圆盘，3)在三根柱子之间一次只能移动一个圆盘</p>
<p>请完成汉诺塔游戏的代码: 要求：1) 将A塔的所有圆盘移动到C塔。并且规定，在2) 小圆盘上不能放大圆盘，3)在三根柱子之间一次只能移动一个圆盘</p>
<p><img alt="image-20230329205105241" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20230329205105241.png" /></p>
<p>​   使用分治算法</p>
<ul>
<li><strong>八皇后问题</strong>：</li>
</ul>
<p>八皇后问题，是一个古老而著名的问题，是<strong>回溯算法的典型案例</strong>。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</strong>。【92】</p>
<p><img alt="image-20220707160102271" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707160102271.png" /></p>
<p><strong>使用到回溯算法</strong></p>
<ul>
<li><strong>马踏棋盘算法</strong>：</li>
</ul>
<p>马踏棋盘算法介绍和游戏演示</p>
<p>1)马踏棋盘算法也被称为骑士周游问题</p>
<p>2)将马随机放在国际象棋的8×8棋盘Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格</p>
<p>3)会使用到<strong>图的深度优化遍历算法(DFS) + 贪心算法优化</strong></p>
<p><img alt="image-20220707160330017" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707160330017.png" /></p>
<h2 id="_3">二、数据结构和算法概述</h2>
<h3 id="21">2.1 数据结构和算法的关系</h3>
<ul>
<li>数据(data)结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。</li>
<li>要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.</li>
<li>程序 = 数据结构 + 算法</li>
<li>数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。</li>
</ul>
<h3 id="22">2.2 几个十一编程中遇到的问题</h3>
<ul>
<li><strong>字符串替换问题</strong></li>
</ul>
<p><img alt="image-20220707165419301" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707165419301.png" /></p>
<p>小结：需要使用单链表</p>
<ul>
<li><strong>五子棋程序</strong></li>
</ul>
<p><img alt="image-20220707165539624" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707165539624.png" /></p>
<p>​           如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能</p>
<p>​           棋盘  二维数组=&gt;(<strong>稀疏数组</strong>)-&gt; 写入文件 【存档功能】</p>
<p>​           读取文件-》稀疏数组-》二维数组 -》 棋盘 【接上局】</p>
<ul>
<li>
<p><strong>约瑟夫(Josephu)问题(丢手帕问题)</strong></p>
</li>
<li>
<p>Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
</li>
<li>
<p>提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表（<strong>单向环形链表</strong>），然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
</li>
<li>
<p>小结：完成约瑟夫问题，需要用到<strong>单向环形链表</strong>这个数据结构</p>
</li>
<li>
<p>其他常见算法问题：</p>
</li>
</ul>
<p><img alt="image-20220707170344126" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707170344126.png" /></p>
<ul>
<li><strong>修路问题</strong> =&gt; 最小生成树(加权值)【数据结构】+ 普利姆算法</li>
<li><strong>最短路径问题</strong> =&gt; 图+弗洛伊德算法</li>
<li><strong>汉诺塔</strong> <strong>=&gt;</strong> 分支算法</li>
<li><strong>八皇后问题</strong> =&gt; 回溯法</li>
</ul>
<h3 id="23">2.3 线性结构和非线性结构</h3>
<ul>
<li><strong>线性结构</strong>：</li>
<li>线性结构作为最常用的数据结构，其特点是<strong>数据元素之间存在一对一</strong>的线性关系</li>
<li>线性结构有两种不同的存储结构，即<strong>顺序存储结构和链式存储结构</strong>。顺序存储的线性表称为顺序表，顺序表中的<strong>存储元素是连续</strong>的</li>
<li>链式存储的线性表称为链表，链表中的<strong>存储元素不一定是连续</strong>的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>
<p>线性结构常见的有：<strong>数组</strong>、<strong>队列</strong>、<strong>链表和栈</strong></p>
</li>
<li>
<p><strong>非线性结构</strong>：</p>
</li>
<li>非线性结构包括：二维数组，多维数组，广义表，<strong>树结构，图结构</strong></li>
</ul>
<h2 id="_4">三、稀疏数组和队列</h2>
<h3 id="31-sparsearray">3.1 稀疏sparsearray数组</h3>
<ul>
<li>
<p><img alt="image-20220707171826929" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707171826929.png" /></p>
</li>
<li>
<p>基本介绍：</p>
</li>
<li>
<p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组</p>
</li>
<li>
<p>稀疏数组的处理方法：</p>
<ul>
<li>记录数组<strong>一共有几行几列，有多少个不同</strong>的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<strong>缩小程序</strong>的规模</li>
</ul>
</li>
<li>
<p>举例说明：</p>
</li>
</ul>
<p><img alt="image-20220707172201679" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707172201679.png" /></p>
<ul>
<li>
<p>应用实例：</p>
</li>
<li>
<p>使用稀疏数组，保留类似前面的二维数组（棋盘、地图等）</p>
</li>
<li>
<p>把稀疏数组存盘，并且可以重新恢复原来的二维数组</p>
<p><img alt="image-20220707173148669" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220707173148669.png" /></p>
</li>
<li>
<p>二维数组 转 稀疏数组的思路：</p>
<ol>
<li>遍历原始的二维数组，得到有效数据的个数 sum</li>
<li>根据sum就可以创建稀疏数组sparseArr int[sum+1] [3]</li>
<li>将二维数组的有效数据存入到稀疏数组</li>
</ol>
</li>
<li>
<p>稀疏数组 转 原始二维数组：</p>
<ol>
<li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr = int [11] [11]</li>
<li>再读取稀疏数组后几行的数据，并赋值给原始的二维数组</li>
</ol>
</li>
</ul>
<p>代码如下：</p>
<p>```java
  /*<em>
   * 稀疏数组
   * 使用稀疏数组，保留类似前面的二维数组（棋盘、地图等）
   * 把稀疏数组存盘，并且可以重新恢复原来的二维数组
   </em>/
  public class SparseArr {
      public static void main(String[] args) {
          //1表示黑子，2表示蓝子，0表示无棋子
          int[][] chessArr1 = new int[11][11];
          chessArr1[1][2] = 1;
          chessArr1[2][3] = 2;</p>
<pre><code>      /**
       * 二维数组 转 稀疏数组
       * 1. 遍历原始的二维数组，得到有效数据的个数 sum
       * 2. 根据sum就可以创建稀疏数组sparseArr int[sum+1] [3]
       * 3. 将二维数组的有效数据存入到稀疏数组
       */
      int sum = 0;
      for (int[] arr : chessArr1) {
          for (int item : arr) {
              System.out.printf("%d\t", item);
              if (item != 0) {
                  sum++;
              }
          }
          System.out.println();
      }
      System.out.println(sum);

      //创建稀疏数组
      int[][] sparseArr = new int[sum + 1][3];
      sparseArr[0][0] = chessArr1.length;
      sparseArr[0][1] = chessArr1[0].length;
      sparseArr[0][2] = sum;
      //将原始数组非0数据存入稀疏数组中
      int count = 0;
      for (int i = 0; i &lt; chessArr1.length; i++) {
          for (int j = 0; j &lt; chessArr1[i].length; j++) {
              if (chessArr1[i][j] != 0) {
                  count++;
                  sparseArr[count][0] = i;
                  sparseArr[count][1] = j;
                  sparseArr[count][2] = chessArr1[i][j];

              }
          }
      }

      System.out.println();
      System.out.println("稀疏数组===========");
      for (int[] arr : sparseArr) {
          for (int item : arr) {
              System.out.printf("%d\t", item);
          }
          System.out.println();
      }


      /**
       * 用BufferedWriter写入稀疏数组到磁盘中
       */
      BufferedWriter writer = null;
      try {
          writer = new BufferedWriter(new FileWriter("data-structure/src/sparsearr/map.data"));
          for (int[] ints : sparseArr) {
              String str = ints[0] + " " + ints[1] + " " + ints[2] + "\n";
              writer.write(str);
          }
          writer.flush();
      } catch (IOException e) {
          throw new RuntimeException(e);
      } finally {
          if (writer != null) {
              try {
                  writer.close();
              } catch (IOException e) {
                  throw new RuntimeException(e);
              }
          }
      }


      /**
       * 将稀疏数组还原成二维数组
       * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr = int [11] [11]
       * 2. 再读取稀疏数组后几行的数据，并赋值给原始的二维数组
       */

      /**
       * 用BufferedReader读取sparse.data中的数据
       */
      BufferedReader reader = null;
      int[][] chessArr2 = null;
      try {
          reader = new BufferedReader(new FileReader("data-structure/src/sparsearr/map.data"));
          //将第一行数据读取出来，并且分割
          String[] temp = reader.readLine().split(" ");
          chessArr2 = new int[Integer.parseInt(temp[0])][Integer.parseInt(temp[1])];
          String str;
          //从第二行开始读取，
          while ((str = reader.readLine()) != null) {
              /**
               * 将读取到的数据分割后得到String数组
               * temp[0]就是原数组有效数据的行数，temp[1]就是原数组有效数据的列数，temp[2]就是有效数据的数值
               */
              temp = str.split(" ");
              chessArr2[Integer.parseInt(temp[0])][Integer.parseInt(temp[1])] = Integer.parseInt(temp[2]);
          }
      } catch (IOException e) {
          throw new RuntimeException(e);
      } finally {
          if (reader != null) {
              try {
                  reader.close();
              } catch (IOException e) {
                  throw new RuntimeException(e);
              }
          }
      }


      System.out.println();
      System.out.println("恢复后的二维数组=========");
      for (int[] arr : chessArr2) {
          for (int item : arr) {
              System.out.printf("%d\t", item);
          }
          System.out.println();
      }
  }
</code></pre>
<p>}
  ```</p>
<h3 id="32">3.2 队列</h3>
<p>使用场景：银行排队的案例</p>
<p><img alt="image-20220708184646167" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220708184646167.png" /></p>
<p>队列介绍：</p>
<ol>
<li>
<p>队列是一个<strong>有序</strong>队列，可以用<strong>数组</strong>或是<strong>链表</strong>来实现</p>
</li>
<li>
<p>遵循先入先出的原则。即：<strong>先存入队列的数据，要先取出。后存入的要后取出</strong></p>
</li>
</ol>
<p><img alt="image-20220708184804825" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220708184804825.png" /></p>
<h4 id="321">3.2.1 数组模拟队列思路：</h4>
<ul>
<li>
<p>队列本身是有序队列，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量</p>
</li>
<li>
<p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front以及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据的输入而改变，如图：</p>
</li>
</ul>
<p><img alt="image-20220708185018127" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220708185018127.png" /></p>
<ul>
<li>
<p>当我们将数据存入队列时称为“addQueue”，addQueue的处理需要有两个步骤：</p>
</li>
<li>
<p>将尾指针往后移：rear+1，当front==rear [空]</p>
</li>
<li>
<p>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。</p>
<p>rear==maxSize-1 [队列满]</p>
</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class ArrayQueue {
    private final int maxSize;    //数组的最大容量
    private int front;      //指向数组的头部
    private int rear;       //指向数组的尾部
    private final int[] arr;      //用于存放数据，模拟队列

    public ArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        front = -1; //指向头部，初始化队列，无数据
        rear = -1;  //指向尾部
        arr = new int[maxSize];
    }

    /**
     * 判断队列是否满
     */
    public boolean isFull() {
        return rear == maxSize - 1;
    }

    /**
     * 判断队列是否为空
     */
    public boolean isEmpty() {
        return front == rear;
    }

    /**
     * 往队列中添加数据
     */
    public void addQueue(int data) {
        if (isFull()) {
            throw new RuntimeException(&quot;队列已满，无法添加数据&quot;);
        }
        rear++;
        arr[rear] = data;
    }

    /**
     * 取出队列数据
     */
    public int getQueue() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;队列为空，无法取出数据&quot;);
        }
        front++;
        return arr[front];
    }

    /**
     * 显示队列的全部数据
     */
    public void showQueue() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;队列为空&quot;);
        }
        for (int i = front + 1; i &lt;= rear; i++) {
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);
        }
    }

    /**
     * 获取队列头
     */
    public int getHead() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;队列为空&quot;);
        }
        return arr[front + 1];
    }

}
</code></pre>
<p>问题分析并优化：</p>
<ol>
<li>目前数组使用一次就不能再使用，没有达到复用的效果</li>
<li>将这个数组使用算法，改进成一个<strong>环形的队列</strong>  取模：%</li>
</ol>
<h4 id="322">3.2.2 数组模拟环形队列</h4>
<p>对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形的（通过<strong>取模的方式</strong>来实现）</p>
<p>分析：</p>
<ol>
<li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意</li>
</ol>
<p>(rear + 1) % maxSize == front [满]</p>
<ol>
<li>rear == front  [空]</li>
</ol>
<p>思路：</p>
<ol>
<li>front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素</li>
</ol>
<p>front的初始值=0</p>
<ol>
<li>rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为需要空出一个空间作为约定</li>
</ol>
<p>rear的初始值=0</p>
<ol>
<li>
<p>当队列满时，条件是：<strong>(rear + 1) % maxSize == front</strong> [满]</p>
</li>
<li>
<p>当队列空，条件是：<strong>rear == front</strong></p>
</li>
<li>
<p>队列中有效数据的个数：<strong>(rear + maxSize - front) % maxSize</strong></p>
</li>
</ol>
<p>代码实现：</p>
<pre><code class="language-java">public class CircleArrayQueue {
    private final int maxSize;    //数组的最大容量
    //front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素
    //front的初始值=0
    private int front;
    //rear指向队列的最后一个元素的后一个位置，因为需要空出一个空间作为约定
    //rear的初始值=0
    private int rear;
    private final int[] arr;      //用于存放数据，模拟队列

    public CircleArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = 0;
        rear = 0;
    }

    /**
     * 判断队列是否满
     */
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
    }

    /**
     * 判断队列是否为空
     */
    public boolean isEmpty() {
        return front == rear;
    }

    /**
     * 往队列中添加数据
     */
    public void addQueue(int data) {
        if (isFull()) {
            throw new RuntimeException(&quot;队列已满，无法添加数据&quot;);
        }
        arr[rear] = data;
        rear = (rear + 1) % maxSize;
    }

    /**
     * 取出队列数据
     */
    public int getQueue() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;队列为空，无法取出数据&quot;);
        }
        //取出队列第一个数据
        //先将第一个数据用temp存放起来，然后
        int temp = arr[front];
        front = (front + 1) % maxSize;
        return  temp;
    }

    /**
     * 显示队列的全部数据
     */
    public void showQueue() {
        if (isEmpty()) {
            System.out.println(&quot;队列为空&quot;);
            return;
        }
        for (int i = front; i &lt; front + size(); i++) {
            System.out.printf(&quot;arr[%d]=%d\n&quot;, i % maxSize, arr[i % maxSize]);
        }
    }

    /**
     * 队列有效数据的个数
     */
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }

    /**
     * 获取队列头
     */
    public int getHead() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;队列为空&quot;);
        }
        return arr[front];
    }
}

测试如下：
public class CircleArrayQueueTest {
    public static void main(String[] args) {
        CircleArrayQueue queue = new CircleArrayQueue(4);   //实际上有效数据只能放3个，有一个是留出来做约定的
        Scanner sc = new Scanner(System.in);
        char key = ' '; //接受用户输入
        while (true) {
            System.out.println(&quot;s(show)：显示队列&quot;);
            System.out.println(&quot;e(exit)：退出程序&quot;);
            System.out.println(&quot;a(add)：添加数据到队列&quot;);
            System.out.println(&quot;g(get)：从队列中取出数据&quot;);
            System.out.println(&quot;h(head)：查看队列头数据&quot;);
            key = sc.next().charAt(0);
            if (key == 's') {
                queue.showQueue();
            } else if (key == 'a') {
                System.out.println(&quot;请输入要添加的数字:&quot;);
                queue.addQueue(sc.nextInt());
            } else if (key == 'g') {
                System.out.println(queue.getQueue());
            } else if (key == 'h') {
                System.out.println(queue.getHead());
            } else if (key == 'e') {
                break;
            } else {
                System.out.println(&quot;请输入正确的字母&quot;);
            }

        }
    }
}
</code></pre>
<h2 id="_5">四、链表</h2>
<p>链表(Linked List)介绍 </p>
<p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img alt="image-20220711194958989" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220711194958989.png" /></p>
<p>小结：</p>
<ol>
<li>
<p>链表是以节点的方式来存储的，是链式存储</p>
</li>
<li>
<p>每个节点包含data域、next域：指向下一个节点</p>
</li>
<li>
<p>如图：发信啊链表的各个节点不一定是连续存储</p>
</li>
<li>
<p>链表分带头节点的链表和没有头结点的链表，根据实际的需求来确定</p>
</li>
</ol>
<p><img alt="image-20220711195139138" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220711195139138.png" /></p>
<h3 id="41">4.1 单链表的应用实例</h3>
<p>使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作</p>
<ul>
<li>
<p>添加：</p>
</li>
<li>
<p>第一种方法在添加英雄时，直接添加到链表的尾部</p>
</li>
</ul>
<p>添加思路：</p>
<ol>
<li>先创建一个head头节点，作用就是表示单链表的头</li>
<li>后面每添加一个节点，就直接加入到链表的最后</li>
</ol>
<p>遍历：</p>
<p>通过一个辅助的变量遍历，帮助遍历整个链表</p>
<p><img alt="image-20220711195543294" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220711195543294.png" /></p>
<ul>
<li>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)</li>
</ul>
<p>思路：</p>
<ol>
<li>首先找到新添加的节点的位置，通过辅助变量遍历来确定</li>
<li>新的节点.next = temp.next</li>
<li>将temp.next = 新节点</li>
</ol>
<p><img alt="image-20220711195725325" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220711195725325.png" /></p>
<ul>
<li>
<p>修改节点</p>
</li>
<li>
<p>思路：</p>
<ol>
<li>
<p>通过遍历，找到该节点</p>
</li>
<li>
<p>temp.name = newNode.name;</p>
</li>
</ol>
<p>temp.nickName = newNode.nickname;</p>
</li>
<li>
<p>删除节点</p>
</li>
<li>
<p>思路：</p>
<ol>
<li>
<p>找到该节点</p>
</li>
<li>
<p>temp.next = temp.next.next</p>
</li>
<li>
<p>被删除的节点将不会有其他引用指向，会被垃圾回收机制回收</p>
</li>
</ol>
<p><img alt="image-20220711200303736" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220711200303736.png" /></p>
</li>
</ul>
<p>全部代码如下：</p>
<pre><code class="language-java">/**
 * 单链表
 */
public class SingleLinkedList {
    private final SingleLinkedListNode head = new SingleLinkedListNode();

    /**
     * 添加节点到单向链表
     * 当不考虑编号顺序时；
     * 1、找到当前节点的最后节点
     * 2、将最后节点的next节点指向添加的节点
     */
    public void add(SingleLinkedListNode node) {
        //头节点不能动，需要一个temp节点来辅助遍历链表
        SingleLinkedListNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        //程序执行到这里说明temp已经是最后节点
        temp.next = node;
    }

    /**
     * 按照编号顺序添加节点
     * 1、首先找到新添加节点的位置，是通过辅助变量遍历来了搞定
     * 2、新节点.next=temp.next
     * 3、将temp.next=新节点
     */
    public void addByOrder(SingleLinkedListNode node) {
        SingleLinkedListNode temp = head;
        while (true) {
            if (temp.next == null) { //说明temp已经到链表最后
                break;
            } else if (temp.next.no == node.no) {
                System.out.printf(&quot;编号%d已存在，添加失败\n&quot;, node.no);
                return;
            } else if (temp.next.no &gt; node.no) {
                break;
            }
            temp = temp.next;
        }
        //程序到这里说明已经找到位置
        node.next = temp.next;
        temp.next = node;
    }

    /**
     * 修改节点的信息，根据编号修改，即no不能修改
     * 说明：
     * 根据newNode的no来修改即可
     */
    public void update(SingleLinkedListNode newNode) {
        if (head.next == null) {
            System.out.println(&quot;链表为空&quot;);
            return;
        }
        SingleLinkedListNode temp = head.next;
        while (true) {
            if (temp == null) {
                System.out.printf(&quot;未找到%d编号的数据\n&quot;, newNode.no);
                return;
            }
            if (temp.no == newNode.no) {
                break;
            }
            temp = temp.next;
        }
        //程序执行到这说明找到要修改节点
        temp.name = newNode.name;
        temp.nickname = newNode.nickname;
    }

    /**
     * 删除节点
     * 根据no删除节点
     */
    public void delete(int no) {
        SingleLinkedListNode temp = head;
        while (true) {
            if (temp.next == null) {    //已经是最后一个元素，但是最后一个元素的no也不是要删除节点的no
                System.out.printf(&quot;未找到编号为%d的数据\n&quot;, no);
                return;
            }
            if (temp.next.no == no) {
                temp.next = temp.next.next;
                return;
            }
            temp = temp.next;
        }
    }

    /**
     * 显示遍历单向链表
     */
    public void list() {
        //判断该单向链表是否为空
        if (head.next == null) {
            System.out.println(&quot;链表为空&quot;);
            return;
        }
        //程序能执行到这说明该链表有除了头节点之外的节点
        //这里不让temp=head的原因是head是空节点，只为指向下一个节点，没有数据，不需要打印数据
        SingleLinkedListNode temp = head.next;
        while (temp != null) {
            System.out.println(temp);
            temp = temp.next;
        }
    }

}

class SingleLinkedListNode {
    public int no;
    public String name;
    public String nickname;
    public SingleLinkedListNode next;

    public SingleLinkedListNode() {
    }

    public SingleLinkedListNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return &quot;SingleLinkedListNode{&quot; +
                &quot;no=&quot; + no +
                &quot;, name='&quot; + name + '\'' +
                &quot;, nickname='&quot; + nickname + '\'' +
                '}';
    }
}

测试如下：
public class SingleLinkedListTest {
    public static void main(String[] args) {
        SingleLinkedList hero = new SingleLinkedList();
        //没按顺序
        //hero.add(new SingleLinkedListNode(1,&quot;宋江&quot;,&quot;及时雨&quot;));
        //hero.add(new SingleLinkedListNode(3,&quot;吴用&quot;,&quot;智多星&quot;));
        //hero.add(new SingleLinkedListNode(4,&quot;林冲&quot;,&quot;豹子头&quot;));
        //hero.add(new SingleLinkedListNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;));

        //按顺序
        hero.addByOrder(new SingleLinkedListNode(1,&quot;宋江&quot;,&quot;及时雨&quot;));
        hero.addByOrder(new SingleLinkedListNode(3,&quot;吴用&quot;,&quot;智多星&quot;));
        hero.addByOrder(new SingleLinkedListNode(4,&quot;林冲&quot;,&quot;豹子头&quot;));
        hero.addByOrder(new SingleLinkedListNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;));

        hero.list();

        System.out.println(&quot;------------------&quot;);
        hero.delete(1);
        hero.list();

    }
}
</code></pre>
<h3 id="42">4.2 单链表面试题</h3>
<p>单链表常见面试题：</p>
<ol>
<li>求单链表中有效节点的个数</li>
</ol>
<p><code>java
   /**
    * 方法：获取单链表的节点的个数(如果是带头结点的链表，需求不统计头结点)
    *
    * @param head 链表的头结点
    * @return 有效节点的个数
    */
   public static int getLength(SingleLinkedListNode head) {
       if (head.next == null) { //空链表
           return 0;
       }
       int length = 0;
       //这里没有统计头结点
       SingleLinkedListNode temp = head.next;
       while (temp != null) {
           length++;
           temp = temp.next;
       }
       return length;
   }</code></p>
<ol>
<li>查找单链表中的倒数第K个节点(新浪面试题)</li>
</ol>
<p><code>java
   /**
    * 查找单链表中的倒数第K个节点
    *
    * @param head  链表的头结点
    * @param index 倒数第index个节点
    * @return 存在则返回该节点，不存在则返回null
    */
   public static SingleLinkedListNode findLastNode(SingleLinkedListNode head, int index) {
       if (head.next == null) {
           return null;
       }
       int length = getLength(head);   //有效节点个数
       SingleLinkedListNode temp = head.next;
       if (index &lt;= 0 || index &gt; length) {
           return null;
       }
       for (int i = 0; i &lt; length - index; i++) {
           temp = temp.next;
       }
       return temp;
   }</code></p>
<ol>
<li>单链表的反转</li>
</ol>
<p>思路分析图解：</p>
<p><img alt="image-20220713170552605" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220713170552605.png" /></p>
<p>思路：</p>
<ol>
<li>
<p>先定义一个节点reverseHead</p>
</li>
<li>
<p>从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端</p>
</li>
<li>
<p>原来的链表的head.next = reverseHead.next</p>
<p><img alt="image-20220713170717864" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220713170717864.png" /></p>
</li>
</ol>
<p><code>java
   /**
    * 反转单向链表
    */
   public static void reverseList(SingleLinkedListNode head) {
       //如果当前链表为空或当前链表只有一个有效数据，无需反转
       if (head.next == null || head.next.next == null) {
           return;
       }
       SingleLinkedListNode temp = head.next;
       SingleLinkedListNode next = null;   //为了保存temp节点的下一个节点
       SingleLinkedListNode reverseHead = new SingleLinkedListNode();
       //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端
       while (temp != null) {
           next = temp.next;   //先暂时保存当前节点的下一个节点
           temp.next = reverseHead.next;   //将temp的下一个节点指向新节点的最前端
           reverseHead.next = temp;    //将temp连接到新的链表上
           temp = next;    //temp后移，进行遍历
       }
       head.next = reverseHead.next;
   }</code></p>
<ol>
<li>从尾到头打印单链表</li>
</ol>
<p>思路分析图解：</p>
<p><img alt="image-20220713170806660" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220713170806660.png" /></p>
<p>思路：</p>
<ol>
<li>方式1：先将单链表进行反转，然后再进行遍历，这样做的问题是会破坏原来的单链表的结构，<strong>不建议</strong></li>
<li>方式2：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印</li>
</ol>
<p><code>java
   /**
    * 逆序打印单向链表
    * 利用栈Stack这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印
    */
   public static void reversePrint(SingleLinkedListNode head){
       if (head.next == null){
           return;
       }
       //创建一个栈，将各个节点压入栈中
       Stack&lt;SingleLinkedListNode&gt; stack = new Stack&lt;&gt;();
       SingleLinkedListNode temp = head.next;
       //将所有节点压入栈中
       while (temp != null){
           stack.push(temp);
           temp = temp.next;
       }
       //将栈中的节点打印，pop出栈
       while (stack.size() &gt; 0){
           System.out.println(stack.pop());
       }
   }</code></p>
<ol>
<li>合并两个有序的单链表，合并之后的链表依然有序</li>
</ol>
<p>```java
   /*<em>
    * 合并两个有序单链表，合并之后的链表依然有序
    </em>/
   public static SingleLinkedList mergeList(SingleLinkedList list1, SingleLinkedList list2){
       SingleLinkedListNode head1 = list1.getHead();
       SingleLinkedListNode head2 = list2.getHead();</p>
<pre><code>   if (head1 == null || head2 == null){
       return null;
   }

   SingleLinkedListNode temp = head2.next;
   SingleLinkedListNode next = null;
   while (temp != null){
       next = temp.next;
       temp.next = null;
       list1.addByOrder(temp);
       temp = next;
   }
   return list1;
</code></pre>
<p>}
   ```</p>
<h3 id="43">4.3 双向链表应用实例</h3>
<ul>
<li>
<p>操作分析和实现：</p>
</li>
<li>
<p>使用带 head 头的双向链表---水浒英雄排行榜 </p>
</li>
<li>
<p>单向链表的缺点分析：</p>
<ol>
<li>单向链表，查找的方向只能是一个方向，二双向链表可以向前或向后查找</li>
<li>单向链表不能自我删除，需要考辅助节点，而双向链表则可以自我删除，所以前面我们单链表删除节点时，需要找到temp，temp是待删除节点的前一个节点</li>
</ol>
<p><img alt="image-20220719163700182" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220719163700182.png" /></p>
<ol>
<li>
<p><strong>遍历：</strong>和单链表一样，只是可以向前，也可以向后查找</p>
</li>
<li>
<p><strong>添加：</strong>（默认添加到双向链表的最后）</p>
</li>
<li>
<p>先找到双向链表的最后节点</p>
</li>
<li>temp.next = newNode</li>
<li>
<p>newNode.pre = temp</p>
</li>
<li>
<p><strong>修改：</strong>思路和单向链表一样</p>
</li>
<li>
<p><strong>删除：</strong></p>
</li>
<li>
<p>因为是双向链表，因此我们可以实现自我删除某个节点</p>
</li>
<li>直接找到要删除的节点，比如temp</li>
<li>temp.pre.next = temp.next</li>
<li>temp.next.pre = temp.pre</li>
</ol>
<p>代码实现：</p>
<p>```java</p>
<p>public class DoubleLinkedList {
       private DoubleLinkedListNode head = new DoubleLinkedListNode();</p>
<pre><code>   //返回头结点
   public DoubleLinkedListNode getHead() {
       return head;
   }

   /**
    * 添加节点到双向链表最后
    */
   public void add(DoubleLinkedListNode node) {
       DoubleLinkedListNode temp = head;
       while (temp.next != null) {
           temp = temp.next;
       }
       temp.next = node;
       node.pre = temp;
   }

   /**
    * 按编号顺序添加节点到双向链表
    */
   public void addByOrder(DoubleLinkedListNode node) {
       DoubleLinkedListNode temp = head;
       while (true) {
           if (temp.next == null) {
               break;
           }
           if (temp.next.no &gt; node.no) {
               break;
           }
           if (temp.next.no == node.no) {
               System.out.printf("编号%d已存在，添加失败\n", node.no);
               return;
           }
           temp = temp.next;
       }
       node.next = temp.next;
       temp.next = node;
       node.pre = temp;

   }

   /**
    * 修改节点的信息，根据编号修改，即no不能修改
    */
   public void update(DoubleLinkedListNode newNode) {
       if (head.next == null) {
           System.out.println("链表为空");
           return;
       }
       DoubleLinkedListNode temp = head.next;
       while (true) {
           if (temp == null) {
               System.out.printf("未找到%d编号的数据\n", newNode.no);
               return;
           }
           if (temp.no == newNode.no) {
               break;
           }
           temp = temp.next;
       }
       //程序执行到这说明找到要修改节点
       temp.name = newNode.name;
       temp.nickname = newNode.nickname;
   }

   /**
    * 删除节点
    */
   public void delete(int no) {
       if (head.next == null) {
           System.out.println("链表为空");
           return;
       }
       DoubleLinkedListNode temp = head.next;
       while (true) {
           if (temp == null) {
               System.out.printf("未找到编号为%d的数据\n", no);
               return;
           }
           if (temp.no == no) {
               if (temp.next != null) {
                   temp.next.pre = temp.pre;
                   temp.pre.next = temp.next;
               } else {
                   temp.pre.next = null;
               }
               return;
           }
           temp = temp.next;
       }
   }

   /**
    * 遍历双向链表
    */
   public void list() {
       if (head.next == null) {
           System.out.println("链表为空");
           return;
       }
       DoubleLinkedListNode temp = head.next;
       while (temp != null) {
           System.out.println(temp);
           temp = temp.next;
       }
   }
</code></pre>
<p>}</p>
<p>class DoubleLinkedListNode {
       public int no;
       public String name;
       public String nickname;
       public DoubleLinkedListNode next;   //默认为null
       public DoubleLinkedListNode pre;    //指向上一个节点，默认为null</p>
<pre><code>   public DoubleLinkedListNode() {
   }

   public DoubleLinkedListNode(int no, String name, String nickname) {
       this.no = no;
       this.name = name;
       this.nickname = nickname;
   }

   @Override
   public String toString() {
       return "DoubleLinkedListNode{" +
               "no=" + no +
               ", name='" + name + '\'' +
               ", nickname='" + nickname + '\'' +
               '}';
   }
</code></pre>
<p>}</p>
<p>```</p>
</li>
</ul>
<h3 id="44">4.4 单向环形链表应用场景</h3>
<ul>
<li>Josephu(约瑟夫、约瑟夫环) 问题</li>
</ul>
<p>Josephu 问题为：</p>
<p>​ 设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从1开始报数，数 到 m 的那个人出列，它的下一位又从1开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。 </p>
<p>​ 提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由k结点起从1开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。</p>
<p>示意图：</p>
<p><img alt="image-20220719165435945" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220719165435945.png" /></p>
<ul>
<li>单向环形链表介绍</li>
</ul>
<p><img alt="image-20220719165309553" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220719165309553.png" /></p>
<p>Josephu(约瑟夫、约瑟夫环) 问题代码实现：</p>
<pre><code class="language-java">/**
 * 单向环形链表
 */
public class CircularLinkedList {
    private Node first;

    public CircularLinkedList(int num) {
        if (num &lt; 1) {
            System.out.println(&quot;参数至少为1&quot;);
            return;
        }
        first = new Node(1);
        first.next = first;
        Node temp = first;
        int tempNum = 2;
        while (tempNum &lt;= num) {
            Node cur = new Node(tempNum);
            temp.next = cur;
            cur.next = first;
            temp = temp.next;
            tempNum++;
        }
    }

    public void list() {
        if (first == null) {
            System.out.println(&quot;该链表为空&quot;);
            return;
        }
        Node temp = first;
        while (true) {
            System.out.println(temp);
            if (temp.next == first) {
                break;
            }
            temp = temp.next;
        }
    }


    /**
     * 根据用户输入，计算出圈顺序
     *
     * @param startNo  表示从第几个开始数
     * @param countNum 表示数几下
     * @param sum      表示最初有几个人
     */
    public void out(int startNo, int countNum, int sum) {
        if (first == null || startNo &lt; 1 || startNo &gt; sum) {
            System.out.println(&quot;参数错误&quot;);
            return;
        }
        Node temp = first;
        for (int i = 0; i &lt; startNo - 1; i++) {
            temp = temp.next;
        }
        while (temp.next != temp) {
            for (int i = 0; i &lt; countNum - 2; i++) {
                temp = temp.next;
            }
            System.out.println(temp.next);  //出圈
            temp.next = temp.next.next;
            temp = temp.next;
        }
        System.out.println(temp);
    }
}

class Node {
    public int no;
    public Node next;

    @Override
    public String toString() {
        return &quot;Node{&quot; +
                &quot;no=&quot; + no +
                '}';
    }

    public Node() {
    }

    public Node(int no) {
        this.no = no;
    }
}
</code></pre>
<h2 id="_6">五、栈</h2>
<h3 id="51">5.1 栈的一个实际需求</h3>
<p>请输入一个表达式
计算式:[7<em>2</em>2-5+1-5+3-3]   点击计算【如下图】</p>
<p><img alt="image-20230318190234815" src="../assets/image-20230318190234815.png" /></p>
<p>请问:    计算机底层是如何运算得到结果的？注意不是简单的把算式列出运算,因为我们看这个算式    7  *  2  *  2  - 5,    但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题。-&gt;    栈</p>
<h3 id="52">5.2 栈的介绍</h3>
<ol>
<li>
<p>栈的英文为：stack</p>
</li>
<li>
<p>栈是一个<strong>先入后出</strong>的有序列表。</p>
</li>
<li>
<p>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为<strong>变化的一端，称为栈顶</strong>(Top)，另一端为<strong>固定的一端，称为栈底</strong>(Bottom)。</p>
</li>
<li>
<p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
</li>
<li>
<p>图解方式说明出栈(pop)和入栈(push)的概念</p>
</li>
</ol>
<p><img alt="image-20220729112913358" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220729112913358.png" /></p>
<h3 id="53">5.3 栈的应用场景</h3>
<ol>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换 [中缀表达式转后缀表达式] 与求值(实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth  一  first)搜索法。</li>
</ol>
<h3 id="54">5.4 栈的快速入门</h3>
<ol>
<li>
<p>用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。</p>
</li>
<li>
<p>实现思路分析,并画出示意图</p>
</li>
</ol>
<p><img alt="image-20220729151626674" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220729151626674.png" /></p>
<ol>
<li>代码实现</li>
</ol>
<p>```java
   public class ArrayStack {
       private final int maxSize;    // 栈的最大空间
       private int top;    // 栈顶
       private final int[] stack;    // 用数组模拟栈</p>
<pre><code>   public ArrayStack(int maxSize) {
       top = -1;
       this.maxSize = maxSize;
       stack = new int[maxSize];
   }

   // 判断是否满
   public boolean isFull() {
       return top == maxSize - 1;
   }

   //判断是否空
   public boolean isEmpty(){
       return top == -1;
   }

   //入栈
   public void push(int value){
       if (isFull()){
           System.out.println("栈满，无法添加数据");
           return;
       }
       stack[++top] = value;
   }

   //弹栈
   public int pop(){
       if (isEmpty()){
           throw new RuntimeException("栈空，无法弹出数据");
       }
       int value = stack[top];
       top--;
       return value;
   }

   //遍历栈，从栈顶开始遍历
   public void list(){
       if (isEmpty()){
           System.out.println("栈空");
           return;
       }
       for (int i = top; i &gt;= 0; i--) {
           System.out.printf("stack[%d]=%d\n", i, stack[i]);
       }
   }
</code></pre>
<p>}
   ```</p>
<ol>
<li>练习：用链表模拟栈</li>
</ol>
<p>```java
   public class LinkedStack {
       private final Node head = new Node();
       private final int maxSize;
       private int top;</p>
<pre><code>   public LinkedStack(int maxSize) {
       this.maxSize = maxSize;
       top = 0;
   }

   // 判断是否空
   public boolean isEmpty() {
       return head.next == null;
   }

   // 判断是否满
   public boolean isFull() {
       return top == maxSize;
   }

   // 入栈
   public void push(int value) {
       if (isFull()) {
           System.out.println("栈已满");
           return;
       }
       Node temp = head;
       while (temp.next != null) {
           temp = temp.next;
       }
       top++;
       temp.next = new Node(value);
   }

   // 弹栈
   public int pop() {
       if (isEmpty()) {
           throw new RuntimeException("栈空");
       }
       if (head.next.next == null) {    // 如果只剩一个元素
           int value = head.next.value;
           top--;
           head.next = null;
           return value;
       }
       Node temp = head;
       while (temp.next.next != null) {
           temp = temp.next;
       }
       int value = temp.next.value;
       top--;
       temp.next = null;
       return value;
   }

   // 遍历
   public void list() {
       if (isEmpty()) {
           System.out.println("栈空");
           return;
       }
       LinkedStack stack = new LinkedStack(maxSize);
       Node temp = head;
       while (temp.next != null){
           stack.push(temp.next.value);
           temp = temp.next;
       }
       while (!stack.isEmpty()){
           System.out.printf("第%d个元素：%d\n", stack.top, stack.pop());
       }
   }
</code></pre>
<p>}</p>
<p>class Node {
       protected int value;
       protected Node next;</p>
<pre><code>   public Node() {
   }

   public Node(int value) {
       this.value = value;
   }
</code></pre>
<p>}
   ```</p>
<h3 id="55">5.5 栈实现综合计算器(中缀表达式)</h3>
<p><img alt="image-20220729202514377" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220729202514377.png" /></p>
<p>代码实现：</p>
<p>思路：将所有 ‘ - ’ 号运算的数字变为负数，将 ‘ - ’ 改为 ‘ + ’</p>
<pre><code class="language-java">import java.util.Scanner;

public class CalculatorTest {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String expression = sc.next();
        CalculatorArrayStack numStack = new CalculatorArrayStack(10);   // 数栈
        CalculatorArrayStack operatorStack = new CalculatorArrayStack(10);   // 符号栈
        int index = 0;  // 当前索引
        int num1 = 0;   // 取出的第一个数字
        int num2 = 0;   // 取出的第二个数字
        int operator = 0;    // 取出的符号
        int result = 0; // 计算得到的值
        char ch = ' ';
        String str = &quot;&quot;;

        // 开始扫描
        while (true) {
            ch = expression.charAt(index);

            if (operatorStack.isOperator(ch)) { // 如果是扫描到的是符号
                if (operatorStack.isEmpty()) {  // 判断符号栈是否为空
                    if (ch == '-'){
                        operatorStack.push('+');
                    }else {
                        operatorStack.push(ch);
                    }
                } else {    // 如果不是空,判断优先级
                    // 如果当前得到的符号的优先级比符号栈顶的优先级低
                    // 则先从数栈中弹出两个数字，在从符号栈中弹出一个符号，进行运算
                    // 得到的结果再压入到数栈中，再将当前符号压入符号栈
                    if (operatorStack.priority(ch) &lt;= operatorStack.priority(operatorStack.getTopVal())) {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        operator = operatorStack.pop();
                        result = numStack.cal(num1, num2, operator);

                        numStack.push(result);
                        if (ch == '-'){     //判断是否为符号，为符号则添加为'+'
                            operatorStack.push('+');
                        }else {
                            operatorStack.push(ch);
                        }
                    } else { // 如果当前得到的符号的优先级比符号栈顶的优先级高
                        // 直接压入符号栈
                        operatorStack.push(ch);
                    }
                }
            } else { // 如果扫描到的是数字
                // numStack.push(ch);
                // 判断ch后一位是否为运算符，若不是运算符则需要字符串拼接，并且继续扫描
                str += ch;
                if (index == expression.length() - 1) { // 如果遍历到字符串的最后一位则可以直接入栈
                    numStack.push(Integer.parseInt(str));
                } else {
                    char temp = expression.charAt(index + 1);
                    //如果下一个运算符是'-'，则将下一个字符串以&quot;-&quot;号开头，使得下一个数字成为负数
                    if (operatorStack.isOperator(temp) &amp;&amp; temp == '-') {
                        numStack.push(Integer.parseInt(str));
                        str = &quot;-&quot;;   // 一定要让str置为空，否则数字将累加
                    } else if (operatorStack.isOperator(temp)) {
                        numStack.push(Integer.parseInt(str));
                        str = &quot;&quot;;
                    }
                }
            }

            index++;
            if (index &gt;= expression.length()) {
                break;
            }
        }
        // 表达式扫描完毕，按顺序从数栈和符号栈中pop出剩下的元素，并运算
        while (!operatorStack.isEmpty()) {
            num1 = numStack.pop();
            num2 = numStack.pop();
            operator = operatorStack.pop();
            result = numStack.cal(num1, num2, operator);
            numStack.push(result);
        }
        System.out.printf(&quot;表达式 %s = %d&quot;, expression, numStack.pop());
    }
}


public class CalculatorArrayStack {
    private final int maxSize;    // 栈的最大空间
    private int top;    // 栈顶
    private final int[] stack;    // 用数组模拟栈

    public CalculatorArrayStack(int maxSize) {
        top = -1;
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    // 判断是否满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    // 判断是否空
    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(int value) {
        if (isFull()) {
            System.out.println(&quot;栈满，无法添加数据&quot;);
            return;
        }
        stack[++top] = value;
    }

    // 拿到栈顶的值
    public int getTopVal() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;栈空，无法弹出数据&quot;);
        }
        return stack[top];
    }

    //拿到栈顶的下一个的值
    public int getTopNextVal(){
        if (isEmpty()){
            throw new RuntimeException(&quot;栈空，无法弹出数据&quot;);
        } else if (top &lt; 1) {
            throw new RuntimeException(&quot;栈中仅有一个元素&quot;);
        }
        return stack[top-1];
    }

    public int getTop() {
        return top;
    }

    // 弹栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;栈空，无法弹出数据&quot;);
        }
        int value = stack[top];
        top--;
        return value;
    }

    // 遍历栈，从栈顶开始遍历
    public void list() {
        if (isEmpty()) {
            System.out.println(&quot;栈空&quot;);
            return;
        }
        for (int i = top; i &gt;= 0; i--) {
            System.out.printf(&quot;stack[%d]=%d\n&quot;, i, stack[i]);
        }
    }

    // 判断是否为符号
    public boolean isOperator(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    /**
     * 判断符号与 + - * / 的优先级
     *
     * @return 优先级高返回1， 优先级低返回0，错误返回-1
     */
    public int priority(int operator) {
        if (operator == '+' || operator == '-') {
            return 0;
        } else if (operator == '*' || operator == '/') {
            return 1;
        } else {
            return -1;
        }
    }

    // 计算
    public int cal(int num1, int num2, int operator) {
        int result = 0;
        switch (operator) {
            case '+' -&gt; result = num2 + num1;
            case '-' -&gt; result = num2 - num1;
            case '*' -&gt; result = num2 * num1;
            case '/' -&gt; result = num2 / num1;
            default -&gt; {
            }
        }
        return result;
    }
}
</code></pre>
<h3 id="56">5.6 逆波兰计算器</h3>
<p>我们完成一个逆波兰计算器，要求完成如下任务:
1)       输入一个逆波兰表达式(后缀表达式)，使用栈(Stack),    计算其结果
2) 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。
3. 思路分析</p>
<p>例如: (3+4)×5-6    对应的后缀表达式就是    3  4  + 5   ×    6  -  ,   针对后缀表达式求值步骤如下:</p>
<ol>
<li>从左至右扫描，将 3  和 4  压入堆栈；</li>
<li>遇到+运算符，因此弹出 4  和 3（4  为栈顶元素，3  为次顶元素），计算出 3+4 的值，得 7，再将  7  入栈； </li>
<li>将 5  入栈；</li>
<li>接下来是×运算符，因此弹出 5  和 7，计算出 7×5=35，将 35  入栈； </li>
<li>将 6  入栈；</li>
<li>最后是-运算符，计算出 35-6  的值，即 29，由此得出最终结果</li>
</ol>
<p>代码实现：</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

public class SuffixExpression {
    public static void main(String[] args) {
        // (3+4)*5-6
        String suffixExpression = &quot;3 4 + 5 * 6 -&quot;;
        // 定义一个方法来将suffixExpression存放到ArrayList中
        List&lt;String&gt; list = toList(suffixExpression);
        // System.out.println(list);
        int result = calculate(list);
        System.out.println(result);
    }


    /**
     * 直接将逆波兰表达式转成List
     */
    public static List&lt;String&gt; toList(String suffixExpression) {
        String[] split = suffixExpression.split(&quot; &quot;);
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list, split);
        return list;
    }

    /**
     * 将ArrayList中的元素压入栈中，并计算
     */
    public static int calculate(List&lt;String&gt; list) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        for (String item : list) {
            // 判断是否为数字，使用正则表达式
            if (item.matches(&quot;\\d+&quot;)) {      // 匹配多位数
                stack.push(item);
            } else {
                // 是运算符则从栈中弹出两个数，进行计算
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int result = switch (item) {
                    case &quot;+&quot; -&gt; num2 + num1;
                    case &quot;-&quot; -&gt; num2 - num1;
                    case &quot;*&quot; -&gt; num2 * num1;
                    case &quot;/&quot; -&gt; num2 / num1;
                    default -&gt; throw new RuntimeException(&quot;运算符有误&quot;);
                };
                // 计算完成后再将结果压入栈中
                stack.push(String.valueOf(result));
            }
        }
        // 全部计算完后，剩下的就是计算得到的结果
        return Integer.parseInt(stack.pop());
    }
}
</code></pre>
<h3 id="57">5.7 中缀表达式转换为后缀表达式</h3>
<p>后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 中缀表达式转成后缀表达式。</p>
<p>实现步骤如下：</p>
<ol>
<li>初始化两个栈，运算符栈operatorStack和存储中间结果的栈numStack</li>
<li>从左到右扫描中缀表达式</li>
<li>遇到数字，将其压入numStack</li>
<li>遇到运算符，比较其与operatorStack栈顶运算符的优先级：</li>
<li>如果operatorStack为空，或者栈顶的运算符为 “ ( ” ，则之间将其压入operatorStack</li>
<li>否则，若优先级比栈顶运算符低，则将operatorStack栈顶的运算符弹出并压入到numStack中，再转到4.1操作与operatorStack新的栈顶运算符进行比较</li>
<li>若优先级比栈顶运算符高，则将运算符直接压入operatorStack中</li>
<li>遇到括号时：</li>
<li>如果是 “ ( ”，直接压入operatorStack</li>
<li>如果是 “ ) ”，则依次弹出operatorStack栈顶的运算符，并压入numStack中，直到遇到 “ ( ”，为止，此时将这对括号丢弃（  弹出当前operatorStack栈顶的 “ ( ”  ），</li>
<li>重复2-5的步骤，直到表达式的最右边</li>
<li>将operatorStack剩下的运算符依次弹出并压入numStack</li>
<li>依次弹出numStack中的元素并输出，其结果的逆序即为中缀表达式转其对应的后缀表达式</li>
</ol>
<p><strong>注：</strong>全程中numStack没有做pop操作，得到的后缀表达式结果也为numStack的逆序输出，所以可以直接用List代替numStack，作为最终后缀表达式的存储</p>
<p>举例说明：</p>
<p>将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下</p>
<p>因此结果为  :"1  2 3  +  4   ×    + 5   –"</p>
<p><img alt="image-20220731161925309" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220731161925309.png" /></p>
<p>思路分析：</p>
<p><img alt="image-20220731161936394" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220731161936394.png" /></p>
<p>代码实现：</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class InfixToSuffix {
    public static void main(String[] args) {
        // 实现将中缀表达式转成后缀表达式的功能
        // 说明
        // 1.1+((2+3)*4)-5 -&gt; 1 2 3 + 4 * + 5 -
        // 2.因为直接对字符串进行操作不方便，因此中缀表达式转成对应的List
        // 即1+((2+3)*4)-5  -&gt;  ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
        // 4.编写一个方法将ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] -&gt; ArraysList[1, 2, 3, +, 4, *, +, 5, -]
        Scanner sc = new Scanner(System.in);
        String infixExpression = sc.next();
        List&lt;String&gt; infixList = infixToList(infixExpression);
        System.out.println(&quot;中缀表达式对应的List=&quot; + infixList);
        List&lt;String&gt; suffixList = infixToSuffixList(infixList);
        System.out.println(&quot;后缀表达式对应的List=&quot; + suffixList);
        int result = calculate(suffixList);
        System.out.println(&quot;最终的结果为：&quot; + result);

    }

    /**
     * 将中缀表达式对应的List转为后缀表达式对应的List
     */
    public static List&lt;String&gt; infixToSuffixList(List&lt;String&gt; list) {
        Stack&lt;String&gt; operatorStack = new Stack&lt;&gt;();   // 符号栈
        List&lt;String&gt; numList = new ArrayList&lt;&gt;();  // 存储中间结果的，相当于最后后缀表达式对应的List
        for (String item : list) {
            if (item.matches(&quot;\\d+&quot;)) {      // 遇到数字直接加入numList
                numList.add(item);
            } else if (&quot;(&quot;.equals(item)) {      // 如果遇到“(”，直接压入符号栈
                operatorStack.push(item);
            } else if (&quot;)&quot;.equals(item)) {
                // 如果是右括号“)”，则依次弹出 符号栈 栈顶的运算符，并加入 numList ，直到遇到左括号为止，此时将这一对括号丢弃
                while (operatorStack.size() &gt; 0 &amp;&amp; !&quot;(&quot;.equals(operatorStack.peek())) {
                    numList.add(operatorStack.pop());
                }
                operatorStack.pop();    // 再将符号栈中的&quot;(&quot;弹出
            } else {     // 遇到运算符
                if (operatorStack.size() == 0 || &quot;(&quot;.equals(operatorStack.peek())) {
                    // 如果 符号栈 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
                    operatorStack.push(item);
                } else {
                    // 优先级比栈顶的低，则将符号栈中的运算符弹出并加入numList中，再与下一个栈顶的运算符进行比较
                    while (operatorStack.size() &gt; 0 &amp;&amp; operatorPriority(item) &lt;= operatorPriority(operatorStack.peek())) {
                        numList.add(operatorStack.pop());
                    }
                    // 优先级比栈顶运算符的高，也将运算符压入符号栈
                    operatorStack.push(item);
                }
            }
        }
        // 将符号栈中剩下的运算符加入numList中
        while (operatorStack.size() &gt; 0) {
            numList.add(operatorStack.pop());
        }
        return numList;
    }

    /**
     * 判读运算符优先级
     *
     * @param operator
     * @return 优先级高返回2， 优先级低返回1
     */
    public static int operatorPriority(String operator) {
        return switch (operator) {
            case &quot;+&quot;, &quot;-&quot; -&gt; 1;
            case &quot;*&quot;, &quot;/&quot; -&gt; 2;
            default -&gt; throw new RuntimeException(&quot;运算符有误&quot;);
        };
    }

    /**
     * 将中缀表达式转成对应的List
     */
    public static List&lt;String&gt; infixToList(String s) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        int index = 0;  // 指针下标
        char c;   // 该下标得到的字符
        String str;
        do {
            // 如果是非数字则直接加入到List中
            if ((c = s.charAt(index)) &lt; '0' || (c = s.charAt(index)) &gt; '9') {
                list.add(c + &quot;&quot;);
                index++;
            } else {     // 如果是数字，则要考虑多位数，进行字符串拼接
                str = &quot;&quot;;
                while (index &lt; s.length() &amp;&amp; ((c = s.charAt(index)) &gt;= '0' &amp;&amp; (c = s.charAt(index)) &lt;= '9')) {
                    str += c;
                    index++;
                }
                list.add(str);
            }
        } while (index &lt; s.length());
        return list;
    }

    /**
     * 将ArrayList中的元素压入栈中，并计算
     */
    public static int calculate(List&lt;String&gt; list) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        for (String item : list) {
            // 判断是否为数字，使用正则表达式
            if (item.matches(&quot;\\d+&quot;)) {      // 匹配多位数
                stack.push(item);
            } else {
                // 是运算符则从栈中弹出两个数，进行计算
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int result = switch (item) {
                    case &quot;+&quot; -&gt; num2 + num1;
                    case &quot;-&quot; -&gt; num2 - num1;
                    case &quot;*&quot; -&gt; num2 * num1;
                    case &quot;/&quot; -&gt; num2 / num1;
                    default -&gt; throw new RuntimeException(&quot;运算符有误&quot;);
                };
                // 计算完成后再将结果压入栈中
                stack.push(String.valueOf(result));
            }
        }
        // 全部计算完后，剩下的就是计算得到的结果
        return Integer.parseInt(stack.pop());
    }
}
</code></pre>
<h3 id="58">5.8 逆波兰计算器完整版</h3>
<p>完整版的逆波兰计算器，功能包括：</p>
<ol>
<li>支持   + - *  /  ( )</li>
<li>多位数，支持小数,</li>
<li>兼容处理,    过滤任何空白字符，包括空格、制表符、换页符</li>
</ol>
<p><strong>说明：</strong>逆波兰计算器完整版考虑的因素较多，下面给出完整版代码供同学们学习，其基本思路和前面一样，也是使用到：<strong>中缀表达式转后缀表达式</strong></p>
<p>代码实现：</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.regex.Pattern;

public class ReversePolishMultiCalc {
    /**
     * 匹配    + - *  /  ( )    运算符
     */
    static final String SYMBOL = &quot;\\+|-|\\*|/|\\(|\\)&quot;;
    static final String LEFT = &quot;(&quot;;
    static final String RIGHT = &quot;)&quot;;
    static final String ADD = &quot;+&quot;;
    static final String MINUS = &quot;-&quot;;
    static final String TIMES = &quot;*&quot;;
    static final String DIVISION = &quot;/&quot;;
    /**
     * 加減    + -
     */
    static final int LEVEL_01 = 1;
    /**
     * 乘除    *  /
     */
    static final int LEVEL_02 = 2;
    /**
     * 括号
     */
    static final int LEVEL_HIGH = Integer.MAX_VALUE;
    static Stack&lt;String&gt; stack = new Stack&lt;&gt;();
    static List&lt;String&gt; data = Collections.synchronizedList(new ArrayList&lt;String&gt;());

    /**
     * 去除所有空白符
     *
     * @param s
     * @return
     */
    public static String replaceAllBlank(String s) {
        // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
        return s.replaceAll(&quot;\\s+&quot;, &quot;&quot;);
    }

    /**
     * 判断是不是数字    int double long  float
     *
     * @param s
     * @return
     */
    public static boolean isNumber(String s) {
        Pattern pattern = Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;);
        return pattern.matcher(s).matches();
    }

    /**
     * 判断是不是运算符
     *
     * @param s
     * @return
     */
    public static boolean isSymbol(String s) {
        return s.matches(SYMBOL);
    }

    /**
     * 匹配运算等级
     *
     * @param s
     * @return
     */
    public static int calcLevel(String s) {
        if (&quot;+&quot;.equals(s) || &quot;-&quot;.equals(s)) {
            return LEVEL_01;
        } else if (&quot;*&quot;.equals(s) || &quot;/&quot;.equals(s)) {
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }

    /**
     * 匹配
     *
     * @param s
     * @throws Exception
     */
    public static List&lt;String&gt; doMatch(String s) throws Exception {
        if (s == null || &quot;&quot;.equals(s.trim())) throw new RuntimeException(&quot;data  is  empty&quot;);
        if (!isNumber(s.charAt(0) + &quot;&quot;)) throw new RuntimeException(&quot;data  illeagle,start  not  with  a number&quot;);
        s = replaceAllBlank(s);
        String each;
        int start = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            if (isSymbol(s.charAt(i) + &quot;&quot;)) {
                each = s.charAt(i) + &quot;&quot;;
                // 栈为空，( 操作符，或者    操作符优先级大于栈顶优先级    &amp;&amp;    操作符优先级不是(  )的优先级及
                // 是 ) 不能直接入栈
                if (stack.isEmpty() || LEFT.equals(each)
                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH)) {
                    stack.push(each);
                } else if (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek())) {
                    // 栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后
                    while (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek())) {
                        if (calcLevel(stack.peek()) == LEVEL_HIGH) {
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                } else if (RIGHT.equals(each)) {
                    // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek())) {
                        if (LEVEL_HIGH == calcLevel(stack.peek())) {
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start = i;                // 前一个运算符的位置
            } else if (i == s.length() - 1 || isSymbol(s.charAt(i + 1) + &quot;&quot;)) {
                each = start == 0 ? s.substring(start, i + 1) : s.substring(start + 1, i + 1);
                if (isNumber(each)) {
                    data.add(each);
                    continue;
                }
                throw new RuntimeException(&quot;data not match number&quot;);
            }
        }
        // 如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，
        // 应该依次出栈入列，可以直接翻转整个 stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList&lt;&gt;(stack));
        System.out.println(data);
        return data;
    }

    /**
     * 算出结果
     *
     * @param list
     * @return
     */
    public static Double doCalc(List&lt;String&gt; list) {
        Double d = 0d;
        if (list == null || list.isEmpty()) {
            return null;
        }
        if (list.size() == 1) {
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; list.size(); i++) {
            list1.add(list.get(i));
            if (isSymbol(list.get(i))) {
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i - 1);
                list1.set(i - 2, d1 + &quot;&quot;);
                list1.addAll(list.subList(i + 1, list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;
    }

    /**
     * 运算
     *
     * @param s1
     * @param s2
     * @param symbol
     * @return
     */
    public static Double doTheMath(String s1, String s2, String symbol) {
        Double result;
        switch (symbol) {
            case ADD:
                result = Double.valueOf(s1) + Double.valueOf(s2);
                break;
            case MINUS:
                result = Double.valueOf(s1) - Double.valueOf(s2);
                break;
            case TIMES:
                result = Double.valueOf(s1) * Double.valueOf(s2);
                break;
            case DIVISION:
                result = Double.valueOf(s1) / Double.valueOf(s2);
                break;
            default:
                result = null;
        }
        return result;
    }

    public static void main(String[] args) {
        // String  math  = &quot;9+(3-1)*3+10/2&quot;;
        String math = &quot;12.8  +  (2  - 3.55)*4+10/5.0&quot;;
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="_7">六、递归</h2>
<h3 id="61">6.1 递归应用场景</h3>
<p>看个实际应用场景，迷宫问题(回溯)，    递归(Recursion)</p>
<p><img alt="image-20220731173429800" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220731173429800.png" /></p>
<h3 id="62">6.2 递归的概念</h3>
<p>简单的说:    递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时 
可以让代码变得简洁。</p>
<h3 id="63">6.3 递归调用机制</h3>
<p>我列举两个小案例,来帮助大家理解递归，部分学员已经学习过递归了，这里在给大家回顾一下递归调用机制</p>
<ol>
<li>打印问题</li>
<li>阶乘问题</li>
<li>使用图解方式说明了递归的调用机制</li>
</ol>
<p><img alt="image-20220731173455506" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220731173455506.png" /></p>
<h3 id="64">6.4 递归能解决什么样的问题</h3>
<p>递归用于解决什么样的问题：
1. 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛)
2. 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
3. 将用栈解决的问题--&gt;第归代码比较简洁</p>
<h3 id="65">6.5 递归需要遵守的重要规则</h3>
<p>递归需要遵守的重要规则：</p>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响,    比如  n  变量</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归,出现  StackOverflowError，死龟了</li>
<li>当一个方法执行完毕，或者遇到  return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li>
</ol>
<h3 id="66-">6.6 递归-迷宫问题</h3>
<h4 id="661">6.6.1 迷宫问题</h4>
<p><img alt="image-20220801104509991" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801104509991.png" /></p>
<h4 id="662">6.6.2 代码实现:</h4>
<pre><code class="language-java">public class MiGong {
    public static void main(String[] args) {
        //   先创建一个二维数组，模拟迷宫
        //   地图
        int[][] map = new int[8][7];
        //   使用  1    表示墙
        //   上下全部置为  1
        for (int i = 0; i &lt; 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        //   左右全部置为  1
        for (int i = 0; i &lt; 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        // 设置挡板,  1    表示
        map[3][1] = 1;
        map[3][2] = 1;
        // map[1][2] = 1;
        // map[2][2] = 1;
        //   输出地图
        System.out.println(&quot;地图的情况&quot;);
        for (int i = 0; i &lt; 8; i++) {
            for (int j = 0; j &lt; 7; j++) {
                System.out.print(map[i][j] + &quot;  &quot;);
            }
            System.out.println();
        }
        // 使用递归回溯给小球找路
        // setWay(map,  1,  1);
        setWay2(map, 1, 1);
        // 输出新的地图,    小球走过，并标识过的递归
        System.out.println(&quot;小球走过，并标识过的    地图的情况&quot;);
        for (int i = 0; i &lt; 8; i++) {
            for (int j = 0; j &lt; 7; j++) {
                System.out.print(map[i][j] + &quot;  &quot;);
            }
            System.out.println();
        }
    }
    // 使用递归回溯来给小球找路
    // 说明
    // 1.map 表示地图
    // 2.i,j 表示从地图的哪个位置开始出发    (1,1)
    // 3.如果小球能到    map[6][5]   位置，则说明通路找到.
    // 4.约定：当map[i][j]为0表示该点没有走过当为 1 表示墙；2表示通路可以走；3表示该点已经走过，但是走不通
    // 5.在走迷宫时，需要确定一个策略(方法)   下-&gt;右-&gt;上-&gt;左    ,    如果该点走不通，再回溯

    /**
     * @param map 表示地图
     * @param i 从哪个位置开始找
     * @param j
     * @return 如果找到通路，就返回  true,    否则返回 false
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) {  //   通路已经找到  ok
            return true;
        } else {
            if (map[i][j] == 0) {  // 如果当前这个点还没有走过
                // 按照策略    下-&gt;右-&gt;上-&gt;左        走
                map[i][j] = 2;  //   假定该点是可以走通.
                if (setWay(map, i + 1, j)) {// 向下走
                    return true;
                } else if (setWay(map, i, j + 1)) {  // 向右走
                    return true;
                } else if (setWay(map, i - 1, j)) {  // 向上
                    return true;
                } else if (setWay(map, i, j - 1)) {  //    向左走
                    return true;
                } else {
                    // 说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }

    // 修改找路的策略，改成    上-&gt;右-&gt;下-&gt;左
    public static boolean setWay2(int[][] map, int i, int j) {
        if (map[6][5] == 2) {  //   通路已经找到  ok
            return true;
        } else {
            if (map[i][j] == 0) {  // 如果当前这个点还没有走过
                // 按照策略    上-&gt;右-&gt;下-&gt;左
                map[i][j] = 2;  //   假定该点是可以走通.
                if (setWay2(map, i - 1, j)) {// 向上走
                    return true;
                } else if (setWay2(map, i, j + 1)) {  // 向右走
                    return true;
                } else if (setWay2(map, i + 1, j)) {  // 向下
                    return true;
                } else if (setWay2(map, i, j - 1)) {  //    向左走
                    return true;
                } else {
                    // 说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else { // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }
}
</code></pre>
<h4 id="663">6.6.3 对迷宫问题的讨论</h4>
<ol>
<li>小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关</li>
<li>再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化</li>
<li>测试回溯现象</li>
<li>思考:    如何求出最短路径?        思路-》代码实现.</li>
</ol>
<h3 id="67-">6.7  递归-八皇后问题(回溯算法)</h3>
<h4 id="671">6.7.1 八皇后问题介绍</h4>
<p>​   八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92)。</strong></p>
<p><img alt="image-20220801114334890" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801114334890.png" /></p>
<h4 id="672">6.7.2 八皇后问题算法思路分析</h4>
<ol>
<li>
<p>第一个皇后先放第一行第一列</p>
</li>
<li>
<p>第二个皇后放在第二行第一列、然后判断是否  OK，   如果不  OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p>
</li>
<li>
<p>继续第三个皇后，还是第一列、第二列……直到第  8  个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p>
</li>
<li>
<p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p>
</li>
<li>
<p>然后回头继续第一个皇后放第二列，后面继续循环执行   1,2,3,4  的步骤</p>
</li>
<li>
<p>示意图：</p>
</li>
</ol>
<p><img alt="image-20220801114400167" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801114400167.png" /></p>
<p><strong>说明：</strong>
理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr <strong>下标 表示第几行</strong>，<strong>即第几个皇后</strong>，arr[i] = val , <strong>val 表示第 i+1 个皇后</strong>，<strong>放在第 i+1 行的第 val+1 列</strong></p>
<h4 id="673">6.7.3 八皇后问题算法代码实现</h4>
<pre><code class="language-java">public class Queens8 {
    static int max = 8; // 指有八个皇后
    static int[] arr = new int[max];    // 下标代表第i+1个皇后和第i+1列，arr[i]=val，val+1代表在第几列
    static int result;
    static int conflictCount;
    static int checkCount;

    public static void main(String[] args) {
        check(0);
        System.out.println(&quot;共有&quot; + result + &quot;个结果&quot;);
        System.out.printf(&quot;判断了%d次\n&quot;, conflictCount);
        System.out.printf(&quot;检查了%d次\n&quot;, checkCount);
    }

    /**
     * 开始放皇后
     * 每一个check递归中都包含一个for循环，可以将全部的结果都查询出来
     */
    public static void check(int n) {
        if (n == max) {      // 当n==max的时候说明前面的皇后都放完了，没有问题
            result++;
            return;
        }
        for (int i = 0; i &lt; arr.length; i++) {
            checkCount++;
            arr[n] = i; // 先放在第i+1列
            if (!conflict(n)) {      // 如果不冲突
                check(n + 1);
            }
            // 如果冲突则继续循环
        }
    }


    /**
     * 判断第n个皇后与前面的有没有冲突
     *
     * @param n 第n个皇后，数组下标
     * @return 冲突返回true，不冲突返回false
     */
    public static boolean conflict(int n) {
        for (int i = 0; i &lt; n; i++) {
            conflictCount++;
            if (arr[n] == arr[i] || Math.abs(n - i) == Math.abs(arr[n] - arr[i])) {
                // 如果在同一列或者在同一斜线，则冲突
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h2 id="_8">七、排序算法</h2>
<h3 id="71">7.1 排序算法的介绍</h3>
<p>排序也称排序算法(Sort Algorithm)，排序是将<strong>一组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列的过程</strong>。</p>
<h3 id="72">7.2 排序的分类：</h3>
<ol>
<li>内部排序:
   指将需要处理的所有数据都加载到<strong>内部存储器(内存</strong>)中进行排序。</li>
<li>外部排序法：
   <strong>数据量过大</strong>，无法全部加载到内存中，需要借助<strong>外部存储(文件等)</strong>进行排序。</li>
<li>常见的排序算法分类(见下图):</li>
</ol>
<p><img alt="image-20220801160142464" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801160142464.png" /></p>
<h3 id="73">7.3 算法的时间复杂度</h3>
<h4 id="731">7.3.1 度量一个程序(算法)执行时间的两种方法</h4>
<ol>
<li>事后统计的方法
   这种方法可行,    但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,    这种方式，<strong>要在同一台计算机的相同状态下运行，才能比较那个算法速度更快</strong>。 </li>
<li>事前估算的方法
   通过分析某个算法的<strong>时间复杂度</strong>来判断哪个算法更优. </li>
</ol>
<h4 id="732">7.3.2 时间频度</h4>
<ul>
<li>基本介绍</li>
</ul>
<p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为  T(n)。[举例说明]</p>
<ul>
<li>举例说明-基本案例</li>
</ul>
<p>比如计算  1-100  所有数字之和,   我们设计两种算法：</p>
<p><img alt="image-20220801164437764" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801164437764.png" /></p>
<ul>
<li>举例说明-忽略常数项</li>
</ul>
<p><img alt="image-20220801164448245" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801164448245.png" /></p>
<p>结论:
1. 2n+20    和    2n    随着  n    变大，执行曲线无限接近,  20  可以忽略
2. 3n+10    和    3n    随着  n    变大，执行曲线无限接近,  10  可以忽略</p>
<ul>
<li>举例说明-忽略低次项</li>
</ul>
<p><img alt="image-20220801164532083" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801164532083.png" /></p>
<p>结论:
1. 2n^2+3n+10    和    2n^2    随着  n    变大,    执行曲线无限接近,    可以忽略    3n+10 
2. n^2+5n+20    和    n^2    随着  n    变大,执行曲线无限接近,    可以忽略    5n+20</p>
<ul>
<li>举例说明-忽略系数</li>
</ul>
<p><img alt="image-20220801164552275" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801164552275.png" /></p>
<p>结论:
1. 随着  n  值变大，5n^2+7n    和    3n^2  + 2n    ，执行曲线重合,    说明这种情况下,  5  和  3  可以忽略。
2. 而  n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方是关键</p>
<h4 id="733">7.3.3 时间复杂度</h4>
<ol>
<li>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。</li>
<li>T(n)   不同，但时间复杂度可能相同。   如：T(n)=n²+7n+6    与   T(n)=3n²+2n+2    它们的  T(n) 不同，但时间复杂度相同，都为  O(n²)。</li>
<li>计算时间复杂度的方法：</li>
<li>用常数  1  代替运行时间中的所有加法常数     T(n)=n²+7n+6   =&gt; T(n)=n²+7n+1</li>
<li>修改后的运行次数函数中，只保留最高阶项     T(n)=n²+7n+1  =&gt; T(n) =  n²</li>
<li>去除最高阶项的系数   T(n)  = n²    =&gt; T(n)  = n²    =&gt;  O(n²)</li>
</ol>
<h4 id="734">7.3.4 常见的时间复杂度</h4>
<ol>
<li>常数阶  O(1)</li>
<li>对数阶  O(log2n)</li>
<li>线性阶  O(n)</li>
<li>线性对数阶  O(nlog2n)</li>
<li>平方阶  O(n^2)</li>
<li>立方阶  O(n^3)</li>
<li>k  次方阶  O(n^k)</li>
<li>指数阶  O(2^n)</li>
</ol>
<p>常见的时间复杂度对应的图:</p>
<p><img alt="image-20220801164835618" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801164835618.png" /></p>
<p>说明：
1. 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log<sub>2</sub><sup>n</sup>)＜Ο(n)＜Ο(nlog<sub>2</sub><sup>n</sup>)＜Ο(n<sup>2</sup>)＜Ο(n<sup>3</sup>)＜Ο(n<sup>k</sup>)＜ Ο(2<sup>n</sup>)   ，随着问题规模  n  的不断增大，上述时间复杂度不断增大，算法的执行效率越低</p>
<ol>
<li>
<p>从图中可见，我们应该尽可能避免使用<strong>指数阶</strong>的算法</p>
</li>
<li>
<p>常数阶  O(1)</p>
<p><img alt="image-20220801165552616" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801165552616.png" /></p>
</li>
<li>
<p>对数阶  O(log<sub>2</sub><sup>n</sup>)</p>
<p><img alt="image-20220801165615533" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801165615533.png" /></p>
</li>
<li>
<p>线性阶  O(n)</p>
<p><img alt="image-20220801165627529" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801165627529.png" /></p>
</li>
<li>
<p>线性对数阶  O(nlog<sub>M</sub><sup>N</sup>)</p>
<p><img alt="image-20220801165640659" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801165640659.png" /></p>
</li>
<li>
<p>平方阶  O(n²)</p>
<p><img alt="image-20220801165654394" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801165654394.png" /></p>
</li>
<li>
<p>立方阶  O(n³)、K  次方阶  O(n<sup>k</sup>)
      说明：参考上面的  O(n²)    去理解就好了，O(n³)相当于三层  n  循环，其它的类似</p>
</li>
</ol>
<h4 id="735">7.3.5 平均时间复杂度和最坏时间复杂度</h4>
<p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</p>
<p>最坏情况下的时间复杂度称最坏时间复杂度。<strong>一般讨论的时间复杂度均是最坏情况下的时间复杂度</strong>。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</p>
<p>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)</p>
<p><img alt="image-20220801165733876" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220801165733876.png" /></p>
<h3 id="74">7.4 算法的空间复杂度简介</h3>
<h4 id="741">7.4.1 基本介绍</h4>
<ol>
<li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space  Complexity)定义为该算法所耗费的存储空间，它也是问题规模  n  的函数。</li>
<li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如<strong>快速排序</strong>和<strong>归并排序算法, 基数排序</strong>就属于这种情况</li>
<li>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis,  memcache)和算法(基数排序)<strong>本质就是用空间换时间</strong>.</li>
</ol>
<h3 id="75">7.5 冒泡排序</h3>
<h4 id="751">7.5.1 基本介绍</h4>
<p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较相邻元素的值，若发现逆序则交换</strong>，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p>
<p>优化：
因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，再进行)</p>
<h4 id="752">7.5.2 演示冒泡过程的例子(图解)</h4>
<p><img alt="image-20220802113805220" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220802113805220.png" /></p>
<p>小结上面的图解过程:</p>
<ol>
<li>
<p>一共进行数组的大小 -1 次大的循环</p>
</li>
<li>
<p>每一趟排序的次数在逐渐的减少</p>
</li>
<li>
<p>如果我们发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序。这个就是优化 </p>
</li>
</ol>
<h4 id="753">7.5.3 冒泡排序应用实例</h4>
<p>代码实现：</p>
<pre><code class="language-java">public class BubbleSort {
    public static void main(String[] args) {
        // int[] array = {-1, -2, 30, -4};
        // bubbleSort(array);
        // System.out.println(&quot;array = &quot; + Arrays.toString(array));

        // 测试冒泡排序算法的时间复杂度
        int[] array = new int[80000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 80000);
        }
        long time1 = System.currentTimeMillis();
        bubbleSort(array);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;冒泡排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);
    }

    public static void sort(int[] array) {
        // 冒泡排序的时间复杂度O(n^2)
        boolean flag = false;   // 用来标识该趟排序是否有变量交换
        for (int i = 0; i &lt; array.length - 1; i++) {
            for (int j = 0; j &lt; array.length - i - 1; j++) {
                if (array[j] &gt; array[j + 1]) {
                    flag = true;
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            // System.out.printf(&quot;第%d趟排序后的数组&quot;, i + 1);

            if (!flag) {
                break;
            } else {
                flag = false;
            }
        }
    }
}
</code></pre>
<h3 id="76">7.6 选择排序</h3>
<h4 id="761">7.6.1 基本介绍</h4>
<p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<h4 id="762">7.6.2 选择排序思想</h4>
<p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<h4 id="763">7.6.3 选择排序思路分析图:</h4>
<p><img alt="image-20230318190252177" src="../assets/image-20230318190252177.png" /></p>
<p>对一个数组的选择排序再进行讲解</p>
<p><img alt="image-20230318190453491" src="../assets/image-20230318190453491.png" /></p>
<h4 id="764">7.6.4 选择排序应用实例:</h4>
<p>请使用选择排序从低到高进行排序 [101, 34, 119, 1]</p>
<p>代码实现：</p>
<pre><code class="language-java">public class SelectSort {
    public static void main(String[] args) {
        // int[] array = new int[]{1, 2, 3, -1, -3, 5};
        // sort(array);
        // System.out.println(&quot;array = &quot; + Arrays.toString(array));

        int[] array = new int[80000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 80000);
        }
        long time1 = System.currentTimeMillis();
        sort(array);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;选择排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);
    }

    public static void sort(int[] array) {
        for (int i = 0; i &lt; array.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j &lt; array.length; j++) {
                if (array[min] &gt; array[j]) {
                    min = j;
                }
            }
            if (min != i) {
                int temp = array[min];
                array[min] = array[i];
                array[i] = temp;
            }
        }
    }
}
</code></pre>
<h3 id="77">7.7 插入排序</h3>
<h4 id="771">7.7.1 插入排序法介绍:</h4>
<p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p>
<h4 id="772">7.7.2 插入排序法思想</h4>
<p>插入排序（Insertion Sorting）的基本思想是：<strong>把 n 个待排序的元素看成为一个有序表和一个无序表</strong>，开始时<strong>有序表中只包含一个元素</strong>，无序表中包含有 <strong>n-1 个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<h4 id="773">7.7.3 插入排序思路图</h4>
<p><img alt="image-20220802165957330" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220802165957330.png" /></p>
<h4 id="774">7.7.4 插入排序法应用实例</h4>
<p>有一群小牛,    考试成绩分别是    101,  34,  119, 1        请从小到大排序 
代码实现：</p>
<pre><code class="language-java">public class InsertSort {
    public static void main(String[] args) {
        // int[] array = new int[]{1, 3, -1, -4, 2};
        // sort(array);
        // System.out.println(&quot;array = &quot; + Arrays.toString(array));

        int[] array = new int[80000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 80000);
        }
        long time1 = System.currentTimeMillis();
        sort(array);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;插入排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);

    }

    public static void sort(int[] array) {
        for (int i = 0; i &lt; array.length - 1; i++) {
            int insertValue = array[i + 1]; // 要插入的数
            int insertIndex = i;    // 要跟插入数进行比较的下标
            // insertValue &lt; array[insertIndex]  表示比要插入的数大的话就继续找，
            // 找到比要插入的数小的数之后，比较数的后一个数就是放要插入数
            while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; array[insertIndex]) {
                array[insertIndex + 1] = array[insertIndex];
                insertIndex--;
            }
            if (insertIndex != i){
                array[insertIndex + 1] = insertValue;
            }
        }
    }
}
</code></pre>
<h3 id="78">7.8 希尔排序</h3>
<h4 id="781">7.8.1 简单插入排序存在的问题</h4>
<p>我们看简单的插入排序可能存在的问题.
数组 arr  = {2,3,4,5,6,1}    这时需要插入的数 1(最小),    这样的过程是： 
{2,3,4,5,6,6}
{2,3,4,5,5,6} 
{2,3,4,4,5,6} 
{2,3,3,4,5,6} 
{2,2,3,4,5,6} 
{1,2,3,4,5,6}
<strong>结论:</strong>    当<strong>需要插入的数是较小的数时</strong>，后移的次数<strong>明显增多</strong>，对<strong>效率有影响</strong>.</p>
<h4 id="782">7.8.2 希尔排序法介绍</h4>
<p>希尔排序是希尔（Donald  Shell）于  1959 年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</p>
<h4 id="783">7.8.3 希尔排序法基本思想</h4>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当<strong>增量减至 1  时</strong>，整个文件恰被分成一组，算法便终止</p>
<h4 id="784">7.8.4 希尔排序法的示意图</h4>
<p><img alt="image-20230318190432220" src="../assets/image-20230318190432220.png" /></p>
<p><img alt="image-20230318190346469" src="../assets/image-20230318190346469.png" /></p>
<h4 id="785">7.8.5 希尔排序法应用实例:</h4>
<p>有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序. 请分别使用</p>
<ol>
<li>希尔排序时，对有序序列在插入时采用交换法,    并测试排序速度.</li>
<li>希尔排序时，对有序序列在插入时采用移动法,    并测试排序速度</li>
</ol>
<p>代码实现：</p>
<pre><code class="language-java">// 希尔排序
public class ShellSort {
    public static void main(String[] args) {
        // int[] array = new int[]{8, 9, 1, 7, 2, 3, 5, 4, 6, 0};
        // sort2(array);
        // System.out.println(&quot;array = &quot; + Arrays.toString(array));

        int[] array = new int[80000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 80000);
        }
        long time1 = System.currentTimeMillis();
        sort2(array);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;希尔排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);
    }

    /**
     * 采用交换法，效率低
     */
    public static void sort(int[] array) {
        int temp;
        for (int gap = array.length / 2; gap &gt; 0; gap /= 2) {
            for (int i = gap; i &lt; array.length; i++) {
                // 遍历各组中所有的元素（共gap组，每组有array.length/gap个元素，步长gap
                for (int j = i - gap; j &gt;= 0; j -= gap) {
                    // 如果当前元素大于加上步长后的那个元素，说明交换
                    if (array[j] &gt; array[j + gap]) {
                        temp = array[j];
                        array[j] = array[j + gap];
                        array[j + gap] = temp;
                    }
                }
            }
        }
    }

    /**
     * 采用插入法
     */
    public static void sort2(int[] array) {
        for (int gap = array.length / 2; gap &gt; 0; gap /= 2) {
            for (int i = gap; i &lt; array.length; i++) {
                int insertIndex = i;
                int insertValue = array[insertIndex];
                while (insertIndex - gap &gt;= 0 &amp;&amp; insertValue &lt; array[insertIndex - gap]) {
                    array[insertIndex] = array[insertIndex - gap];
                    insertIndex -= gap;
                }
                if (insertIndex != i) {
                    array[insertIndex] = insertValue;
                }
            }

        }
    }
}
</code></pre>
<h3 id="79">7.9 快速排序</h3>
<h4 id="791">7.9.1 快速排序法介绍:</h4>
<p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到<strong>整个数据变成有序序列</strong></p>
<h4 id="792">7.9.2 快速排序法示意图</h4>
<p><img alt="image-20220803112624909" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220803112624909.png" /></p>
<p><img alt="image-20220803112632857" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220803112632857.png" /></p>
<h4 id="793">7.9.3 快速排序法应用实例:</h4>
<p>要求:   对    [-9,78,0,23,-567,70]    进行从小到大的排序，要求使用快速排序法。【测试  8w 和  800w】 说明[验证分析]:</p>
<ol>
<li>如果取消左右递归，结果是 -9  -567  0  23  78  70</li>
<li>如果取消右递归,结果是 -567 -9 0 23 78 70</li>
<li>如果取消左递归,结果是 -9 -567 0 23 70 78</li>
</ol>
<p>代码实现：</p>
<pre><code class="language-java">public class QuickSort {
    public static void main(String[] args) {

        // int[] array = new int[]{-9, 78, 0, 23, -567, 70};
        // sort(array, 0, array.length - 1);
        // System.out.println(&quot;array = &quot; + Arrays.toString(array));
        int[] array = new int[80000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 80000);
        }
        long time1 = System.currentTimeMillis();
        sort(array, 0, array.length - 1);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;快速排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);
        // System.out.println(&quot;array = &quot; + Arrays.toString(array));

    }

    public static void sort(int[] array, int left, int right) {
        int l = left;   //左指针
        int r = right;  //右指针
        int pivot = array[(left + right) / 2];
        int temp;
        while (l &lt; r) {
            while (array[l] &lt; pivot) {   // 找到pivot左边大于等于pivot的
                l++;
            }
            while (array[r] &gt; pivot) {   // 找到pivot右边小于等于pivot的
                r--;
            }

            if (l == r) {
                break;
            }

            temp = array[l];
            array[l] = array[r];
            array[r] = temp;

            if (array[l] == pivot) {    //如果交换完之后array[l] == pivot就让r--
                r--;
            }
            if (array[r] == pivot) {    //如果交换完之后array[r] == pivot就让l++
                l++;
            }
        }
        if (l == r) {   // 防止栈溢出
            l++;
            r--;
        }
        // 左递归
        if (left &lt; r) {
            sort(array, left, r);
        }
        // 右递归
        if (right &gt; l) {
            sort(array, l, right);
        }
    }
}
</code></pre>
<h3 id="710">7.10 归并排序</h3>
<h4 id="7101">7.10.1 归并排序介绍:</h4>
<p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的<strong>分治（divide-and-conquer）策略</strong>（分治法将问题分(divide)成一些<strong>小的问题然后递归求解</strong>，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。</p>
<h4 id="7102-1-">7.10.2 归并排序思想示意图 1-基本思想</h4>
<p><img alt="image-20220803192854631" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220803192854631.png" /></p>
<h4 id="7103-2-">7.10.3 归并排序思想示意图 2-合并相邻有序子序列:</h4>
<p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p>
<p><img alt="image-20220803192920754" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220803192920754.png" /></p>
<h4 id="7104">7.10.4 归并排序的应用实例:</h4>
<p>给你一个数组, val arr = Array(8, 4, 5, 7, 1, 3, 6, 2 ), 请使用归并排序完成排序。</p>
<pre><code class="language-java">public class MergeSort {
    public static void main(String[] args) {
        // int[] array = {8, 4, 5, 7, 1, 3, 6, 2};
        // sort(array, 0, array.length - 1, new int[array.length]);
        // System.out.println(&quot;array = &quot; + Arrays.toString(array));

        int[] array = new int[8000000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 8000000);
        }
        long time1 = System.currentTimeMillis();
        sort(array, 0, array.length - 1, new int[array.length]);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;归并排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);
    }

    public static void sort(int[] array, int left, int right, int[] temp) {
        if (left &lt; right) {
            int mid = (left + right) / 2;
            sort(array, left, mid, temp);
            sort(array, mid + 1, right, temp);
            merge(array, left, mid, right, temp);
        }

    }

    /**
     * 合并的方法
     *
     * @param array 目标数组
     * @param left 左边有序数列的初始索引
     * @param mid 中间索引
     * @param right 右边有序数列的 终止索引
     * @param temp 临时数组
     */
    public static void merge(int[] array, int left, int mid, int right, int[] temp) {
        int i = left;   // 初始化i，使其为左边有序数组的初始索引
        int j = mid + 1;  // 初始化j，使其为右边有序数组的初始索引
        int tempIndex = 0;  // 临时数组的当前下标

        // 将左右两边的有序序列的元素按顺序填充到temp数组中，直到有一方结束
        while (i &lt;= mid &amp;&amp; j &lt;= right) {
            // 如果 左边的有序序列的当前元素，小于等于右边有序序列的当前元素
            // 就把 左边的有序序列的当前元素填充到temp中
            if (array[i] &lt;= array[j]) {
                temp[tempIndex] = array[i];
                i++;
            } else {
                temp[tempIndex] = array[j];
                j++;
            }
            tempIndex++;
        }

        // 把一边剩余的有序序列全部填充到temp中
        while (j &lt;= right) {
            temp[tempIndex] = array[j];
            j++;
            tempIndex++;
        }
        while (i &lt;= mid) {
            temp[tempIndex] = array[i];
            i++;
            tempIndex++;
        }

        tempIndex = 0;
        int tempLeft = left;
        while (tempLeft &lt;= right) {
            array[tempLeft] = temp[tempIndex];
            tempLeft++;
            tempIndex++;
        }

    }
}

</code></pre>
<h3 id="711">7.11 基数排序</h3>
<h4 id="7111">7.11.1 基数排序(桶排序)介绍</h4>
<ol>
<li>基数排序（radix  sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket  sort）或  bin  sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li>
<li>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</li>
<li>基数排序(Radix  Sort)是桶排序的扩展</li>
<li>基数排序是  1887  年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</li>
</ol>
<h4 id="7112">7.11.2 基数排序基本思想</h4>
<ol>
<li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,   数列就变成一个有序序列。</li>
<li>这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</li>
</ol>
<h4 id="7113">7.11.3 基数排序图文说明</h4>
<p>将数组    {53,  3,  542,  748,  14,  214}    使用基数排序,    进行升序排序</p>
<p><img alt="image-20220831161650819" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220831161650819.png" /></p>
<p><img alt="image-20220831161655783" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220831161655783.png" /></p>
<p><img alt="image-20220831161659760" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220831161659760.png" /></p>
<h4 id="7114">7.11.4 基数排序代码实现</h4>
<p>要求：将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序</p>
<pre><code class="language-java">/**
 * 基数排序
 * 基数排序是用空间换时间
 * 负数不建议使用基数排序
 */
public class RadixSort {
    public static void main(String[] args) {
        // int[] arr = {53, 3, 542, 748, 14, 214};
        // sort(arr);
        // System.out.println(Arrays.toString(arr));

        int[] array = new int[8000000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 8000000);
        }
        long time1 = System.currentTimeMillis();
        sort(array);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;基数排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);
    }

    public static void sort(int[] arr) {
        int[][] bucket = new int[10][arr.length];   // 用来存放数据的桶， 共有10个
        int[] bucketElementCount = new int[bucket.length]; // 用来表示每个桶中有几个有效数据，下标表示第几个桶

        int max = Integer.MIN_VALUE;
        int maxLength = 0;
        // int maxLength = (max + &quot; &quot;).length(); //效率较低
        // 求出最大数
        for (int j : arr) {
            if (j &gt; max) {
                max = j;
            }
        }

        // 求出最大数的位数
        while (max % 10 != 0 || max / 10 != 0) {
            max /= 10;
            maxLength++;
        }

        int index;
        for (int count = 0, n = 1; count &lt; maxLength; count++, n *= 10) {
            for (int k : arr) {
                int element = k / n % 10;

                // 把当前的元素放到第element个桶中的第bucketElementCount[element]的位置
                bucket[element][bucketElementCount[element]] = k;
                bucketElementCount[element]++;
            }

            index = 0;
            // 遍历每一个桶。将桶中的数据放入原数组
            for (int i = 0; i &lt; bucket.length; i++) {
                for (int j = 0; j &lt; bucketElementCount[i]; j++) {
                    arr[index] = bucket[i][j];
                    index++;
                }
                if (count != maxLength - 1 &amp;&amp; bucketElementCount[i] != 0) {
                    bucketElementCount[i] = 0;
                }
            }
        }
    }
}
</code></pre>
<h4 id="7115">7.11.5 基数排序的说明</h4>
<ol>
<li>基数排序是对传统桶排序的扩展，速度很快.</li>
<li>基数排序是经典的<strong>空间换时间的</strong>方式，占用内存很大,    当对海量数据排序时，容易造成    OutOfMemoryError    。</li>
<li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的</li>
<li>有负数的数组，我们不用基数排序来进行排序,    如果要支持负数，参考:  https://code.i-harness.com/zh-CN/q/e98fa9</li>
</ol>
<h3 id="712">7.12 常用排序算法总结和对比</h3>
<h4 id="7121">7.12.1 一张排序算法的比较图</h4>
<p><img alt="image-20220831163530924" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220831163530924.png" /></p>
<h4 id="7122">7.12.2 相关术语解释</h4>
<ol>
<li>稳定：如果  a 原本在  b  前面，而  a=b，排序之后  a 仍然在  b  的前面；</li>
<li>不稳定：如果  a 原本在  b  的前面，而  a=b，排序之后  a 可能会出现在  b  的后面；</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度：一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
<li>n:   数据规模</li>
<li>k:   “桶”的个数</li>
<li>In-place: 不占用额外内存</li>
<li>Out-place: 占用额外内存</li>
</ol>
<h2 id="_9">八、查找算法</h2>
<h3 id="81">8.1 查找算法介绍</h3>
<p>在  java 中，我们常用的查找有四种:</p>
<ol>
<li>顺序(线性)查找</li>
<li>二分查找/折半查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ol>
<h3 id="82">8.2 线性查找算法</h3>
<p>有一个数列：{1,8,  10,  89,  1000,  1234}    ，判断数列中是否包含此名称【顺序查找】 要求:    如果找到了，就提示找到，并给出下标值</p>
<pre><code class="language-java">package search;

public class SeqSearch {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6};
        int index = search(arr, -1);
        if (index == -1) {
            System.out.println(&quot;没有查找到该数&quot;);
        } else {
            System.out.println(&quot;下标为：&quot; + index);
        }


    }

    /**
     * 这里实现的线性查找是找到一个就返回下标
     *
     * @param arr
     * @param value
     * @return
     */
    public static int search(int[] arr, int value) {
        for (int i = 0; i &lt; arr.length; i++) {
            if (arr[i] == value) {
                return i;
            }
        }
        return -1;
    }
}
</code></pre>
<h3 id="83">8.3 二分查找算法</h3>
<h4 id="831">8.3.1 二分查找</h4>
<p>请对一个有序数组进行二分查找    {1,8,  10, 89,  1000,  1234}    ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示"没有这个数"。</p>
<h4 id="832">8.3.2 二分查找算法的思路</h4>
<p><img alt="image-20220901201733334" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220901201733334.png" /></p>
<h4 id="833">8.3.3 二分查找的代码</h4>
<p>说明：增加了找到所有的满足条件的元素下标</p>
<p>课后思考题：    {1,8,  10,  89,  1000,  1000，1234}    当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</p>
<pre><code class="language-java">package search;

import java.util.ArrayList;
import java.util.List;

/**
 * 二分查找
 * 使用二分查找的前提是数组是有序的
 */
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1, 1, 2, 3, 4, 5, 6};
        // int index = search(arr, 1, 0, arr.length - 1);
        List&lt;Integer&gt; indexs = search2(arr, 1, 0, arr.length - 1);
        System.out.println(&quot;index: &quot; + indexs);

    }

    /**
     * @param arr 目标数组
     * @param findValue 要查找的value
     * @param left 左边索引
     * @param right 右边索引
     * @return 找到返回索引，没找到返回 -1
     */
    public static int search(int[] arr, int findValue, int left, int right) {
        if (left &gt; right) {
            return -1;
        }
        int mid = (left + right) / 2;
        if (arr[mid] &lt; findValue) {
            return search(arr, findValue, mid + 1, right);
        } else if (arr[mid] &gt; findValue) {
            return search(arr, findValue, left, mid - 1);
        } else {
            return mid;
        }

    }

    /**
     * 可以扫描多个元素
     * 思路：
     * 1.在找到mid索引的时候不要马上返回
     * 2.向mid索引的左边扫描，将所有满足条件的元素的下标加入到List中（因为是有序数组，所以相同的元素必定相邻）
     * 3.向mid索引的右边扫描，将所有满足条件的元素的下标加入到List中
     * 4.将List返回
     */
    public static List&lt;Integer&gt; search2(int[] arr, int findValue, int left, int right) {
        if (left &gt; right) {
            return new ArrayList&lt;&gt;();
        }
        int mid = (left + right) / 2;
        if (arr[mid] &lt; findValue) {
            return search2(arr, findValue, mid + 1, right);
        } else if (arr[mid] &gt; findValue) {
            return search2(arr, findValue, left, mid - 1);
        } else {
            int temp = mid - 1;
            List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
            while (temp &gt;= 0 &amp;&amp; arr[temp] == findValue) {
                result.add(temp);
                temp--;
            }
            result.add(mid);
            temp = mid + 1;
            while (temp &lt;= arr.length - 1 &amp;&amp; arr[temp] == findValue) {
                result.add(temp);
                temp++;
            }
            return result;
        }
    }
}
</code></pre>
<h3 id="84">8.4 插值查找</h3>
<ol>
<li>插值查找原理介绍：</li>
</ol>
<p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。</p>
<ol>
<li>将折半查找中的求  mid   索引的公式    ,  low   表示左边索引  left,  high  表示右边索引  right. 
   key    就是前面我们讲的       findVal</li>
</ol>
<p><img alt="image-20220902201603080" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220902201603080.png" /></p>
<ol>
<li>
<p>int mid  = low +  (high  - low) *  (key  - arr[low]) /  (arr[high] -  arr[low])       ;/<em>插值索引</em>/ 
   对应前面的代码公式：
   int mid  = left  +  (right    –    left)  *  (findVal   –    arr[left]) /  (arr[right]    –    arr[left])</p>
</li>
<li>
<p>举例说明插值查找算法    1-100   的数组</p>
</li>
</ol>
<p><img alt="image-20220902201609696" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220902201609696.png" /></p>
<h4 id="841">8.4.1 插值查找应用案例</h4>
<pre><code class="language-java">package search;

/**
 * 插值查找
 * 主要的不同就是mid的计算方式不同，自适应
 * int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
 */
public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr = new int[100];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i + 1;
        }
        int index = search(arr, 0, arr.length - 1, 99);
        System.out.println(&quot;index = &quot; + index);
        // System.out.println(Arrays.toString(arr));

    }

    public static int search(int[] arr, int left, int right, int findVal) {
        if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) {
            return -1;
        }
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal &lt; midVal) {
            return search(arr, left, mid - 1, findVal);
        } else if (findVal &gt; midVal) {
            return search(arr, mid + 1, right, findVal);
        } else {
            return mid;
        }

    }
}
</code></pre>
<h4 id="842">8.4.2 插值查找注意事项</h4>
<ol>
<li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快.</li>
</ol>
<p>2)       关键字分布不均匀的情况下，该方法不一定比折半查找要好</p>
<h3 id="85">8.5 斐波那契(黄金分割法)查找算法</h3>
<h4 id="851">8.5.1 斐波那契(黄金分割法)查找基本介绍</h4>
<ol>
<li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。</li>
</ol>
<p>2)       斐波那契数列    {1,  1,  2,  3,  5,  8,  13,  21,  34,  55  }    发现斐波那契数列的两个相邻数    的比例，无限接近    黄金分割值0.618</p>
<h4 id="852">8.5.2 斐波那契(黄金分割法)原理</h4>
<p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid  不再是中间或插值得到，而是位于黄金分割点附近，即  mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示：</p>
<p><img alt="image-20220902215820792" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220902215820792.png" /></p>
<p><strong>对  F(k-1)-1  的理解：</strong></p>
<ol>
<li>
<p>由斐波那契数列   F[k]=F[k-1]+F[k-2]   的性质，可以得到  （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1  。该式说明：只要顺序表的长度为  F[k]-1，则可以将该表分成长度为  F[k-1]-1  和  F[k-2]-1  的两段，即如上图所示。从而中间位置为  mid=low+F(k-1)-1</p>
</li>
<li>
<p>类似的，每一子段也可以用相同的方式分割</p>
</li>
<li>
<p>但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置），都赋为 n 位置的值即可。</p>
</li>
</ol>
<pre><code class="language-java">while(n &gt; fib(k)-1){
    k++;
}

就是说目标数组的长度得是fib[k] - 1的长度才能求出黄金分割点mid。（结合上图理解）
</code></pre>
<h4 id="853">8.5.3 斐波那契查找应用案例</h4>
<pre><code class="language-java">package search;

import java.util.Arrays;

/**
 * 斐波那契查找
 * 需要用到斐波那契数列
 * mid不再是中间或者插值找到的下标，而是临近黄金分割点的位置
 * 在n=F(k)-1情况下，mid = low + F[k-1] - 1，我们就得到了mid的位置
 * mid = low + fib(k - 1) - 1
 */
public class FibonacciSearch {
    public static void main(String[] args) {
        // int[] fib = getFib(20);
        // System.out.println(Arrays.toString(fib));

        int[] arr = {1, 2, 3, 4, 5, 6};
        int index = search(arr, 6);
        System.out.println(&quot;index = &quot; + index);
    }

    /**
     * 得到一个斐波那契数列
     */
    public static int[] getFib(int size) {
        int[] fib = new int[size];
        fib[0] = 1;
        fib[1] = 1;
        for (int i = 2; i &lt; fib.length; i++) {
            fib[i] = fib[i - 1] + fib[i - 2];
        }
        return fib;
    }

    /**
     * mid = low + fib(k - 1) - 1
     */
    public static int search(int[] arr, int findVal) {
        int low = 0;
        int high = arr.length - 1;
        int[] fib = getFib(20); // 获取斐波那契数列
        int k = 0;  // 就是fib(k - 1)中的k
        int mid = 0;    // 黄金分割点

        // 由于顺序表长度不一定刚好等于fib[k] - 1，所以，需要将顺序表的长度添加值fib[k] - 1
        while (high &gt; fib[k] - 1) {
            k++;
        }

        //因为fib[k]值可能大于arr的长度，因此我们需要构造一个新的数组，将不足的部分进行填充
        int[] temp = Arrays.copyOf(arr, fib[k]);
        for (int i = arr.length; i &lt; temp.length; i++) {
            temp[i] = arr[high];
        }

        while (low &lt;= high) {
            mid = low + fib[k - 1] - 1;
            int midVal = temp[mid];
            if (findVal &gt; midVal) {
                low = mid + 1;
                k -= 2; //为什么是k-=2，结合图片理解
            } else if (findVal &lt; midVal) {
                high = mid - 1;
                k--;    //为什么是k--，结合图片理解
            } else {
                return Math.min(mid, high);
            }
        }
        return -1;
    }
}
</code></pre>
<h2 id="_10">九、哈希表</h2>
<h3 id="91-google">9.1 哈希表(散列)-Google 上机题</h3>
<ol>
<li>
<p>看一个实际需求，google  公司的一个上机题:</p>
</li>
<li>
<p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的 id 时,要求查找到该员工的所有信息.</p>
</li>
<li>
<p>要求:   不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)</p>
</li>
</ol>
<h3 id="92">9.2 哈希表的基本介绍</h3>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表</p>
<p><img alt="image-20220903150604805" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220903150604805.png" /></p>
<p><img alt="image-20220903150608306" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220903150608306.png" /></p>
<h3 id="93-google">9.3 google 公司的一个上机题</h3>
<p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的  id  时, 要求查找到该员工的    所有信息.</p>
<p><strong>要求</strong>：</p>
<ol>
<li>不使用数据库,,速度越快越好=&gt;哈希表(散列)</li>
<li>添加时，保证按照  id 从低到高插入        [课后思考：如果  id  不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]</li>
<li>
<p>使用链表来实现哈希表,    该链表不带表头[即:    链表的第一个结点就存放雇员信息]</p>
</li>
<li>
<p>思路分析：</p>
</li>
</ol>
<p><img alt="image-20220903150715633" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220903150715633.png" /></p>
<pre><code class="language-java">package hashtab;

import java.util.Scanner;

public class HashTabDemo {
    public static void main(String[] args) {
        HashTab hashTab = new HashTab(7);
        // 写一个菜单
        String key = &quot;&quot;;
        Scanner sc = new Scanner(System.in);
        while (true) {
            System.out.println(&quot;add：添加雇员&quot;);
            System.out.println(&quot;list：显示雇员&quot;);
            System.out.println(&quot;find：查找雇员&quot;);
            System.out.println(&quot;edit：修改雇员信息&quot;);
            System.out.println(&quot;del：删除雇员&quot;);
            System.out.println(&quot;exit：退出系统&quot;);
            key = sc.next();
            switch (key) {
                case &quot;del&quot; -&gt; {
                    System.out.println(&quot;请输入要删除雇员的id&quot;);
                    int id = sc.nextInt();
                    hashTab.findEmpById(id);
                    System.out.println(&quot;确认要删除吗？(y/n)&quot;);
                    String tempKey = sc.next();
                    switch (tempKey) {
                        case &quot;y&quot; -&gt; {
                            hashTab.delEmpById(id);
                        }
                        case &quot;n&quot; -&gt; System.out.println(&quot;取消操作成功&quot;);
                        default -&gt; System.out.println(&quot;请重新输入&quot;);
                    }
                }
                case &quot;add&quot; -&gt; {
                    System.out.println(&quot;输入id&quot;);
                    int id = sc.nextInt();
                    System.out.println(&quot;输入名字&quot;);
                    String name = sc.next();
                    Emp emp = new Emp(id, name);
                    hashTab.add(emp);
                }
                case &quot;edit&quot; -&gt; {
                    System.out.println(&quot;请输入要修改雇员的id&quot;);
                    int id = sc.nextInt();
                    hashTab.findEmpById(id);
                    System.out.println(&quot;请输入要修改雇员的信息(id/name)&quot;);
                    String tempKey = sc.next();
                    switch (tempKey) {
                        case &quot;name&quot; -&gt; {
                            System.out.println(&quot;请输入要修改雇员的姓名&quot;);
                            String name = sc.next();
                            Emp emp = new Emp(id, name);
                            hashTab.editEmpById(emp);
                            System.out.println(&quot;修改成功&quot;);
                        }
                        case &quot;id&quot; -&gt; System.out.println(&quot;无法修改id&quot;);
                    }
                }
                case &quot;list&quot; -&gt; hashTab.list();
                case &quot;find&quot; -&gt; {
                    System.out.println(&quot;请输入要查找雇员的id&quot;);
                    int id = sc.nextInt();
                    hashTab.findEmpById(id);
                }
                case &quot;exit&quot; -&gt; System.exit(0);
            }
        }
    }
}

/**
 * 创建HashTab管理多条链表
 */
class HashTab {
    private final EmpLinkedList[] empLinkedListArray;
    private final int size;   // 共有多少条链表

    public HashTab(int size) {
        this.size = size;
        empLinkedListArray = new EmpLinkedList[size];
        // 这里要分别初始化每一个链表
        for (int i = 0; i &lt; empLinkedListArray.length; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
    }

    /**
     * 根据id删除雇员
     */
    public void delEmpById(int id) {
        int index = hashFun(id);
        EmpLinkedList empLinkedList = empLinkedListArray[index - 1];
        if (empLinkedList == null || empLinkedList.getHead() == null) {
            System.out.println(&quot;未找到id=&quot; + id + &quot;的雇员&quot;);
            return;
        }
        Emp tempEmp = empLinkedList.getHead();
        if (tempEmp.getId() == id) {
            empLinkedList.setHead(tempEmp.getNext());
            System.out.println(&quot;删除成功&quot;);
            return;
        }
        while (true) {
            if (tempEmp.getNext() == null) {
                System.out.println(&quot;未找到id=&quot; + id + &quot;的雇员&quot;);
                return;
            }
            if (tempEmp.getNext().getId() == id) {
                tempEmp.setNext(tempEmp.getNext().getNext());
                System.out.println(&quot;删除成功&quot;);
                return;
            }
            tempEmp = tempEmp.getNext();
        }
    }

    /**
     * 根据id修改雇员信息
     */
    public void editEmpById(Emp editEmp) {
        int index = hashFun(editEmp.getId());
        Emp emp = empLinkedListArray[index - 1].findEmpById(editEmp.getId());
        if (emp == null) {
            System.out.println(&quot;为找到id=&quot; + editEmp.getId() + &quot;的雇员&quot;);
        } else {
            emp.setName(editEmp.getName());
        }
    }

    /**
     * 根据id查找雇员
     */
    public void findEmpById(int id) {
        int index = hashFun(id);
        Emp emp = empLinkedListArray[index - 1].findEmpById(id);
        if (emp == null) {
            System.out.println(&quot;未查找到id=&quot; + id + &quot;的雇员&quot;);
        } else {
            System.out.printf(&quot;在第%d条链表中找到id=%d的雇员，信息为：&quot;, index, id);
            System.out.println(emp);
        }


    }

    /**
     * 添加
     */
    public void add(Emp emp) {
        if (emp.getId() &lt;= 0) {
            System.out.println(&quot;id必须是正整数&quot;);
            return;
        }
        int index = hashFun(emp.getId());
        empLinkedListArray[index - 1].add(emp);
    }

    /**
     * 遍历HashTab
     */
    public void list() {
        for (int i = 0; i &lt; empLinkedListArray.length; i++) {
            empLinkedListArray[i].list(i);
        }
    }

    /**
     * 编写散列函数，这个一个简单的方法，取模法
     */
    public int hashFun(int id) {
        return id % size;
    }

}

/**
 * 雇员链表
 */
class EmpLinkedList {
    private Emp head;

    public Emp getHead() {
        return head;
    }

    public void setHead(Emp head) {
        this.head = head;
    }

    /**
     * 添加雇员到链表
     */
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        }
        Emp tempEmp = head;
        if (tempEmp.getId() &gt; emp.getId()) {
            head = emp;
            head.setNext(tempEmp);
            return;
        }
        while (tempEmp.getNext() != null) {
            if (tempEmp.getNext().getId() &gt; emp.getId()) {
                break;
            } else if (tempEmp.getId() == emp.getId()) {
                System.out.println(&quot;已存在该id的雇员，添加失败&quot;);
                return;
            }
            tempEmp = tempEmp.getNext();
        }
        Emp newNext = tempEmp.getNext();
        emp.setNext(newNext);
        tempEmp.setNext(emp);
    }

    /**
     * 遍历链表
     */
    public void list(int no) {
        if (head == null) {
            System.out.printf(&quot;第%d条链表为空\n&quot;, no + 1);
            return;
        }
        Emp tempEmp = head;
        System.out.printf(&quot;第%d条链表的信息为:&quot;, no + 1);
        while (tempEmp != null) {
            System.out.print(tempEmp + &quot;  &quot;);
            tempEmp = tempEmp.getNext();
        }
        System.out.println();
    }

    /**
     * 查找雇员
     */
    public Emp findEmpById(int id) {
        if (head == null) {
            return null;
        }
        Emp tempEmp = head;
        while (tempEmp != null) {
            if (tempEmp.getId() == id) {
                return tempEmp;
            }
            tempEmp = tempEmp.getNext();
        }
        return null;
    }

}

/**
 * 雇员类
 */
class Emp {
    private int id;
    private String name;
    private Emp next;

    public Emp() {
    }

    @Override
    public String toString() {
        return &quot;Emp{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Emp getNext() {
        return next;
    }

    public void setNext(Emp next) {
        this.next = next;
    }

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
</code></pre>
<h2 id="_11">十、树结构的基础部分</h2>
<h3 id="101">10.1 二叉树</h3>
<h4 id="1011">10.1.1 为什么需要树这种数据结构</h4>
<ol>
<li>
<p>数组存储方式的分析
   <strong>优点</strong>：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
   <strong>缺点</strong>：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低    [示意图]
   画出操作示意图：
   <img alt="image-20220904131556006" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904131556006.png" /></p>
</li>
<li>
<p>链式存储方式的分析
   <strong>优点</strong>：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。
   <strong>缺点</strong>：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)   【示意图】 
   操作示意图：
   <img alt="image-20220904131626683" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904131626683.png" /></p>
</li>
<li>
<p>树存储方式的分析
   能提高<strong>数据存储</strong>，<strong>读取</strong>的效率，比如利用<strong>二叉排序树</strong>(Binary  Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的<strong>插入</strong>，<strong>删除</strong>，<strong>修改</strong>的速度。【示意图,后面详讲
   案例:  [7, 3,  10,  1,  5,  9,  12]
   <img alt="image-20220904131714470" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904131714470.png" /></p>
</li>
</ol>
<h4 id="1012">10.1.2 树示意图</h4>
<p><img alt="image-20230318190311787" src="../assets/image-20230318190311787.png" /></p>
<p>树的常用术语(结合示意图理解):</p>
<ol>
<li>节点</li>
<li>根节点</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点    (没有子节点的节点)</li>
<li>节点的权(节点值)</li>
<li>路径(从 root 节点找到该节点的路线)</li>
<li>层</li>
<li>子树</li>
<li>树的高度(最大层数)</li>
<li>森林：多颗子树构成森林</li>
</ol>
<h4 id="1013">10.1.3 二叉树的概念</h4>
<ol>
<li>树有很多种，每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树。</li>
<li>二叉树的子节点分为左节点和右节点</li>
<li>
<p>示意图
   <img alt="image-20220904132829027" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904132829027.png" /></p>
</li>
<li>
<p>如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n^  -1  ,  n为层数，则我们称为满二叉树。
   <img alt="image-20220904133003777" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904133003777.png" /></p>
</li>
<li>
<p>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树
   <img alt="image-20220904133018683" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904133018683.png" /></p>
</li>
</ol>
<h4 id="1014">10.1.4 二叉树遍历的说明</h4>
<p>使用<strong>前序</strong>，<strong>中序</strong>和<strong>后序</strong>对下面的二叉树进行遍历.</p>
<ol>
<li>前序遍历:   先输出父节点，再遍历左子树和右子树</li>
<li>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</li>
<li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li>
<li>小结：看输出<strong>父节点的顺序</strong>，就确定是前序，中序还是后序</li>
</ol>
<h4 id="1015">10.1.5 二叉树遍历应用实例(前序,中序,后序)</h4>
<p>应用实例的说明和思路</p>
<p><img alt="image-20220904142930441" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904142930441.png" /></p>
<pre><code class="language-java">package tree;

public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        UserNode root = new UserNode(1, &quot;张三&quot;);
        UserNode node2 = new UserNode(2, &quot;李四&quot;);
        UserNode node3 = new UserNode(3, &quot;王五&quot;);
        UserNode node4 = new UserNode(4, &quot;赵六&quot;);
        UserNode node5 = new UserNode(5, &quot;老六&quot;);
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        binaryTree.setRoot(root);
        System.out.println(&quot;前序遍历&quot;); // 1 2 3 5 4
        binaryTree.predixOrder();
        System.out.println(&quot;中序遍历&quot;); // 2 1 5 3 4
        binaryTree.infixOrder();
        System.out.println(&quot;后序遍历&quot;); // 2 5 4 3 1
        binaryTree.suffixOrder();
    }

}

/**
 * 创建一个二叉树
 */
class BinaryTree {
    private UserNode root;

    public void setRoot(UserNode root) {
        this.root = root;
    }

    /**
     * 前序遍历
     */
    public void predixOrder() {
        if (root == null) {
            System.out.println(&quot;二叉树为空！&quot;);
            return;
        }
        root.predixOrder();
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (root == null) {
            System.out.println(&quot;二叉树为空！&quot;);
            return;
        }
        root.infixOrder();
    }

    /**
     * 后序遍历
     */
    public void suffixOrder() {
        if (root == null) {
            System.out.println(&quot;二叉树为空！&quot;);
            return;
        }
        root.suffixOrder();
    }
}

/**
 * 创建User Node节点
 */
class UserNode {
    private int id;
    private String name;
    private UserNode left;  // 左节点
    private UserNode right; // 右节点

    public UserNode getLeft() {
        return left;
    }

    public void setLeft(UserNode left) {
        this.left = left;
    }

    public UserNode getRight() {
        return right;
    }

    public void setRight(UserNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return &quot;UserNode{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public UserNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    /**
     * 前序遍历
     */
    public void predixOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.predixOrder();
        }
        if (this.right != null) {
            this.right.predixOrder();
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    /**
     * 后续遍历
     */
    public void suffixOrder() {
        if (this.left != null) {
            this.left.suffixOrder();
        }
        if (this.right != null) {
            this.right.suffixOrder();
        }
        System.out.println(this);
    }
}
</code></pre>
<h4 id="1016-">10.1.6 二叉树-查找指定节点</h4>
<p>要求 </p>
<ol>
<li>请编写前序查找，中序查找和后序查找的方法。</li>
<li>并分别使用三种查找方式，查找 heroNO = 5 的节点</li>
<li>并分析各种查找方式，分别比较了多少次</li>
<li>思路分析图解
   <img alt="image-20220904154257152" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220904154257152.png" /></li>
</ol>
<pre><code class="language-java">/**
 * 根据id前序查找
 */
public UserNode predixSearch(int id) {
    if (this.id == id) {
        return this;
    }
    UserNode result = null;
    if (this.left != null) {
        result = this.left.predixSearch(id);
    }
    if (result != null) {
        return result;
    }

    if (this.right != null) {
        result = this.right.predixSearch(id);
    }
    return result;
}

/**
 * 根据id中序查找
 */
public UserNode infixSearch(int id) {
    UserNode result = null;
    if (this.left != null) {
        result = this.left.infixSearch(id);
    }
    if (result != null) {
        return result;
    }

    if (this.id == id) {
        return this;
    }

    if (this.right != null) {
        result = this.right.infixSearch(id);
    }
    return result;
}

/**
 * 根据id后序遍历查找
 */
public UserNode suffixSearch(int id) {
    UserNode result = null;
    if (this.left != null) {
        result = this.left.suffixSearch(id);
    }
    if (result != null) {
        return result;
    }

    if (this.right != null) {
        result = this.right.suffixSearch(id);
    }
    if (result != null) {
        return result;
    }

    if (this.id == id) {
        result = this;
    }
    return result;

}
</code></pre>
<h4 id="1017-">10.1.7 二叉树-删除节点</h4>
<p>要求
1. 如果删除的节点是叶子节点，则删除该节点
2. 如果删除的节点是非叶子节点，则删除该子树.</p>
<ol>
<li>
<p>测试，删除掉 5 号叶子节点 和 3 号子树.</p>
</li>
<li>
<p>完成删除思路分析</p>
</li>
</ol>
<p><img alt="image-20220905194716818" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220905194716818.png" /></p>
<pre><code class="language-java">class BinaryTree {
    private UserNode root;

    /**
     * 删除节点
     */
    public void delNode(int id) {
        if (root == null) {
            System.out.println(&quot;二叉树为空！&quot;);
        }else {
            if (root.getId() == id){
                root = null;
            }else {
                root.delNode(id);
            }
        }
    }
}

class UserNode {
    private int id;
    private String name;
    private UserNode left;  // 左节点
    private UserNode right; // 右节点

    /**
     * 删除节点
     */
    public void delNode(int id) {
        if (this.left != null &amp;&amp; this.left.id == id) {
            this.left = null;
            return;
        }
        if (this.right != null &amp;&amp; this.right.id == id) {
            this.right = null;
            return;
        }
        if (this.left != null) {
            this.left.delNode(id);
        }
        if (this.right != null) {
            this.right.delNode(id);
        }
    }
}
</code></pre>
<p>10.1.8 二叉树-删除节点 
思考题(课后练习)</p>
<p>如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，需要指定规则,    假如规定如下:</p>
<ol>
<li>如果该非叶子节点 A 只有一个子节点 B，则子节点 B 替代节点 A</li>
<li>如果该非叶子节点 A 有左子节点 B  和右子节点 C，则让左子节点 B  替代节点 A。</li>
<li>请大家思考，如何完成该删除功能,    老师给出提示.(课后练习)</li>
<li>后面在讲解   二叉排序树时，在给大家讲解具体的删除方法</li>
</ol>
<p><img alt="image-20220905194956546" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220905194956546.png" /></p>
<h3 id="102">10.2 顺序存储二叉树</h3>
<h4 id="1021">10.2.1 顺序存储二叉树的概念</h4>
<p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即<strong>数组可以转换成树</strong>，<strong>树也可以转换成数组</strong>，看右面的示意图</p>
<p><img alt="image-20220905202210521" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220905202210521.png" /></p>
<p>要求:
1. 二叉树的结点，要求以数组的方式来存放    arr  :  [1, 2,  3,  4,  5,  6,  6]</p>
<ol>
<li>要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</li>
</ol>
<p>顺序存储二叉树的特点:</p>
<ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第  n  个元素的左子节点为        <strong>2  *  n + 1</strong></li>
<li>第  n  个元素的右子节点为        <strong>2  *  n + 2</strong></li>
<li>第  n  个元素的父节点为        <strong>(n-1) /  2</strong></li>
<li>n  :   表示二叉树中的第几个元素(按  0  开始编号如图所示)</li>
</ol>
<h4 id="1022">10.2.2 顺序存储二叉树遍历</h4>
<pre><code class="language-java">package tree;

public class ArrayBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        ArrayBinaryTree tree = new ArrayBinaryTree(arr);
        tree.predixOrder();
    }
}

class ArrayBinaryTree {
    private final int[] arr;

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }

    /**
     * 重载predixOrder
     */
    public void predixOrder() {
        this.predixOrder(0);
    }
    public void infixOrder() {
        this.infixOrder(0);
    }
    public void suffixOrder() {
        this.suffixOrder(0);
    }

    /**
     * 编写一个方法完成二叉树前序遍历数组
     *
     * @param index 数组下标
     */
    public void predixOrder(int index) {
        if (arr.length == 0) {
            System.out.println(&quot;数组为空，无法遍历&quot;);
            return;
        }
        System.out.println(arr[index]);
        if ((2 * index + 1) &lt; arr.length) {
            predixOrder(2 * index + 1);
        }
        if ((2 * index + 2) &lt; arr.length) {
            predixOrder(2 * index + 2);
        }
    }

    /**
     * 编写一个方法完成二叉树中序遍历数组
     *
     * @param index 数组下标
     */
    public void infixOrder(int index) {
        if (arr.length == 0) {
            System.out.println(&quot;数组为空，无法遍历&quot;);
            return;
        }
        if ((2 * index + 1) &lt; arr.length) {
            predixOrder(2 * index + 1);
        }
        System.out.println(arr[index]);
        if ((2 * index + 2) &lt; arr.length) {
            predixOrder(2 * index + 2);
        }
    }

    /**
     * 编写一个方法完成二叉树后序遍历数组
     *
     * @param index 数组下标
     */
    public void suffixOrder(int index) {
        if (arr.length == 0) {
            System.out.println(&quot;数组为空，无法遍历&quot;);
            return;
        }
        if ((2 * index + 1) &lt; arr.length) {
            predixOrder(2 * index + 1);
        }
        if ((2 * index + 2) &lt; arr.length) {
            predixOrder(2 * index + 2);
        }
        System.out.println(arr[index]);
    }
}
</code></pre>
<h4 id="1023">10.2.3 顺序存储二叉树应用实例</h4>
<p>八大排序算法中的堆排序，就会使用到顺序存储二叉树</p>
<h3 id="103">10.3 线索化二叉树</h3>
<h4 id="1031">10.3.1 先看一个问题</h4>
<p>将数列    {1,  3, 6, 8,  10, 14 }构建成一颗二叉树.        n+1=7</p>
<p><img alt="image-20220906202037381" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220906202037381.png" /></p>
<p>问题分析:
1. 当我们对上面的二叉树进行中序遍历时，数列为   {8,  3,  10,  1,  6,  14  }
2. 但是   6,  8,  10,  14    这几个节点的   左右指针，并没有完全的利用上.
3. 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?
4. 解决方案-线索二叉树</p>
<h4 id="1032">10.3.2 线索二叉树基本介绍</h4>
<ol>
<li>n  个结点的二叉链表中含有 n+1【公式    2n-(n-1)=n+1】   个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）</li>
<li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded  BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为<strong>前驱</strong>结点</li>
<li>一个结点的后一个结点，称为后继结点</li>
</ol>
<h4 id="1033">10.3.3 线索二叉树应用案例</h4>
<p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为   {8,  3,  10,  1,  14,  6}</p>
<p><img alt="image-20220906202321358" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220906202321358.png" /></p>
<p><strong>思路分析</strong>：中序遍历的结果：{8, 3,  10,  1,  14,  6}</p>
<p><img alt="image-20220906202335365" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220906202335365.png" /></p>
<p>说明:   当线索化二叉树后，Node  节点的    属性    left    和    right    ，有如下情况:
1. left    指向的是左子树，也可能是指向的前驱节点，比如①节点left指向的左子树，而⑩节点的left指向的就是前驱节点.
2. right  指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而⑩节点的right指向的是后继节点.</p>
<pre><code class="language-java">package tree;

import java.util.Objects;

public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        Node root = new Node(1);
        Node node2 = new Node(3);
        Node node3 = new Node(6);
        Node node4 = new Node(8);
        Node node5 = new Node(10);
        Node node6 = new Node(14);

        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);


        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        // 测试中序线索化
        // threadedBinaryTree.infixThreadedNodes();
        // threadedBinaryTree.preThreadedNode();
        threadedBinaryTree.postThreadedNode();

        // // 测试:以10号节点测试
        Node leftNode = node5.getLeft();
        Node rightNode = node5.getRight();
        // System.out.println(&quot;中序线索化10号结点的前驱结点是=&quot; + leftNode); // 3
        // System.out.println(&quot;中序线索化10号结点的后继结点是=&quot; + rightNode); // 1
        // System.out.println(&quot;前序线索化10号结点的前驱结点是=&quot; + leftNode); // 8
        // System.out.println(&quot;前序线索化10号结点的后继结点是=&quot; + rightNode); // 6
        System.out.println(&quot;后序线索化10号结点的前驱结点是=&quot; + leftNode); // 8
        System.out.println(&quot;后序线索化10号结点的后继结点是=&quot; + rightNode); // 3


        // 当线索化二叉树后，不能再使用原来的遍历方式
        // System.out.println(&quot;使用中序线索化的方式遍历线索化二叉树&quot;);
        // threadedBinaryTree.infixThreadedList();  // 8,  3,  10,  1,  14,  6

        // System.out.println(&quot;使用前序线索化的方式遍历线索化二叉树&quot;);
        // threadedBinaryTree.preThreadedList(); // 1, 3, 8, 10, 6, 14

        System.out.println(&quot;使用后序线索化的方式遍历线索化二叉树&quot;);
        threadedBinaryTree.postThreadedList(); // 8,10,3,14,6,1


    }
}

/**
 * 线索化二叉树
 */
class ThreadedBinaryTree {
    private Node root;

    /**
     * 当前节点的前驱结点
     */
    private Node pre;

    /**
     * 中序线索化节点
     */
    public void infixThreadedNode(Node node) {
        if (node == null) {
            return;
        }

        // 线索化左子树
        infixThreadedNode(node.getLeft());

        // 线索化当前节点
        if (node.getLeft() == null) {
            node.setLeft(pre);
            node.setLeftType(1);
        }

        if (pre != null &amp;&amp; pre.getRight() == null) {
            pre.setRight(node);
            pre.setRightType(1);
        }
        //！！！！每处理一个节点后，当前节点是下一个节点的前驱结点
        pre = node;

        // 线索化右子树
        infixThreadedNode(node.getRight());
    }

    /**
     * 线索化中序遍历二叉树
     */
    public void infixThreadedList() {
        Node node = root;
        while (node != null) {
            // 循环找到leftType = 1的节点
            // 后面随着遍历而变化，因为当leftType = 1时
            // 说明该节点是按照线索化处理后的有效节点
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            System.out.println(node);
            // 如果当前节点的右指针指向的是后继节点，就一直输出
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
            node = node.getRight();
        }
    }

    /**
     * 前序线索化节点
     */
    public void preThreadedNode(Node node) {
        if (node == null) {
            return;
        }
        if (node.getLeft() == null) {
            node.setLeft(pre);
            node.setLeftType(1);
        }
        if (pre != null &amp;&amp; pre.getRight() == null) {
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;
        if (node.getLeftType() != 1) {
            preThreadedNode(node.getLeft());
        }

        if (node.getRightType() != 1) {
            preThreadedNode(node.getRight());
        }
    }

    /**
     * 前序遍历线索化二叉树
     */
    public void preThreadedList() {
        Node node = root;
        if (node != null) {
            System.out.println(node);
            while (node.getLeftType() == 0) {
                node = node.getLeft();
                System.out.println(node);
            }
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
        }
    }

    /**
     * 重写postThreadedNode
     */
    public void postThreadedNode() {
        postThreadedNode(root);
    }

    /**
     * 后序线索化二叉树
     */
    public void postThreadedNode(Node node) {
        if (node == null) {
            return;
        }
        if (node.getLeftType() == 0) {
            postThreadedNode(node.getLeft());
        }
        if (node.getRightType() == 0) {
            postThreadedNode(node.getRight());
        }

        if (node.getLeft() == null) {
            node.setLeft(pre);
            node.setLeftType(1);
        }
        if (pre != null &amp;&amp; pre.getRight() == null) {
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;

    }

    /**
     * 重写preThreadedNode
     */
    public void preThreadedNode() {
        preThreadedNode(root);
    }

    /**
     * 重写infixThreadedNodes
     */
    public void infixThreadedNodes() {
        infixThreadedNode(root);
    }

    /**
     * 后序遍历线索化二叉树
     */
    public void postThreadedList() {
        Node node = root;
        if (node != null) {
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            System.out.println(node);
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
            if (root.getRightType() == 0 &amp;&amp; root.getRight() != null) {
                node = root.getRight();
            }
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            System.out.println(node);
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
        }
    }

    public void setRoot(Node root) {
        this.root = root;
    }
}

class Node {
    private int no;
    private Node left;
    private Node right;

    /**
     * 左子树的类型，1表示前驱结点
     */
    private int leftType;
    /**
     * 右子树类型，1表述后继节点
     */
    private int rightType;

    public int getNo() {
        return no;
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return &quot;Node{&quot; +
                &quot;no=&quot; + no +
                '}';
    }

    public Node() {
    }

    public Node(int no) {
        this.no = no;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Node node = (Node) o;
        return no == node.no;
    }

    @Override
    public int hashCode() {
        return Objects.hash(no);
    }
}
</code></pre>
<h4 id="1034">10.3.4 遍历线索化二叉树</h4>
<ol>
<li>说明：对前面的中序线索化的二叉树，进行遍历</li>
<li>分析：因为线索化后，<strong>各个结点指向有变化，因此原来的遍历方式不能使用</strong>，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致。</li>
</ol>
<h2 id="_12">十一、树结构实际应用</h2>
<h3 id="111">11.1 堆排序</h3>
<h4 id="1111">11.1.1 堆排序基本介绍</h4>
<ol>
<li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为  O(<strong>nlogn</strong>)，它也是不稳定排序。</li>
<li>堆是具有以下性质的<strong>完全二叉树</strong>：每个结点的值都大于或等于其左右子树结点的值，称为<strong>大顶堆</strong>
   <strong>注意</strong>：没有要求结点的左子树的值和右子树的值的大小关系。</li>
<li>每个结点的值都小于或等于其左右子树结点的值，称为<strong>小顶堆</strong></li>
<li>大顶堆举例说明</li>
</ol>
<p><img alt="image-20220907164511057" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220907164511057.png" /></p>
<ol>
<li>小顶堆举例说明</li>
</ol>
<p><img alt="image-20220907164525281" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220907164525281.png" /></p>
<ol>
<li>一般<strong>升序</strong>采用大顶堆，<strong>降序</strong>采用小顶堆</li>
</ol>
<h4 id="1112">11.1.2 堆排序基本思想</h4>
<p>堆排序的基本思想是：
1. 将待排序序列构造成一个大顶堆
2. 此时，整个序列的最大值就是堆顶的根节点。
3. 将其与末尾元素进行交换，此时末尾就为最大值。
4. 然后将剩余  n-1  个元素重新构造成一个堆，这样会得到  n  个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<h4 id="1113">11.1.3 堆排序步骤图解说明</h4>
<p>要求：给你一个数组    {4,6,8,5,9}  ,    要求使用堆排序法，将数组升序排序</p>
<p>步骤1：</p>
<ol>
<li>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 原始的数组    [4,  6,  8,  5,  9].假设给定无序序列结构如下</li>
</ol>
<p><img alt="image-20230318185934299" src="../assets/image-20230318185934299.png" /></p>
<ol>
<li>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1 = 5/2-1 = 1，也就是下面的 6 结点），从左至右，从下至上进行调整。</li>
</ol>
<p><img alt="image-20230318190051967" src="../assets/image-20230318190051967.png" /></p>
<ol>
<li>找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</li>
</ol>
<p><img alt="image-20220907164802894" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220907164802894.png" /></p>
<ol>
<li>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。</li>
</ol>
<p><img alt="image-20220907164820290" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220907164820290.png" /></p>
<p>此时，我们就将一个无序序列构造成了一个大顶堆。</p>
<p>步骤2：</p>
<ol>
<li>将堆顶元素 9 和末尾元素 4 进行交换</li>
</ol>
<p><img alt="image-20230318190108768" src="../assets/image-20230318190108768.png" /></p>
<ol>
<li>重新调整结构，使其继续满足堆定义</li>
</ol>
<p><img alt="image-20230318190117447" src="../assets/image-20230318190117447.png" /></p>
<ol>
<li>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</li>
</ol>
<p><img alt="image-20230318190123705" src="../assets/image-20230318190123705.png" /></p>
<ol>
<li>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</li>
</ol>
<p><img alt="image-20230318190134800" src="../assets/image-20230318190134800.png" /></p>
<p><strong>再简单总结下堆排序的基本思路：</strong></p>
<ol>
<li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li>
</ol>
<h4 id="1114">11.1.4 堆排序代码实现</h4>
<pre><code class="language-java">package tree;

/**
 * 堆排序算法
 */
public class HeapSort {
    public static void main(String[] args) {
        // int[] arr = {4, 6, 8, 5, 9};
        // sort(arr);
        // System.out.println(Arrays.toString(arr));
        int[] array = new int[8000000];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = (int) (Math.random() * 8000000);
        }
        long time1 = System.currentTimeMillis();
        sort(array);
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;堆排序执行的时间为：&quot; + (time2 - time1) + &quot;纳秒&quot;);
    }

    public static void sort(int[] arr) {
        int temp;
        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }

        for (int i = arr.length - 1; i &gt; 0; i--) {
            temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, i);
        }
    }

    /**
     * 功能：完成将以index对应的非叶子节点的树调整成大顶堆
     * 举例 int arr[] = {4, 6, 8, 5, 9};  =&gt;  index = 1 =&gt; adjustHeap =&gt; 得到 {4, 9, 8, 5, 6}
     * 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt;  得到 {4,  9,  8,  5,  6} =&gt; {9, 6, 8, 5, 4}
     *
     * @param arr 待调整的数组
     * @param index 表示非叶子结点在数组中索引
     * @param length 表示对多少个元素继续调整，length是在逐渐的减少
     */
    public static void adjustHeap(int[] arr, int index, int length) {
        int temp = arr[index];  // 当前节点，也就是父节点
        //index * 2 + 1表示的是当前节点的左子节点
        for (int k = index * 2 + 1; k &lt; length; k = k * 2 + 1) {
            // 如果右子树的值大于左子树的值，则让当前指针指向右子树
            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) {
                k++;
            }
            // 如果子节点大于父节点
            if (arr[k] &gt; temp) {
                arr[index] = arr[k];    // 把较大的值赋给当前节点
                index = k;  //！！！index指向k，继续循环比较
            } else {
                break;
            }
        }
        //当for循环结束后，我们已经将以index为父节点的树的最大值放在了最顶部（局部的）
        arr[index] = temp;
    }
}

</code></pre>
<h3 id="112">11.2 赫夫曼树</h3>
<h4 id="1121">11.2.1 基本介绍</h4>
<ol>
<li>给定 n  个权值作为  n  个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree),    还有的书翻译为霍夫曼树。</li>
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li>
</ol>
<h4 id="1122">11.2.2 赫夫曼树几个重要概念和举例说明</h4>
<ol>
<li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通<strong>路中分支的数目称为路径长度</strong>。若规定根结点的层数为  1，则从根结点到第  L  层结点的路径长度为 L-1</li>
<li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为  WPL(weighted  path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li>
<li>WPL 最小的就是赫夫曼树</li>
</ol>
<p><img alt="image-20220908195225832" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220908195225832.png" /></p>
<h4 id="1123">11.2.3 赫夫曼树创建思路图解</h4>
<p>给你一个数列    {13,  7,  8,  3,  29,  6, 1}，要求转成一颗赫夫曼树.</p>
<p><strong>构成赫夫曼树的步骤</strong>：</p>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>
<p>组成一颗新的二叉树,    该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li>
<p>再将这颗新的二叉树，以根节点的权值大小    再次排序，不断重复 1-2-3-4    的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
</li>
</ol>
<p><img alt="image-20220908195310615" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220908195310615.png" /></p>
<pre><code class="language-java">package huffmantree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class HuffmanTree {
    public static void main(String[] args) {
        int[] arr = {13, 7, 8, 3, 29, 6, 1};
        Node tree = createHuffmanTree(arr);
        tree.preOrder();
    }

    /**
     * 创建赫夫曼树
     *
     * @param arr 需要创建为赫夫曼树的数组
     * @return 创建好后赫夫曼树的root节点
     */
    public static Node createHuffmanTree(int[] arr) {
        List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();
        for (int value : arr) {
            nodes.add(new Node(value));
        }

        while (nodes.size() &gt; 1) {
            // 从小到大排序
            Collections.sort(nodes);

            // 取出根节点权值最小的值
            Node leftNode = nodes.get(0);

            // 取出根节点权值第二小的值
            Node rightNode = nodes.get(1);

            // 构建新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;

            // 删除从List中删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);

            // 将根节点加入到List中
            nodes.add(parent);
        }

        // 返回赫夫曼树的头
        return nodes.get(0);

    }
}

/**
 * 节点类
 * 为了让Node对象使用Collections集合排序
 * 需要实现Comparable接口
 */
class Node implements Comparable&lt;Node&gt; {
    int value;
    Node left;
    Node right;

    /**
     * 前序遍历
     */
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return &quot;Node{&quot; +
                &quot;value=&quot; + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
</code></pre>
<h3 id="113">11.3 赫夫曼编码</h3>
<h4 id="1131">11.3.1 基本介绍</h4>
<ol>
<li>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间</li>
<li>赫夫曼码是可变字长编码(VLC)的一种。Huffman  于 1952  年提出一种编码方法，称之为最佳编码</li>
</ol>
<h4 id="1132">11.3.2 原理剖析</h4>
<p>通信领域中信息的处理方式  </p>
<ol>
<li>定长编码</li>
</ol>
<p><img alt="image-20220909204437191" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220909204437191.png" /></p>
<ol>
<li>变长编码</li>
</ol>
<p><img alt="image-20220909204454910" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220909204454910.png" /></p>
<ol>
<li>赫夫曼编码</li>
</ol>
<p>步骤如下：</p>
<p>传输的   字符串
1. i like like like java do you like a java
2. d:1  y:1  u:1  j:2  v:2  o:2  l:4  k:4  e:4  i:5  a:5   :9       //    各个字符对应的个数
3. 按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值</p>
<p><img alt="image-20220909204711327" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220909204711327.png" /></p>
<ol>
<li>根据赫夫曼树，给各个字符,规定编码   (前缀编码)，向左的路径为  0   向右的路径为 1 ，编码如下:</li>
</ol>
<p><img alt="image-20220909204745613" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220909204745613.png" /></p>
<ol>
<li>
<p>按照上面的赫夫曼编码，我们的"i like like like java do you like a java" 字符串对应的编码为(注：意这里我们使用的无损压缩)</p>
</li>
<li>
<p>长度为 ： 133
   说明:
   原来长度是 359 ,   压缩了  (359-133) / 359 = 62.9%</p>
</li>
</ol>
<p>此编码满足前缀编码,   即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性赫夫曼编码是无损处理方案</p>
<p><strong>注意</strong>：这个赫夫曼树根据<strong>排序方法不同</strong>，也可能不太一样，这样对应的<strong>赫夫曼编码也不完全一样</strong>，但是 wpl 是一样的，都是最小的, 最后生成的<strong>赫夫曼编码的长度是一样</strong>，比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:</p>
<p><img alt="image-20220909204900040" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220909204900040.png" /></p>
<h4 id="1133-">11.3.3 最佳实践-数据压缩(创建赫夫曼树)</h4>
<p>将给出的一段文本，比如    "i  like  like  like  java  do  you  like  a  java" ，根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理，形如1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</p>
<pre><code class="language-java">package huffmancoding;

import java.io.*;
import java.util.*;

/**
 * 赫夫曼编码
 */
public class HuffmanCoding {
    /**
     * 赫夫曼编码表，用于存放赫夫曼编码
     */
    static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;();

    public static void main(String[] args) {
        // 测试压缩文件
        // String srcFile = &quot;data-structure//src//huffmancoding//无标题.png&quot;;
        // String destFile = &quot;data-structure//src//huffmancoding//destFile.zip&quot;;
        // zipFile(srcFile, destFile);
        // System.out.println(&quot;压缩文件成功&quot;);

        //测试解压文件
        String zipFile = &quot;data-structure//src//huffmancoding//destFile.zip&quot;;
        String destFile = &quot;data-structure//src//huffmancoding//解压后的.png&quot;;
        unZipFile(zipFile, destFile);
        System.out.println(&quot;解压完成&quot;);

        // String str = &quot;i like like like java do you like a java&quot;;
        // System.out.println(&quot;压缩前长度为：&quot; + str.length());

        /*// 测试统计字符串中各个字符的出现次数
        List&lt;Node&gt; charNumList = getCharNum(str.getBytes());
        Collections.sort(charNumList);
        System.out.println(&quot;charNumList = &quot; + charNumList);

        Node tree = createHuffmanTree(str);
        // 测试创建赫夫曼树
        tree.preOrder();

        // 测试赫夫曼树转成的赫夫曼编码
        Map&lt;Byte, String&gt; huffmanCodes = getCodes(tree);
        System.out.println(huffmanCodes);

        // 测试压缩
        byte[] bytes = zip(str.getBytes(), huffmanCodes);
        System.out.println(Arrays.toString(bytes));*/

        // byte[] huffmanZipBytes = huffmanZip(str);
        // System.out.println(&quot;压缩后的结果：&quot; + Arrays.toString(huffmanZipBytes));
        // System.out.println(&quot;压缩后长度为：&quot; + huffmanZipBytes.length);
        //
        // // 测试解压
        // // 解码过后的字符串
        // byte[] decode = decode(huffmanCodes, huffmanZipBytes);
        // System.out.println(&quot;解码过后的字符串：&quot; + new String(decode));

    }

    /**
     * 对huffmanZip重载
     *
     * @param bytes 传入字符串对应的byte[]
     * @return 返回压缩后的对应的byte[]
     */
    public static byte[] huffmanZip(byte[] bytes) {
        // 创建其对应的赫夫曼树
        Node tree = createHuffmanTree(bytes);

        // 得到赫夫曼编码
        huffmanCodes = getCodes(tree);
        return zip(bytes, huffmanCodes);
    }

    /**
     * 将字符串用赫夫曼编码压缩
     *
     * @param str 传入字符串
     * @return 返回压缩后的对应的byte[]
     */
    public static byte[] huffmanZip(String str) {
        // 得到str对应的byte[]
        byte[] strBytes = str.getBytes();
        // 创建其对应的赫夫曼树
        Node tree = createHuffmanTree(strBytes);

        // 得到赫夫曼编码
        huffmanCodes = getCodes(tree);
        return zip(strBytes, huffmanCodes);
    }

    /**
     * 构建赫夫曼树
     *
     * @param strBytes 传入字符串对应的byte[]
     * @return 返回赫夫曼树的根节点
     */
    public static Node createHuffmanTree(byte[] strBytes) {
        // 统计字符串中各个字符的出现次数
        List&lt;Node&gt; nodes = getCharNum(strBytes);
        // 构建赫夫曼树
        while (nodes.size() &gt; 1) {
            Collections.sort(nodes);    // 从小到大排序
            Node leftNode = nodes.get(0); // 取出最小的结点
            Node rightNode = nodes.get(1);    // 取出第二小的结点
            // 将两个子节点的num相加组成新的根节点
            Node parent = new Node(null, leftNode.num + rightNode.num);
            // 设置根节点的左右子节点
            parent.left = leftNode;
            parent.right = rightNode;

            // 把两个子节点从nodes中删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            // 将parent加入nodes
            nodes.add(parent);
        }
        // 返回赫夫曼树根节点
        return nodes.get(0);
    }

    /**
     * 统计字符串中各个字符的出现次数
     *
     * @param strBytes 字符串对应的byte[]
     */
    public static List&lt;Node&gt; getCharNum(byte[] strBytes) {
        List&lt;Node&gt; nodes = new ArrayList&lt;&gt;();
        Map&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;();   // 用map接收[key，value], key = data, value = num

        for (byte b : strBytes) {
            // 从map中获取该字符的次数
            // 如果map中没有该字符，则新加一个
            map.merge(b, 1, Integer::sum);
        }

        // 将map中的数据添加到nodes中
        for (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) {
            nodes.add(new Node(entry.getKey(), entry.getValue()));
        }

        return nodes;
    }

    /**
     * 重载getCodes方法
     *
     * @param node 传入赫夫曼树根结点
     * @return 返回赫夫曼编码
     */
    public static Map&lt;Byte, String&gt; getCodes(Node node) {
        if (node == null) {
            return null;
        }
        getCodes(node, &quot;&quot;, new StringBuilder());    // 递归获取赫夫曼编码表
        return huffmanCodes;
    }

    /**
     * 将赫夫曼树转为对应的赫夫曼编码
     *
     * @param node 传入节点
     * @param path 路径；左子结点为0，右子结点为1
     * @param stringPath 用于拼接路径
     */
    public static void getCodes(Node node, String path, StringBuilder stringPath) {
        StringBuilder newStringPath = new StringBuilder(stringPath);
        newStringPath.append(path);    // 拼接路径
        if (node.data == null) {    // data = null说明不是叶子结点
            // 左递归
            getCodes(node.left, &quot;0&quot;, newStringPath);
            // 右递归
            getCodes(node.right, &quot;1&quot;, newStringPath);
        } else {
            // 说明是叶子结点
            // 将拼接好的路径放入map中
            huffmanCodes.put(node.data, newStringPath.toString());
        }
    }

    /**
     * 将赫夫曼编码转成对应的byte[]
     *
     * @param strBytes 要压缩字符串对应的byte[]
     * @param huffmanCodes 赫夫曼编码
     * @return 赫夫曼编码转换后的byte[]
     */
    public static byte[] zip(byte[] strBytes, Map&lt;Byte, String&gt; huffmanCodes) {
        StringBuilder stringBuilder = new StringBuilder();
        for (byte strByte : strBytes) { // 将bytes转成赫夫曼编码对应的字符串
            stringBuilder.append(huffmanCodes.get(strByte));
        }

        // 将字符串以每8位进行分割组成byte[] huffmanCodeBytes
        int length;
        if (stringBuilder.length() % 8 == 0) {   // 能被8整除
            length = stringBuilder.length() / 8;
        } else {
            length = stringBuilder.length() / 8 + 1;
        }

        byte[] huffmanCodeBytes = new byte[length];
        int index = 0;  // huffmanCodeBytes下标
        for (int i = 0; i &lt; stringBuilder.length(); i += 8) {
            String subString;   // 存放分割的字符串
            if (i + 8 &gt; stringBuilder.length()) {
                subString = stringBuilder.substring(i);
            } else {
                subString = stringBuilder.substring(i, i + 8);
            }
            // 将分割成的字符串转换成二进制再转换成对应的byte
            huffmanCodeBytes[index] = (byte) Integer.parseInt(subString, 2);
            index++;
        }

        return huffmanCodeBytes;
    }

    /**
     * 对数据的解压
     *
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanCodeBytes 赫夫曼编码得到的字节数组
     * @return 原来的字符串对应的byte[]
     */
    public static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanCodeBytes) {
        // 1.先得到HuffmanBytes对应的二进制字符串
        StringBuilder sb = new StringBuilder();
        // 2.将byte[] 转成二进制字符串
        for (int i = 0; i &lt; huffmanCodeBytes.length; i++) {
            byte b = huffmanCodeBytes[i];
            // 判断是不是最后一个字节，如果是最后一个字节则不需要补码
            boolean flag = (i == huffmanCodeBytes.length - 1);
            sb.append(byteToBitString(b, !flag));
        }
        // 把字符串安装指定的赫夫曼编码进行解码
        // 把赫夫曼编码表进行调换，要反向查询
        Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;();
        for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) {
            map.put(entry.getValue(), entry.getKey());
        }

        List&lt;Byte&gt; list = new ArrayList&lt;&gt;();    // 创建一个集合，用来存放byte
        StringBuilder key = new StringBuilder();    // 用来拼接字符串
        for (int i = 0; i &lt; sb.length(); i++) {
            key.append(sb.charAt(i));
            Byte b = map.get(key.toString());
            if (b != null) {  // 如果map中有数据，说明找到一个，将其存放到List中
                list.add(b);
                key = new StringBuilder();  // 将sb2置空，重新扫描
            }
        }
        // 当for循环结束后，List中就存放了所有的字符
        byte[] result = new byte[list.size()];
        for (int i = 0; i &lt; result.length; i++) {
            result[i] = list.get(i);
        }
        return result;

    }

    /**
     * 将一个byte转成一个二进制的字符串
     *
     * @param b 传入byte
     * @param flag 标志是否需要补高位，如果是true，则需要补
     * @return 该b对应的二进制字符串（补码返回）
     */
    public static String byteToBitString(byte b, boolean flag) {
        int temp = b;    // 将b转成int
        if (flag) { // 如果为true则需要补码
            temp |= 256;
        }
        String str = Integer.toBinaryString(temp);  // 将int的temp转为二进制字符串
        if (flag || temp &lt; 0) { // 如果是需要补位或者输入的数小于零
            return str.substring(str.length() - 8);
        } else {
            return str;
        }

    }

    /**
     * 将文件进行压缩
     *
     * @param srcFile 目标文件地址
     * @param destFile 压缩后的文件地址
     */
    public static void zipFile(String srcFile, String destFile) {
        // 创建文件输入流
        FileInputStream is = null;
        // 创建文件输出流
        FileOutputStream os = null;
        // 创建文件输出流对应的ObjectOutputStream
        ObjectOutputStream oos = null;
        try {
            is = new FileInputStream(srcFile);
            byte[] b = new byte[is.available()];    // 创建byte[]，长度为文件大小
            // 读取文件
            is.read(b);
            byte[] huffmanZipBytes = huffmanZip(b); // 直接将byte[] 压缩
            os = new FileOutputStream(destFile);
            oos = new ObjectOutputStream(os);
            oos.write(huffmanZipBytes);    // 将赫夫曼编码后的字节数组写入压缩文件

            // 以对象流的方式写入赫夫曼编码，是为了以后可以恢复源文件
            // 注意一定要把赫夫曼编码写入压缩文件
            oos.writeObject(huffmanCodes);

        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            try {
                is.close();
                os.close();
                oos.close();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * 解压文件
     *
     * @param zipFile 解压的文件
     * @param destFile 将文件解压到的路径
     */
    public static void unZipFile(String zipFile, String destFile) {
        // 定义文件输入流
        InputStream is = null;
        // 定义对象输入流
        ObjectInputStream ois = null;
        // 文件输出流
        OutputStream os = null;
        try {
            is = new FileInputStream(zipFile);
            // 创建对象输入流
            ois = new ObjectInputStream(is);
            // 读取byte[]
            byte[] huffmanBytes = (byte[]) ois.readObject();
            Map&lt;Byte, String&gt; codes = (Map&lt;Byte, String&gt;) ois.readObject();

            // 解码
            byte[] decodeBytes = decode(codes, huffmanBytes);
            // 将bytes 写入到目标文件
            os = new FileOutputStream(destFile);
            // 写出数据到文件中
            os.write(decodeBytes);

        } catch (Exception e) {
            throw new RuntimeException(e);
        }finally {
            try {
                os.close();
                ois.close();
                is.close();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }

        }
    }
}

/**
 * 结点类
 * 要实现Comparable接口
 */
class Node implements Comparable&lt;Node&gt; {
    /**
     * 代表的字符
     */
    Byte data;
    /**
     * 代表字符的个数
     */
    int num;
    /**
     * 左子节点
     */
    Node left;
    /**
     * 右子节点
     */
    Node right;

    /**
     * 前序遍历
     */
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(Byte data, int num) {
        this.data = data;
        this.num = num;
    }

    @Override
    public String toString() {
        return &quot;Node{&quot; +
                &quot;data=&quot; + data +
                &quot;, num=&quot; + num +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        return this.num - o.num;
    }
}
</code></pre>
<h4 id="1134-">11.3.4 最佳实践-文件压缩</h4>
<p>思路：读取文件-&gt;   得到赫夫曼编码表   -&gt;    完成压缩</p>
<h4 id="1135-">11.3.5 最佳实践-文件解压(文件恢复)</h4>
<p>思路：读取压缩文件(数据和赫夫曼编码表)-&gt;    完成解压(文件恢复)</p>
<h4 id="1136">11.3.6 赫夫曼编码压缩文件注意事项</h4>
<ol>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化,    比如视频,ppt    等等文件 
   [举例压一个   .ppt]</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml  文件]</li>
<li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.</li>
</ol>
<h3 id="114">11.4 二叉排序树</h3>
<h4 id="1141">11.4.1 先看一个需求</h4>
<p>给你一个数列    (7,  3, 10,  12,  5,  1, 9)，要求能够高效的完成对数据的查询和添加</p>
<h4 id="1142">11.4.2 解决方案分析</h4>
<ul>
<li>使用<strong>数组</strong></li>
</ul>
<p><strong>数组未排序</strong>，优点：直接在数组尾添加，速度快。缺点：查找速度慢</p>
<p><strong>数组排序</strong>，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢</p>
<ul>
<li>使用链式存储-<strong>链表</strong></li>
</ul>
<p>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。</p>
<h4 id="1143">11.4.3 二叉排序树介绍</h4>
<p><strong>二叉排序树</strong>：BST: (Binary  Sort(Search) Tree),    对于二叉排序树的<strong>任何一个非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</strong>。
<strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p><img alt="image-20220912193945155" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220912193945155.png" /></p>
<h4 id="1144">11.4.4 二叉排序树创建和遍历</h4>
<p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如:   数组为   Array(7, 3,10,12,5,1,9)，创建成对应的二叉排序树为:</p>
<p><img alt="image-20220912194020846" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220912194020846.png" /></p>
<h4 id="1145">11.4.5 二叉排序树的删除</h4>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p>
<ol>
<li>删除叶子节点   (比如：2,  5,  9,  12)</li>
<li>删除只有一颗子树的节点    (比如：1)</li>
<li>删除有两颗子树的节点.  (比如：7,  3，10  )</li>
<li>操作的思路分析</li>
</ol>
<p><img alt="image-20220912194037143" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220912194037143.png" /></p>
<pre><code class="language-java">//对删除结点的各种情况的思路分析:
第一种情况:
删除叶子节点 (比如：2,  5,  9,  12) 
思路
(1) 需求先去找到要删除的结点 targetNode
(2) 找到 targetNode 的 父结点 parent
(3) 确定 targetNode 是 parent 的左子结点 还是右子结点
(4) 根据前面的情况来对应删除 
    左子结点 parent.left  = null 
    右子结点 parent.right  =  null;

第二种情况: 删除只有一颗子树的节点，比如 1 
思路
(1) 需求先去找到要删除的结点targetNode
(2) 找到 targetNode 的父结点 parent
(3) 确定 targetNode 的子结点是左子结点还是右子结点
(4) targetNode 是 parent 的左子结点还是右子结点
(5) 如果 targetNode 有左子结点
5.1 如果 targetNode 是 parent 的左子结点
    parent.left  = targetNode.left;
5.2 如果 targetNode 是 parent 的右子结点
    parent.right = targetNode.left;
(6) 如果 targetNode 有右子结点
6.1 如果 targetNode 是 parent 的左子结点
    parent.left = targetNode.right;
6.2 如果 targetNode 是 parent 的右子结点
    parent.right  =  targetNode.right

情况三：删除有两颗子树的节点. (比如：7,  3，10  ) 
思路
(1) 需求先去找到要删除的结点 targetNode
(2) 找到  targetNode 的父结点    parent
(3) 从 targetNode 的右子树找到最小的结点
(4) 用一个临时变量，将最小结点的值保存 temp = 11
(5) 删除该最小结点
(6) targetNode.value = temp
</code></pre>
<h4 id="1146">11.4.6 二叉排序树的代码实现</h4>
<pre><code class="language-java">package binarysorttree;

/**
 * 二叉排序树模块
 */
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};
        BinarySortTree tree = new BinarySortTree();
        // 循环添加结点到二叉排序树
        for (int item : arr) {
            tree.add(new Node(item));
        }
        // 中序遍历，测试二叉排序树
        System.out.println(&quot;删除前&quot;);
        tree.infixOrder();

        // 测试删除叶子结点
        // tree.deleteNode(2);
        // tree.deleteNode(5);
        // tree.deleteNode(9);
        // System.out.println(&quot;删除叶子结点后&quot;);
        // tree.infixOrder();

        // 测试删除只有一个子结点的结点
        // tree.deleteNode(1);
        // System.out.println(&quot;删除只有一个子结点的结点后&quot;);
        // tree.infixOrder();

        // 测试删除有两个子节点的节点
        // tree.deleteNode(10);
        // System.out.println(&quot;删除有两个子结点的结点后&quot;);
        // tree.infixOrder();

        tree.deleteNode(2);
        tree.deleteNode(5);
        tree.deleteNode(9);
        tree.deleteNode(12);
        tree.deleteNode(7);
        tree.deleteNode(3);
        tree.deleteNode(10);
        tree.deleteNode(1);
        tree.infixOrder();
    }
}

/**
 * 二叉排序树
 */
class BinarySortTree {
    /**
     * 二叉排序树根节点
     */
    private Node root;

    /**
     * 查找目标结点
     *
     * @param value 传入值
     * @return 找到返回，没找到返回null
     */
    public Node searchNode(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchNode(value);
        }
    }

    /**
     * 查找目标结点的父节点
     *
     * @param value 传入value
     * @return 找到则返回，没找到则返回null
     */
    public Node searchParentNode(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchParentNode(value);
        }
    }

    /**
     * 删除结点
     *
     * @param value 要删除结点的value
     */
    public void deleteNode(int value) {
        if (root == null) {
            return;
        }
        if (root.left == null &amp;&amp; root.right == null) {  // 只有root节点
            if (root.value == value) {
                root = null;
                return;
            }
        }
        // 查找目标结点
        Node targetNode = searchNode(value);
        if (targetNode == null) {   // 没找到目标结点
            System.out.println(&quot;没有找到目标结点&quot;);
            return;
        }
        // 查找目标结点的父节点
        Node parentNode = searchParentNode(value);
        if (targetNode.left == null &amp;&amp; targetNode.right == null) {  // 是叶子结点
            // 判断目标结点在父节点的左子结点还是右子结点
            if (parentNode.left != null &amp;&amp; parentNode.left == targetNode) {    // 是左子结点
                parentNode.left = null;
            } else if (parentNode.right != null &amp;&amp; parentNode.right == targetNode) { // 是右子结点
                parentNode.right = null;
            }
        } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 要删除的是有两个子结点的根节点
            // 找到目标结点的右子树中的最小结点并替换目标结点的value
            targetNode.value = deleteRightTreeMin(targetNode);  // 已经删除最小结点
        } else { // 是只有一个子结点的根节点
            if (targetNode.left != null) {  // 目标结点有左子结点
                if (parentNode != null) {
                    // 目标结点是父节点的左子结点
                    if (parentNode.left != null &amp;&amp; parentNode.left.value == targetNode.value) {
                        parentNode.left = targetNode.left;
                    } else { // 目标结点是父节点的右子结点
                        parentNode.right = targetNode.left;
                    }
                } else {
                    root = targetNode.left;
                }
            } else { // 目标结点有右子结点
                if (parentNode != null) {
                    // 目标结点是父节点的左子结点
                    if (parentNode.left != null &amp;&amp; parentNode.left.value == targetNode.value) {
                        parentNode.left = targetNode.right;
                    } else { // 目标结点是父节点的右子结点
                        parentNode.right = targetNode.right;
                    }
                }else {
                    root = targetNode.right;
                }
            }
        }
    }

    /**
     * 删除根节点右子树的最小结点
     *
     * @param node 传入根节点
     * @return 返回以node为根节点的右子树中的最小结点的值
     */
    public int deleteRightTreeMin(Node node) {
        Node tempNode = node.right; // 搜索最小结点
        Node parentNode = node; // 最小结点的父节点
        // 找到最小结点，跟最小结点的父节点
        // 不管是否有右子结点，如果没有左子结点，则该结点必然最小
        while (tempNode.left != null) {
            parentNode = tempNode;
            tempNode = tempNode.left;
        }
        // 判断while循环有没有进行
        if (parentNode.value != node.value) {
            parentNode.left = null;
        } else { // while循环没进行，说明node节点只有一个右子结点
            parentNode.right = null;    // 将右子结点删除
        }
        return tempNode.value;
    }

    /**
     * 添加结点
     *
     * @param node 传入结点
     */
    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    /**
     * 中序遍历二叉排序树
     */
    public void infixOrder() {
        if (root == null) {
            throw new RuntimeException(&quot;根节点为空&quot;);
        }
        root.infixOrder();
    }
}

/**
 * 结点类
 */
class Node {
    /**
     * 值
     */
    int value;
    /**
     * 左子节点
     */
    Node left;
    /**
     * 右子节点
     */
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return &quot;Node{&quot; +
                &quot;value=&quot; + value +
                '}';
    }

    /**
     * 添加结点，满足二叉排序树的要求
     *
     * @param node 传入结点
     */
    public void add(Node node) {
        if (node == null) {
            throw new RuntimeException(&quot;结点为空&quot;);
        }
        if (node.value &lt;= this.value) { // 传入结点的value小于当前结点的value
            if (this.left == null) {    // 如果当前结点的左子结点为null
                this.left = node;   // 将当前结点的左子结点 = 传入的结点
            } else {    // 如果不为空则继续向左子结点递归比较添加
                this.left.add(node);
            }
        } else { // 传入结点的value大于当前结点的value
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }
        }
    }

    /**
     * 中序遍历二叉排序树
     */
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    /**
     * 查找结点
     *
     * @param value 传入要删除结点的value
     * @return 找到返回该结点，没找到返回null
     */
    public Node searchNode(int value) {
        if (this.value == value) {  // 如果该结点等于要找的value
            return this;    // 返回该节点
        } else if (this.value &lt; value) {  // 如果右子结点的不为空，且该节点的value小于value
            if (this.right == null) {   // 如果没有右子结点
                return null;    // 返回null，没找到
            }
            return this.right.searchNode(value);
        } else {
            if (this.left == null) {
                return null;
            }
            return this.left.searchNode(value);
        }
    }

    /**
     * 查找目标结点的父节点
     *
     * @param value 目标结点的value
     * @return 找到返回，没找到返回null
     */
    public Node searchParentNode(int value) {
        boolean flag1 = this.left != null &amp;&amp; this.left.value == value;
        boolean flag2 = this.right != null &amp;&amp; this.right.value == value;
        if (flag1 || flag2) {    // 如果该节点的左右子结点有符合条件的则返回该节点
            return this;
        } else if (this.value &gt;= value &amp;&amp; this.left != null) {  // 如果该节点value小于目标节点的value，且左子结点不为空
            return this.left.searchParentNode(value);   // 递归查找左子结点
        } else if (this.value &lt; value &amp;&amp; this.right != null) {
            return this.right.searchParentNode(value);  // 递归查找右子结点
        } else {
            return null;    // 没找到
        }
    }
}
</code></pre>
<h3 id="115-avl">11.5 平衡二叉树(AVL  树)</h3>
<h4 id="1151">11.5.1 看一个案例(说明二叉排序树可能的问题)</h4>
<p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.
左边 BST 存在的问题分析:</p>
<ol>
<li>左子树全部为空，从形式上看，更像一个单链表.</li>
<li>插入速度没有影响</li>
<li>查询速度明显降低(因为需要依次比较)，不能发挥 BST 的优势，因为每次还需要比较左子树，其查询速度比单链表还慢</li>
<li>解决方案-平衡二叉树(AVL)</li>
</ol>
<h4 id="1152">11.5.2 基本介绍</h4>
<ol>
<li>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。</li>
<li>具有以下特点：它是<strong>一棵空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过1</strong>，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li>
<li>举例说明，看看下面哪些  AVL 树，为什么?</li>
</ol>
<p><img alt="image-20220914163013670" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914163013670.png" /></p>
<h4 id="1153-">11.5.3 应用案例-单旋转(左旋转)</h4>
<ol>
<li>要求:   给你一个数列，创建出对应的平衡二叉树.数列    {4,3,6,5,7,8}</li>
<li>思路分析(示意图)</li>
</ol>
<p><img alt="image-20220914163052196" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914163052196.png" /></p>
<pre><code class="language-java">/**
 * 左旋转
 */
public void leftRotate() {
    // 以当前结点的值创建新的结点
    Node newNode = new Node(value);
    // 新结点的左子结点，设置成当前结点的左子结点
    newNode.left = this.left;
    // 把新节点的右子结点设置成当前结点的右子结点的左子结点
    newNode.right = this.right.left;
    // 把当前结点的value设置成右子结点的值
    value = this.right.value;
    // 把当前结点的右子结点设置成当前结点的右子结点的右子结点
    right = right.right;
    // 把当前结点的左子结点设置成新节点
    left = newNode;
}
</code></pre>
<h4 id="1154-">11.5.4 应用案例-单旋转(右旋转)</h4>
<ol>
<li>要求:   给你一个数列，创建出对应的平衡二叉树.数列   {10,12,  8,  9,  7,  6}</li>
<li>思路分析(示意图)</li>
</ol>
<p><img alt="image-20220914163137480" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914163137480.png" /></p>
<pre><code class="language-java">/**
 * 右旋转
 */
public void rightRotate() {
    Node newNode = new Node(value);
    newNode.right = right;
    newNode.left = left.right;
    value = left.value;
    left = left.left;
    right = newNode;
}
</code></pre>
<h4 id="1155-">11.5.5 应用案例-双旋转</h4>
<p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列
int[] arr  = {10,11,7,6,8,9};       运行原来的代码可以看到，并没有转成   AVL 树. 
int[] arr  = {2,1,6,5,7,3};  //    运行原来的代码可以看到，并没有转成   AVL  树</p>
<ol>
<li>问题分析</li>
</ol>
<p><img alt="image-20220914163327119" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914163327119.png" /></p>
<ol>
<li>解决思路分析</li>
<li>当符号右旋转的条件时</li>
<li>如果它的左子树的右子树高度大于它的左子树的高度</li>
<li>对左子结点进行左旋转</li>
<li>然后对当前结点进行右旋转</li>
</ol>
<pre><code class="language-java">package avl;

/**
 * 平衡二叉树
 */
public class AvlTreeDemo {
    public static void main(String[] args) {
        int[] arr = {10, 11, 7, 6, 8, 9};
        AvlTree avlTree = new AvlTree();
        for (int item : arr) {
            avlTree.add(new Node(item));
        }
        avlTree.infixOrder();

        System.out.println(&quot;树的高度&quot; + avlTree.getRoot().height());
        System.out.println(&quot;树的左子树高度&quot; + avlTree.getRoot().getLeftHeight());
        System.out.println(&quot;树的右子树高度&quot; + avlTree.getRoot().getRightHeight());
        System.out.println(&quot;当前根结点为：&quot; + avlTree.getRoot());


    }
}

/**
 * 平衡二叉树
 */
class AvlTree {
    /**
     * 平衡二叉树根节点
     */
    private Node root;

    /**
     * 查找目标结点
     *
     * @param value 传入值
     * @return 找到返回，没找到返回null
     */
    public Node searchNode(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchNode(value);
        }
    }

    /**
     * 查找目标结点的父节点
     *
     * @param value 传入value
     * @return 找到则返回，没找到则返回null
     */
    public Node searchParentNode(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchParentNode(value);
        }
    }

    /**
     * 删除结点
     *
     * @param value 要删除结点的value
     */
    public void deleteNode(int value) {
        if (root == null) {
            return;
        }
        if (root.left == null &amp;&amp; root.right == null) {  // 只有root节点
            if (root.value == value) {
                root = null;
                return;
            }
        }
        // 查找目标结点
        Node targetNode = searchNode(value);
        if (targetNode == null) {   // 没找到目标结点
            System.out.println(&quot;没有找到目标结点&quot;);
            return;
        }
        // 查找目标结点的父节点
        Node parentNode = searchParentNode(value);
        if (targetNode.left == null &amp;&amp; targetNode.right == null) {  // 是叶子结点
            // 判断目标结点在父节点的左子结点还是右子结点
            if (parentNode.left != null &amp;&amp; parentNode.left == targetNode) {    // 是左子结点
                parentNode.left = null;
            } else if (parentNode.right != null &amp;&amp; parentNode.right == targetNode) { // 是右子结点
                parentNode.right = null;
            }
        } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { // 要删除的是有两个子结点的根节点
            // 找到目标结点的右子树中的最小结点并替换目标结点的value
            targetNode.value = deleteRightTreeMin(targetNode);  // 已经删除最小结点
        } else { // 是只有一个子结点的根节点
            if (targetNode.left != null) {  // 目标结点有左子结点
                if (parentNode != null) {
                    // 目标结点是父节点的左子结点
                    if (parentNode.left != null &amp;&amp; parentNode.left.value == targetNode.value) {
                        parentNode.left = targetNode.left;
                    } else { // 目标结点是父节点的右子结点
                        parentNode.right = targetNode.left;
                    }
                } else {
                    root = targetNode.left;
                }
            } else { // 目标结点有右子结点
                if (parentNode != null) {
                    // 目标结点是父节点的左子结点
                    if (parentNode.left != null &amp;&amp; parentNode.left.value == targetNode.value) {
                        parentNode.left = targetNode.right;
                    } else { // 目标结点是父节点的右子结点
                        parentNode.right = targetNode.right;
                    }
                } else {
                    root = targetNode.right;
                }
            }
        }
    }

    /**
     * 删除根节点右子树的最小结点
     *
     * @param node 传入根节点
     * @return 返回以node为根节点的右子树中的最小结点的值
     */
    public int deleteRightTreeMin(Node node) {
        Node tempNode = node.right; // 搜索最小结点
        Node parentNode = node; // 最小结点的父节点
        // 找到最小结点，跟最小结点的父节点
        // 不管是否有右子结点，如果没有左子结点，则该结点必然最小
        while (tempNode.left != null) {
            parentNode = tempNode;
            tempNode = tempNode.left;
        }
        // 判断while循环有没有进行
        if (parentNode.value != node.value) {
            parentNode.left = null;
        } else { // while循环没进行，说明node节点只有一个右子结点
            parentNode.right = null;    // 将右子结点删除
        }
        return tempNode.value;
    }

    /**
     * 添加结点
     *
     * @param node 传入结点
     */
    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    /**
     * 中序遍历平衡二叉树
     */
    public void infixOrder() {
        if (root == null) {
            return;
        }
        root.infixOrder();
    }

    public Node getRoot() {
        return root;
    }
}

/**
 * 结点类
 */
class Node {
    /**
     * 值
     */
    int value;
    /**
     * 左子节点
     */
    Node left;
    /**
     * 右子节点
     */
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return &quot;Node{&quot; +
                &quot;value=&quot; + value +
                '}';
    }

    /**
     * @return 返回该结点的左子树的高度
     */
    public int getLeftHeight() {
        if (left == null) {
            return 0;
        }
        return left.height();
    }

    /**
     * @return 返回该结点的右子树的高度
     */
    public int getRightHeight() {
        if (right == null) {
            return 0;
        }
        return right.height();
    }

    /**
     * 返回以该结点为根节点的树的高度
     *
     * @return 高度
     */
    public int height() {
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
    }

    /**
     * 添加结点，满足平衡二叉树的要求
     *
     * @param node 传入结点
     */
    public void add(Node node) {
        if (node == null) {
            throw new RuntimeException(&quot;结点为空&quot;);
        }
        if (node.value &lt;= this.value) { // 传入结点的value小于当前结点的value
            if (this.left == null) {    // 如果当前结点的左子结点为null
                this.left = node;   // 将当前结点的左子结点 = 传入的结点
            } else {    // 如果不为空则继续向左子结点递归比较添加
                this.left.add(node);
            }
        } else { // 传入结点的value大于当前结点的value
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }
        }
        // 如果右子树高度-左子树高度 &gt; 1，就左旋转
        if (getRightHeight() - getLeftHeight() &gt; 1) {
            // 如果它的右子树的左子树高度大于它的右子树的右子树的高度
            // 先对右子结点进行右旋转
            // 然后再对当前结点进行右旋转
            if (right != null &amp;&amp; right.getLeftHeight() &gt; right.getRightHeight()) {
                right.rightRotate();
            }
            leftRotate();
        } else if (getLeftHeight() - getRightHeight() &gt; 1) { // 如果左子树高度-右子树高度 &gt; 1，就右旋转
            // 如果它的左子树的右子树高度大于它的左子树的高度
            // 对左子结点进行左旋转
            // 然后再对当前结点进行右旋转
            if (left != null &amp;&amp; left.getRightHeight() &gt; left.getLeftHeight()) {
                left.leftRotate();
            }
            rightRotate();
        }
    }

    /**
     * 中序遍历平衡二叉树
     */
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    /**
     * 查找结点
     *
     * @param value 传入要删除结点的value
     * @return 找到返回该结点，没找到返回null
     */
    public Node searchNode(int value) {
        if (this.value == value) {  // 如果该结点等于要找的value
            return this;    // 返回该节点
        } else if (this.value &lt; value) {  // 如果右子结点的不为空，且该节点的value小于value
            if (this.right == null) {   // 如果没有右子结点
                return null;    // 返回null，没找到
            }
            return this.right.searchNode(value);
        } else {
            if (this.left == null) {
                return null;
            }
            return this.left.searchNode(value);
        }
    }

    /**
     * 查找目标结点的父节点
     *
     * @param value 目标结点的value
     * @return 找到返回，没找到返回null
     */
    public Node searchParentNode(int value) {
        boolean flag1 = this.left != null &amp;&amp; this.left.value == value;
        boolean flag2 = this.right != null &amp;&amp; this.right.value == value;
        if (flag1 || flag2) {    // 如果该节点的左右子结点有符合条件的则返回该节点
            return this;
        } else if (this.value &gt;= value &amp;&amp; this.left != null) {  // 如果该节点value小于目标节点的value，且左子结点不为空
            return this.left.searchParentNode(value);   // 递归查找左子结点
        } else if (this.value &lt; value &amp;&amp; this.right != null) {
            return this.right.searchParentNode(value);  // 递归查找右子结点
        } else {
            return null;    // 没找到
        }
    }

    /**
     * 左旋转
     */
    public void leftRotate() {
        // 以当前结点的值创建新的结点
        Node newNode = new Node(value);
        // 新结点的左子结点，设置成当前结点的左子结点
        newNode.left = this.left;
        // 把新节点的右子结点设置成当前结点的右子结点的左子结点
        newNode.right = this.right.left;
        // 把当前结点的value设置成右子结点的值
        value = this.right.value;
        // 把当前结点的右子结点设置成当前结点的右子结点的右子结点
        right = right.right;
        // 把当前结点的左子结点设置成新节点
        left = newNode;
    }

    /**
     * 右旋转
     */
    public void rightRotate() {
        Node newNode = new Node(value);
        newNode.right = right;
        newNode.left = left.right;
        value = left.value;
        left = left.left;
        right = newNode;
    }
}
</code></pre>
<h2 id="_13">十二、多路查找树</h2>
<h3 id="121-b">12.1 二叉树与 B  树</h3>
<h4 id="1211">12.1.1 二叉树的问题分析</h4>
<p>二叉树的操作效率较高，但是也存在问题,    请看下面的二叉树</p>
<p><img alt="image-20220914192753335" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914192753335.png" /></p>
<ol>
<li>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如  1  亿)，就存在如下问题:</li>
<li>问题  1：在构建二叉树时，需要多次进行  i/o  操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响</li>
<li>问题  2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</li>
</ol>
<h4 id="1212">12.1.2 多叉树</h4>
<ol>
<li>在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点， 
   就是多叉树（multiway tree）</li>
<li>后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</li>
<li>举例说明(下面  2-3  树就是一颗多叉树)</li>
</ol>
<p><img alt="image-20220914192835987" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914192835987.png" /></p>
<h4 id="1213-b">12.1.3 B 树的基本介绍</h4>
<p>B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。</p>
<p><img alt="image-20220914192859644" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914192859644.png" /></p>
<ol>
<li>如图 B 树通过重新组织节点，降低了树的高度.</li>
<li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为 4k)， 
   这样每个节点只需要一次  I/O 就可以完全载入</li>
<li>将树的度 M  设置为  1024，在  600  亿个元素中最多只需要  4  次  I/O 操作就可以读取到想要的元素,  B  树(B+)广泛 
   应用于文件存储系统以及数据库系统中</li>
</ol>
<h3 id="122-2-3">12.2 2-3  树</h3>
<h4 id="1221-2-3-b">12.2.1 2-3 树是最简单的  B  树结构,   具有如下特点:</h4>
<ol>
<li>2-3  树的所有叶子节点都在同一层.(只要是  B  树都满足这个条件)</li>
<li>
<p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
</li>
<li>
<p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</p>
</li>
<li>
<p>2-3  树是由二节点和三节点构成的树。</p>
</li>
</ol>
<h4 id="1222-2-3">12.2.2 2-3 树应用案例</h4>
<p>将数列{16,  24,  12,  32,  14,  26,  34,  10,  8,  28,  38,  20}构建成  2-3  树，并保证数据插入的大小顺序。</p>
<p><img alt="image-20220914192948582" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914192948582.png" /></p>
<p>插入规则:
1. 2-3  树的所有叶子节点都在同一层.(只要是  B  树都满足这个条件)
2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层， 
   拆后仍然需要满足上面  3 个条件。
5. 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</p>
<h4 id="1223">12.2.3 其它说明</h4>
<p>除了  23  树，还有  234  树等，概念和  23  树类似，也是一种 B 树。    如图:</p>
<p><img alt="image-20220914193014529" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914193014529.png" /></p>
<h3 id="123-b-b-b">12.3 B  树、B+树和  B*树</h3>
<h4 id="1231-b">12.3.1 B 树的介绍</h4>
<p>B-tree  树即  B  树，B  即  Balanced，平衡的意思。有人把  B-tree  翻译成  B-树，容易让人产生误解。会以为  B-树是一种树，而  B 树又是另一种树。实际上，B-tree  就是指的  B  树。</p>
<h4 id="1232-b">12.3.2 B 树的介绍</h4>
<p>前面已经介绍了  2-3  树和  2-3-4  树，他们就是 B  树(英语：B-tree    也写成  B-树)，这里我们再做一个说明，我们在学习  Mysql  时，经常听到说某种类型的索引是基于  B  树或者  B+树的，如图:</p>
<p><img alt="image-20220914193117245" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914193117245.png" /></p>
<p>对上图的说明:</p>
<ol>
<li>B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li>
<li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中,    即叶子节点和非叶子节点都存放数据.</li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<h4 id="1233-b">12.3.3 B+树的介绍</h4>
<p>B+树是 B 树的变体，也是一种多路搜索树。</p>
<p><img alt="image-20220914193203927" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914193203927.png" /></p>
<p>对上图的说明:</p>
<ol>
<li>B+树的搜索与  B 树也基本相同，区别是  B+树只有达到叶子结点才命中（B  树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li>
<li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B 树和 B+树各有自己的应用场景，不能说  B+树完全比  B  树好，反之亦然.</li>
</ol>
<h4 id="1234-b">12.3.4 B*树的介绍</h4>
<p>B<em>树是 B+树的变体，在  B+树的非根和非叶子结点再增加</em><em>指向兄弟的指针</em>*。</p>
<p><img alt="image-20220914193258759" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220914193258759.png" /></p>
<p>B*树的说明:</p>
<ol>
<li>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为  2/3，而  B+树的块的最低使用率为的1/2。</li>
<li>从第 1 个特点我们可以看出，B*树分配新结点的概率比  B+树要低，空间使用率更高</li>
</ol>
<h2 id="_14">十三、图</h2>
<h3 id="131">13.1 图基本介绍</h3>
<h4 id="1311">13.1.1 为什么要有图</h4>
<ol>
<li>前面我们学了线性表和树</li>
<li>线性表局限于一个直接前驱和一个直接后继的关系</li>
<li>树也只能有一个直接前驱也就是父节点</li>
<li>当我们需要表示多对多的关系时，    这里我们就用到了图。</li>
</ol>
<h4 id="1312">13.1.2 图的举例说明</h4>
<p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。如图：</p>
<p><img alt="image-20220915125023323" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220915125023323.png" /></p>
<h3 id="1313">13.1.3 图的常用概念</h3>
<ol>
<li>顶点(vertex)</li>
<li>边(edge)</li>
<li>路径</li>
<li>无向图</li>
</ol>
<p><img alt="image-20220915125049664" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220915125049664.png" /></p>
<ol>
<li>
<p>有向图</p>
</li>
<li>
<p>带权图</p>
</li>
</ol>
<p><img alt="image-20220915125103560" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220915125103560.png" /></p>
<h3 id="132">13.2 图的表示方式</h3>
<p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h4 id="1321">13.2.1 邻接矩阵</h4>
<p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1....n个点。</p>
<p><img alt="image-20220915125137674" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220915125137674.png" /></p>
<h4 id="1322">13.2.2 邻接表</h4>
<ol>
<li>邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失.</li>
<li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</li>
<li>举例说明</li>
</ol>
<p><img alt="image-20220915125156068" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220915125156068.png" /></p>
<h3 id="133">13.3 图的快速入门案例</h3>
<ol>
<li>要求:   代码实现如下图结构.</li>
</ol>
<p><img alt="image-20220916193613034" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220916193613034.png" /></p>
<ol>
<li>
<p>思路分析 (1) 存储顶点 String 使用 ArrayList (2) 保存矩阵 int[][] edges</p>
</li>
<li>
<p>代码实现</p>
</li>
</ol>
<h3 id="134">13.4 图的深度优先遍历介绍</h3>
<h4 id="1341">13.4.1 图遍历介绍</h4>
<p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种 
访问策略: (1)深度优先遍历    (2)广度优先遍历</p>
<h4 id="1342">13.4.2 深度优先遍历基本思想</h4>
<p>图的深度优先搜索(Depth  First Search)   。</p>
<ol>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解： 每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li>
<li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>显然，深度优先搜索是一个递归的过程</li>
</ol>
<h5 id="1343">13.4.3 深度优先遍历算法步骤</h5>
<ol>
<li>访问初始结点 v，并标记结点 v  为已访问。</li>
<li>查找结点 v  的第一个邻接结点 w。</li>
<li>若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1  步，将从 v  的下一个结点继续。</li>
<li>若 w 未被访问，对 w 进行深度优先遍历递归（即把  w 当做另一个 v，然后进行步骤  123）。</li>
<li>查找结点 v  的 w 邻接结点的下一个邻接结点，转到步骤 3。</li>
<li>分析图</li>
</ol>
<p><img alt="image-20220916193743804" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220916193743804.png" /></p>
<h3 id="135">13.5 图的广度优先遍历</h3>
<h4 id="1351">13.5.1 广度优先遍历基本思想</h4>
<ol>
<li>图的广度优先搜索(Broad  First  Search)  。</li>
<li>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</li>
</ol>
<h5 id="1352">13.5.2 广度优先遍历算法步骤</h5>
<ol>
<li>
<h4 id="v-v">访问初始结点 v  并标记结点 v  为已访问。</h4>
</li>
<li>
<p>结点 v  入队列</p>
</li>
<li>
<p>当队列非空时，继续执行，否则算法结束。</p>
</li>
<li>
<p>出队列，取得队头结点  u。</p>
</li>
<li>
<p>查找结点  u  的第一个邻接结点  w。</p>
</li>
<li>
<p>若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤：</p>
</li>
<li>
<p>若结点  w 尚未被访问，则访问结点  w 并标记为已访问。</p>
</li>
<li>
<p>结点  w 入队列</p>
</li>
<li>
<p>查找结点  u  的继  w 邻接结点后的下一个邻接结点  w，转到步骤  6。</p>
</li>
</ol>
<pre><code class="language-java">package graph;

import java.util.ArrayList;
import java.util.List;

public class GraphDemo {
    public static void main(String[] args) {
        // 测试图创建
        int n = 5;  // 顶点个数
        String[] vertex = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;};
        Graph graph = new Graph(n);
        for (int i = 0; i &lt; n; i++) {
            graph.insertVertex(vertex[i]);
        }
        // 添加边
        // A-B A-C B-C B-D B-E
        graph.insertEdges(0, 1, 1);
        graph.insertEdges(0, 2, 1);
        graph.insertEdges(1, 2, 1);
        graph.insertEdges(1, 3, 1);
        graph.insertEdges(1, 4, 1);
        graph.showGraph();
    }
}

class Graph {
    List&lt;String&gt; vertexList;    // 存储顶点集合
    int[][] edges; // 存储图对应的领结矩阵
    int numOfEdges; // 表示边的数目
    boolean[] isVisited; // 记录某个结点是否被访问

    /**
     * @param n 传入顶点数目
     */
    public Graph(int n) {
        vertexList = new ArrayList&lt;&gt;(n);
        isVisited = new boolean[n];
        edges = new int[n][n];
        numOfEdges = 0;
    }

    /**
     * 插入顶点
     *
     * @param vertex 传入顶点值
     */
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    /**
     * 添加边
     *
     * @param v1 表示点的下标，即第一个顶点的下标：&quot;A&quot; -&gt; &quot;B&quot; ==&gt; &quot;A&quot; -&gt; 0  &quot;B&quot; -&gt; 1
     * @param v2 表示点的下标，即第二个顶点的下标
     * @param weight 两个顶点之间的关系，1表示连接，0表示不连接
     */
    public void insertEdges(int v1, int v2, int weight) {
        // 是无向图，两个都要设置
        edges[v1][v2] = weight; // 两个顶点建立关系
        edges[v2][v1] = weight;
        numOfEdges++;   // 边的数量++
    }

    /**
     * @return 边的个数
     */
    public int getNumOfEdges() {
        return numOfEdges;
    }

    /**
     * @return 顶点的个数
     */
    public int getNumOfVertex() {
        return vertexList.size();
    }

    /**
     * 显示图
     */
    public void showGraph() {
        for (int[] edge : edges) {
            for (int item : edge) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
        }
    }

    /**
     * @param v1 第一个顶点
     * @param v2 第二个顶点
     * @return 返回两个顶点间的关系
     */
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    /**
     * 根据下标返回顶点
     *
     * @param index 传入下标 0-&gt;&quot;A&quot;  1-&gt;&quot;B&quot;
     * @return 返回对应顶点数据
     */
    public String getValueByIndex(int index) {
        return vertexList.get(index);
    }
}
</code></pre>
<h3 id="136-vs">13.6 图的深度优先 VS    广度优先</h3>
<p><img alt="image-20220916200236980" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220916200236980.png" /></p>
<h2 id="10">十四、程序员常用  10  种算法</h2>
<h3 id="141">14.1 二分查找算法(非递归)</h3>
<h4 id="1411">14.1.1 二分查找算法(非递归)介绍</h4>
<ol>
<li>前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式</li>
<li>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</li>
<li>二分查找法的运行时间为对数时间 O(log~2~^n^)   ，即查找到需要的目标位置最多只需要㏒₂n  步，假设从[0,99]的队列(100  个数，即  n=100)中寻到目标数 30，则需要查找步数为log~2~^100^ ,   即最多需要查找 7 次(  2^6^ &lt; 100 &lt; 2^7^)</li>
</ol>
<h4 id="1412">14.1.2 二分查找算法(非递归)代码实现</h4>
<pre><code class="language-java">package binarysearch;

/**
 * 二分查找，非递归
 */
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1, 3, 8, 10, 11, 67, 100};
        int index = binarySearch(arr, -8);
        System.out.println(&quot;index = &quot; + index);
    }

    /**
     * 二分查找算法，非递归
     *
     * @param arr 待查找的数组，升序排列
     * @param target 目标数
     * @return 返回对应下标，-1表示未找到
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;   // 左边出示下标
        int right = arr.length - 1; // 右边初始下标
        int mid;    // 中间下标
        // 只要left &lt;= right就一直找
        while (left &lt;= right) {
            mid = (left + right) / 2;
            if (arr[mid] &gt; target) {    // 中间数字比目标大
                right = mid - 1;    // 说明目标在左边
            } else if (arr[mid] &lt; target) {
                left = mid + 1; // 说明在右边
            } else {
                return mid; // 找到
            }
        }
        return -1;  // 没找到
    }
}
</code></pre>
<h3 id="142">14.2 分治算法</h3>
<h4 id="1421">14.2.1 分治算法介绍</h4>
<ol>
<li>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</li>
<li>分治算法可以求解的一些经典问题</li>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>棋盘覆盖</li>
<li>合并排序</li>
<li>快速排序</li>
<li>线性时间选择</li>
<li>最接近点对问题</li>
<li>循环赛日程表</li>
<li>汉诺塔</li>
</ol>
<h4 id="1422">14.2.2 分治算法的基本步骤</h4>
<p>分治法在每一层递归上都有三个步骤：</p>
<ol>
<li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>合并：将各个子问题的解合并为原问题的解。</li>
</ol>
<h4 id="1423-divide-and-conquerp">14.2.3 分治(Divide-and-Conquer(P))算法设计模式如下：</h4>
<p><img alt="image-20220916205358830" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220916205358830.png" /></p>
<h4 id="1424-">14.2.4 分治算法最佳实践-汉诺塔</h4>
<ol>
<li>如果是有一个盘，   A-&gt;C
   如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 (1)最下边的盘 (2) 上面的盘</li>
<li>先把最上面的盘   A-&gt;B</li>
<li>把最下边的盘   A-&gt;C</li>
<li>把  B 塔的所有盘    从    B-&gt;C</li>
</ol>
<pre><code class="language-java">package dac;

/**
 * 汉诺塔
 */
public class HanoiTower {
    public static void main(String[] args) {
        hanoiTower(5, 'A', 'B', 'C');
    }

    /**
     * 汉诺塔
     *
     * @param num 有几个盘子不在正确的位置
     * @param a 从哪开始
     * @param b 借助那个
     * @param c 移动到哪
     */
    public static void hanoiTower(int num, char a, char b, char c) {
        // 如果只有一个盘子
        if (num == 1) {
            System.out.println(&quot;第1个盘子从：&quot; + a + &quot;-&gt;&quot; + c);   // 直接从A-&gt;c
        } else {
            // 如果是num&gt;=2
            // 把盘子看成两个部分
            // 1.最下面的一个盘子
            // 2.上面的所有盘子
            hanoiTower(num - 1, a, c, b);   // 把盘子从A-&gt;b，中间借助C
            System.out.println(&quot;第&quot; + (num) + &quot;个盘子从：&quot; + a + &quot;-&gt;&quot; + c);
            hanoiTower(num - 1, b, a, c); // 把B中剩下的所有盘子移动到C，借助A
        }
    }
}
</code></pre>
<h3 id="143">14.3 动态规划算法</h3>
<h4 id="1431-">14.3.1 应用场景-背包问题</h4>
<p>背包问题：有一个背包，容量为4磅，现有如下物品</p>
<p><img alt="image-20220921165255426" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921165255426.png" /></p>
<ol>
<li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li>
<li>要求装人的物品不能重复</li>
</ol>
<h4 id="1432">14.3.2 动态规划算法介绍</h4>
<ol>
<li>动态规划(Dynamic Programming)算法的核心思想是：将<strong>大问题划分为小问题</strong>进行解决，从而一步步获取最优解的处理算法</li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）</li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解</li>
</ol>
<h4 id="1433-">14.3.3 动态规划算法最佳实践-背包问题</h4>
<p>背包问题：有一个背包，容量为4磅，现有如下物品</p>
<p><img alt="image-20220921165255426" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921165255426.png" /></p>
<ol>
<li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li>
<li>要求装人的物品不能重复</li>
<li>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分 <strong>01背包</strong>和<strong>完全背包</strong>(完全背包指的是：每种物品都有无限件可用)</li>
<li>这里的问题属于<strong>01背包</strong>，即每个物品最多放一个。而无限背包可以转化为01背包</li>
<li>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据 w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i] [j]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果</li>
</ol>
<pre><code class="language-java">(1)v[i][0]=v[0][j]=0;  //表示 填入表第一行和第一列是0
(2)当 w[i]&gt; j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略
(3)当 j&gt;=w[i]时：v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}
// 当准备加入的新增的商品的容量小于等于当前背包的容量, 
// 装入的方式:
v[i-1][j]：就是上一个单元格的装入的最大值 
v[i]：表示当前商品的价值
v[i-1][j-w[i]]：装入  i-1  商品，到剩余空间 j-w[i]的最大值 
当j&gt;=w[i]时：v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}
</code></pre>
<p><img alt="image-20220921165817680" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921165817680.png" /></p>
<pre><code class="language-java">package dp;

/**
 * 背包问题
 */
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] weights = {1, 4, 3};  // 物品的重量
        int[] values = {1500, 3000, 2000}; // 物品的价值
        int m = 4;  // 背包容量
        int n = values.length;  // 物品的数量

        // v[i][j] 表示在前i个物品中能装入容量为j的背包中的最大价值
        int[][] v = new int[n + 1][m + 1];
        // 定义一个数组放记录放入的商品
        int[][] paths = new int[n + 1][m + 1];


        for (int i = 1; i &lt; v.length; i++) {    // 忽略第一行 i表示第几个物品
            for (int j = 1; j &lt; v[0].length; j++) { // 忽略第一列 j表示背包容量
                if (weights[i - 1] &gt; j) {   // 当前物品的重量比背包容量大，就直接用上一个单元格的结果
                    v[i][j] = v[i - 1][j];
                } else {    // 当前物品的重量&lt;=背包容量，就比较上一个单元格的结果跟当前物品的价值加剩下重量物品的价格哪个大
                    // v[i][j] = Math.max(v[i - 1][j], values[i - 1] + v[i - 1][j - weights[i - 1]]);
                    if (v[i - 1][j] &lt; values[i - 1] + v[i - 1][j - weights[i - 1]]) {
                        v[i][j] = values[i - 1] + v[i - 1][j - weights[i - 1]];
                        paths[i][j] = 1;    // 不是之前表格中放过的物品就记录下来
                    } else {
                        v[i][j] = v[i - 1][j];
                    }
                }
            }
        }
        // 遍历所有情况
        for (int[] items : v) {
            for (int item : items) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
        }

        // 查看最终放入背包的物品是哪几个
        int i = paths.length - 1;
        int j = paths[0].length - 1;
        while (i &gt; 0 &amp;&amp; j &gt; 0) {
            if (paths[i][j] == 1) {
                System.out.printf(&quot;第%d个物品放入背包\n&quot;, i);
                j -= weights[i - 1];    // 放入第i个商品过后，背包容量的剩余空间就要改变
            }
            i--;
        }

        // 查看有那些情况是新放入的
        for (int[] path : paths) {
            for (int p : path) {
                System.out.print(p + &quot; &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="144-kmp">14.4 KMP  算法</h3>
<h4 id="1441-">14.4.1 应用场景-字符串匹配问题</h4>
<p>字符串匹配问题：：</p>
<ol>
<li>有一个字符串 str1 =  ""硅硅谷  尚硅谷你尚硅  尚硅谷你尚硅谷你尚硅你好""，和一个子串    str2="尚硅谷你尚硅 你"</li>
<li>现在要判断 str1 是否含有 str2，如果存在，就返回第一次出现的位置，如果没有，则返回-1</li>
</ol>
<h4 id="1442">14.4.2 暴力匹配算法</h4>
<p>如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串  str2  匹配到 j 位置，则有: </p>
<ol>
<li>如果当前字符匹配成功（即  str1[i] ==  str2[j]），则  i++，j++，继续匹配下一个字符</li>
<li>如果失配（即  str1[i]! =  str2[j]），令  i  = i  - (j  -  1)，j  = 0。相当于每次匹配失败时，i    回溯，j    被置为  0。</li>
<li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</li>
</ol>
<h4 id="1443-kmp">14.4.3 KMP  算法介绍</h4>
<ol>
<li>KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li>
<li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的 出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.</li>
<li>KMP  方法算法就利用之前判断过信息，通过一个  next  数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过  next 数组找到，前面匹配过的位置，省去了大量的计算时间</li>
<li>参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</li>
</ol>
<h4 id="1444-kmp-">14.4.4 KMP  算法最佳应用-字符串匹配问题</h4>
<p>字符串匹配问题：：</p>
<ol>
<li>有一个字符串    str1= "BBC ABCDAB ABCDABCDABDE"，和一个子串    str2="ABCDABD"</li>
<li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li>
<li>要求：使用  <strong>KMP  算法</strong>完成判断，不能使用简单的暴力匹配算法.</li>
</ol>
<p>思路分析图解</p>
<p>举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？</p>
<ol>
<li>首先，用 Str1 的第一个字符和 Str2  的第一个字符去比较，不符合，关键词向后移动一位</li>
</ol>
<p><img alt="image-20220921170445553" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170445553.png" /></p>
<ol>
<li>重复第一步，还是不符合，再后移</li>
</ol>
<p><img alt="image-20220921170500319" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170500319.png" /></p>
<ol>
<li>一直重复，直到 Str1 有一个字符与 Str2  的第一个字符符合为止</li>
</ol>
<p><img alt="image-20220921170513658" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170513658.png" /></p>
<ol>
<li>接着比较字符串和搜索词的下一个字符，还是符合。</li>
</ol>
<p><img alt="image-20220921170546672" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170546672.png" /></p>
<ol>
<li>遇到 Str1 有一个字符与 Str2  对应的字符不符合</li>
</ol>
<p><img alt="image-20220921170556167" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170556167.png" /></p>
<ol>
<li>这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 <strong>KMP 算法的想法是</strong>，设法利用这个已知信息，不要把”搜索位置”<strong>移回已经比较过的位置</strong>，继续把它向后移，这样就提高了效率。)</li>
</ol>
<p><img alt="image-20220921170640283" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170640283.png" /></p>
<ol>
<li>怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《<strong>部分匹配表</strong>》，这张表的产生在后面介绍</li>
</ol>
<p><img alt="image-20220921170702098" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170702098.png" /></p>
<ol>
<li>
<p>已知空格与  D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符  B  对应的”部分匹配值”为  2，因此按照下面的公式算出向后移动的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值。因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。</p>
</li>
<li>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为  0。
   所以，移动位数  = 2 - 0，结果为 2，于是将搜索词向后移 2 位。</p>
</li>
</ol>
<p><img alt="image-20220921170757469" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170757469.png" /></p>
<ol>
<li>因为空格与 A 不配，继续后移一位。</li>
</ol>
<p><img alt="image-20220921170807982" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170807982.png" /></p>
<ol>
<li>逐位比较，直到发现 C 与 D 不匹配。于是，移动位数  = 6  - 2，继续将搜索词向后移动    4    位。</li>
</ol>
<p><img alt="image-20220921170823585" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170823585.png" /></p>
<ol>
<li>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配）， 移动位数 = 7 - 0，再将搜索词向后移动    7   位，这里就不再重复了。</li>
</ol>
<p><img alt="image-20220921170844703" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170844703.png" /></p>
<ol>
<li>介绍《部分匹配表》怎么产生的。先介绍前缀，后缀是什么</li>
</ol>
<p><img alt="image-20220921170901325" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220921170901325.png" /></p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， 
－”A”的前缀和后缀都为空集，共有元素的长度为  0；
－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为  0； 
－”ABC”的前缀为[A, AB]，后缀为[BC,  C]，共有元素的长度  0；
－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD,  CD,  D]，共有元素的长度为  0；
－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA,  CDA,  DA, A]，共有元素为”A”，长度为  1； 
－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB,  CDAB,  DAB, AB,  B]，共有元素为”AB”， 
长度为  2；
－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD,  CDABD,  DABD, ABD,  BD, D]，共有元素的长度为 0。</p>
<ol>
<li>部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度- 部分匹配值），就可以来到第二个”AB”的位置。</li>
</ol>
<p>代码：</p>
<pre><code class="language-java">package kmp;

/**
 * 字符串匹配算法
 */
public class KmpAlgorithm {
    public static void main(String[] args) {
        String str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;;
        String str2 = &quot;ABCDABD&quot;;
        // int[] next = kmpNext(str2);
        // System.out.println(&quot;next = &quot; + Arrays.toString(next));

        int index = kmpSearch(str1, str2);
        System.out.println(&quot;index = &quot; + index);

    }

    /**
     * 字符串匹配kmp算法
     *
     * @param str1 传入源字符串
     * @param str2 子字符串
     * @return 找到返回第一个匹配的位置，没找到返回-1
     */
    public static int kmpSearch(String str1, String str2) {
        int[] next = kmpNext(str2);
        for (int i = 0, j = 0; i &lt; str1.length(); i++) {
            // 要考虑不相等的时候，*********核心代码
            while (j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) {
                j = next[j - 1];
            }

            if (str1.charAt(i) == str2.charAt(j)) { // 如果相等就往后继续比较
                j++;
            }
            if (j == str2.length()) {   // 说明找到了
                return i - j + 1;
            }
        }
        return -1;
    }

    /**
     * 得到字符串的部分匹配值表
     *
     * @param destStr 传入字符串
     * @return 返回对应的数组
     */
    public static int[] kmpNext(String destStr) {
        // 创建一个数组，用来表示字符串的部分匹配值表
        // 比如：ABCDAB -&gt; 000012
        int[] next = new int[destStr.length()];
        next[0] = 0;    // 第一个元素匹配值表对应的数字肯定是0
        for (int i = 1, j = 0; i &lt; destStr.length(); i++) {
            // 如果不相等则需要去前面找直到找到相等的
            while (j &gt; 0 &amp;&amp; destStr.charAt(i) != destStr.charAt(j)) {
                j = next[j - 1];
            }

            // 如果当前元素重复出现了，j++
            // 如：ABCDAB -&gt; 000012，i = 4  j = 0 -&gt; 'A' == 'A' -&gt; j++
            if (destStr.charAt(i) == destStr.charAt(j)) {
                j++;
            } /*else {  //不可直接置为0，虽然大部分情况都是一样的但是有BUG，如：AABAAA
                j = 0;
            }*/
            next[i] = j;    // 当前位置部分匹配值为j
        }
        return next;
    }
}
</code></pre>
<h3 id="145">14.5 贪心算法</h3>
<h4 id="1451-">14.5.1 应用场景-集合覆盖问题</h4>
<p>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。    如何选择最少的广播台，让所有的地区都可以接收到信号</p>
<p><img alt="image-20220922190614518" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220922190614518.png" /></p>
<h4 id="1452">14.5.2 贪心算法介绍</h4>
<ol>
<li>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</li>
<li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li>
</ol>
<h4 id="1453-">14.5.3 贪心算法最佳应用-集合覆盖</h4>
<ol>
<li>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。    如何选择最少的广播台，让所有 
   的地区都可以接收到信号
   <img alt="image-20220922190644141" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220922190644141.png" /></li>
<li>思路分析:
   如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假 
   设总的有  n  个广播台，则广播台的组合总共有
   2^n^-1个，假设每秒可以计算 10  个子集， 如图:</li>
</ol>
<p><img alt="image-20220922190746030" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220922190746030.png" /></p>
<p>使用贪婪算法，效率高:</p>
<ol>
<li>目前并没有算法可以快速计算得到准备的值，    使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合</li>
<li>遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）</li>
<li>将这个电台加入到一个集合中(比如 ArrayList),    想办法把该电台覆盖的地区在下次比较时去掉。</li>
<li>重复第  1  步<strong>直到覆盖了全部</strong>的地区</li>
</ol>
<p><img alt="image-20220922190825098" src="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.assets/image-20220922190825098.png" /></p>
<h4 id="1454">14.5.4 贪心算法注意事项和细节</h4>
<ol>
<li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li>
<li>比如上题的算法选出的是 K1, K2,  K3,  K5，符合覆盖了全部的地区</li>
<li>但是我们发现   K2, K3,K4,K5    也可以覆盖全部地区，如果 K2    的使用成本低于 K1,那么我们上题的    K1,  K2,  K3, K5  虽然是满足条件，但是并不是最优的.</li>
</ol>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.efa0ade1.min.js"></script>
      
    
  </body>
</html>